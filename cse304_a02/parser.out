Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ASSIGN
    DO

Grammar

Rule 0     S' -> program
Rule 1     program -> class_decl
Rule 2     program -> empty
Rule 3     class_decl -> class_decl class_decl
Rule 4     class_decl -> CLASS ID EXTENDS ID { class_body_decl }
Rule 5     class_decl -> CLASS ID { class_body_decl }
Rule 6     class_body_decl -> class_body_decl class_body_decl
Rule 7     class_body_decl -> field_decl
Rule 8     class_body_decl -> method_decl
Rule 9     class_body_decl -> constructor_decl
Rule 10    field_decl -> modifier var_decl
Rule 11    modifier -> PRIVATE STATIC
Rule 12    modifier -> PRIVATE
Rule 13    modifier -> PUBLIC STATIC
Rule 14    modifier -> PUBLIC
Rule 15    modifier -> STATIC
Rule 16    modifier -> empty
Rule 17    var_decl -> type variable ;
Rule 18    type -> INT
Rule 19    type -> FLOAT
Rule 20    type -> BOOLEAN
Rule 21    type -> ID
Rule 22    variable -> ID
Rule 23    method_decl -> modifier type ID ( optional_formals ) block
Rule 24    method_decl -> modifier VOID ID ( optional_formals ) block
Rule 25    constructor_decl -> modifier ID ( optional_formals ) block
Rule 26    optional_formals -> formals
Rule 27    optional_formals -> empty
Rule 28    formals -> formal_param , formals
Rule 29    formals -> formal_param
Rule 30    formal_param -> type variable
Rule 31    block -> { stmt }
Rule 32    block -> { }
Rule 33    stmt -> stmt stmt
Rule 34    stmt -> IF ( expr ) stmt ELSE stmt
Rule 35    stmt -> IF ( expr ) stmt
Rule 36    stmt -> WHILE ( expr ) stmt
Rule 37    stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
Rule 38    stmt -> RETURN optional_expr ;
Rule 39    stmt -> stmt_expr ;
Rule 40    stmt -> BREAK ;
Rule 41    stmt -> CONTINUE ;
Rule 42    stmt -> block
Rule 43    stmt -> var_decl
Rule 44    stmt -> ;
Rule 45    optional_expr -> expr
Rule 46    optional_expr -> empty
Rule 47    optional_stmt_expr -> stmt_expr
Rule 48    optional_stmt_expr -> empty
Rule 49    literal -> INT_CONST
Rule 50    literal -> FLOAT_CONST
Rule 51    literal -> STRING_CONST
Rule 52    literal -> NULL
Rule 53    literal -> TRUE
Rule 54    literal -> FALSE
Rule 55    primary -> literal
Rule 56    primary -> THIS
Rule 57    primary -> SUPER
Rule 58    primary -> ( expr )
Rule 59    primary -> NEW ID ( arguments )
Rule 60    primary -> NEW ID ( )
Rule 61    primary -> field_access
Rule 62    primary -> method_invocation
Rule 63    arguments -> expr
Rule 64    arguments -> expr , arguments
Rule 65    field_access -> primary . ID
Rule 66    field_access -> ID
Rule 67    method_invocation -> field_access ( arguments )
Rule 68    method_invocation -> field_access ( )
Rule 69    expr -> primary
Rule 70    expr -> assign
Rule 71    expr -> expr arith_op expr
Rule 72    expr -> expr bool_op expr
Rule 73    expr -> expr unary_op expr
Rule 74    assign -> field_access = expr
Rule 75    assign -> field_access PLUS PLUS
Rule 76    assign -> PLUS PLUS field_access
Rule 77    assign -> field_access MINUS MINUS
Rule 78    assign -> MINUS MINUS field_access
Rule 79    arith_op -> PLUS
Rule 80    arith_op -> MINUS
Rule 81    arith_op -> TIMES
Rule 82    arith_op -> DIVIDE
Rule 83    bool_op -> AND
Rule 84    bool_op -> OR
Rule 85    bool_op -> EQUALITY
Rule 86    bool_op -> INEQUALITY
Rule 87    bool_op -> LESSER
Rule 88    bool_op -> GREATER
Rule 89    bool_op -> LEQ
Rule 90    bool_op -> GEQ
Rule 91    unary_op -> PLUS
Rule 92    unary_op -> MINUS
Rule 93    unary_op -> NOT
Rule 94    stmt_expr -> assign
Rule 95    stmt_expr -> method_invocation
Rule 96    empty -> <empty>

Terminals, with rules where they appear

(                    : 23 24 25 34 35 36 37 58 59 60 67 68
)                    : 23 24 25 34 35 36 37 58 59 60 67 68
,                    : 28 64
.                    : 65
;                    : 17 37 37 38 39 40 41 44
=                    : 74
AND                  : 83
ASSIGN               : 
BOOLEAN              : 20
BREAK                : 40
CLASS                : 4 5
CONTINUE             : 41
DIVIDE               : 82
DO                   : 
ELSE                 : 34
EQUALITY             : 85
EXTENDS              : 4
FALSE                : 54
FLOAT                : 19
FLOAT_CONST          : 50
FOR                  : 37
GEQ                  : 90
GREATER              : 88
ID                   : 4 4 5 21 22 23 24 25 59 60 65 66
IF                   : 34 35
INEQUALITY           : 86
INT                  : 18
INT_CONST            : 49
LEQ                  : 89
LESSER               : 87
MINUS                : 77 77 78 78 80 92
NEW                  : 59 60
NOT                  : 93
NULL                 : 52
OR                   : 84
PLUS                 : 75 75 76 76 79 91
PRIVATE              : 11 12
PUBLIC               : 13 14
RETURN               : 38
STATIC               : 11 13 15
STRING_CONST         : 51
SUPER                : 57
THIS                 : 56
TIMES                : 81
TRUE                 : 53
VOID                 : 24
WHILE                : 36
error                : 
{                    : 4 5 31 32
}                    : 4 5 31 32

Nonterminals, with rules where they appear

arguments            : 59 64 67
arith_op             : 71
assign               : 70 94
block                : 23 24 25 42
bool_op              : 72
class_body_decl      : 4 5 6 6
class_decl           : 1 3 3
constructor_decl     : 9
empty                : 2 16 27 46 48
expr                 : 34 35 36 45 58 63 64 71 71 72 72 73 73 74
field_access         : 61 67 68 74 75 76 77 78
field_decl           : 7
formal_param         : 28 29
formals              : 26 28
literal              : 55
method_decl          : 8
method_invocation    : 62 95
modifier             : 10 23 24 25
optional_expr        : 37 38
optional_formals     : 23 24 25
optional_stmt_expr   : 37 37
primary              : 65 69
program              : 0
stmt                 : 31 33 33 34 34 35 36 37
stmt_expr            : 39 47
type                 : 17 23 30
unary_op             : 73
var_decl             : 10 43
variable             : 17 30

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . class_decl
    (2) program -> . empty
    (3) class_decl -> . class_decl class_decl
    (4) class_decl -> . CLASS ID EXTENDS ID { class_body_decl }
    (5) class_decl -> . CLASS ID { class_body_decl }
    (96) empty -> .

    CLASS           shift and go to state 4
    $end            reduce using rule 96 (empty -> .)

    program                        shift and go to state 1
    class_decl                     shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> class_decl .
    (3) class_decl -> class_decl . class_decl
    (3) class_decl -> . class_decl class_decl
    (4) class_decl -> . CLASS ID EXTENDS ID { class_body_decl }
    (5) class_decl -> . CLASS ID { class_body_decl }

    $end            reduce using rule 1 (program -> class_decl .)
    CLASS           shift and go to state 4

    class_decl                     shift and go to state 5

state 3

    (2) program -> empty .

    $end            reduce using rule 2 (program -> empty .)


state 4

    (4) class_decl -> CLASS . ID EXTENDS ID { class_body_decl }
    (5) class_decl -> CLASS . ID { class_body_decl }

    ID              shift and go to state 6


state 5

    (3) class_decl -> class_decl class_decl .
    (3) class_decl -> class_decl . class_decl
    (3) class_decl -> . class_decl class_decl
    (4) class_decl -> . CLASS ID EXTENDS ID { class_body_decl }
    (5) class_decl -> . CLASS ID { class_body_decl }

  ! shift/reduce conflict for CLASS resolved as shift
    $end            reduce using rule 3 (class_decl -> class_decl class_decl .)
    CLASS           shift and go to state 4

  ! CLASS           [ reduce using rule 3 (class_decl -> class_decl class_decl .) ]

    class_decl                     shift and go to state 5

state 6

    (4) class_decl -> CLASS ID . EXTENDS ID { class_body_decl }
    (5) class_decl -> CLASS ID . { class_body_decl }

    EXTENDS         shift and go to state 7
    {               shift and go to state 8


state 7

    (4) class_decl -> CLASS ID EXTENDS . ID { class_body_decl }

    ID              shift and go to state 9


state 8

    (5) class_decl -> CLASS ID { . class_body_decl }
    (6) class_body_decl -> . class_body_decl class_body_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) field_decl -> . modifier var_decl
    (23) method_decl -> . modifier type ID ( optional_formals ) block
    (24) method_decl -> . modifier VOID ID ( optional_formals ) block
    (25) constructor_decl -> . modifier ID ( optional_formals ) block
    (11) modifier -> . PRIVATE STATIC
    (12) modifier -> . PRIVATE
    (13) modifier -> . PUBLIC STATIC
    (14) modifier -> . PUBLIC
    (15) modifier -> . STATIC
    (16) modifier -> . empty
    (96) empty -> .

    PRIVATE         shift and go to state 15
    PUBLIC          shift and go to state 17
    STATIC          shift and go to state 16
    VOID            reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    INT             reduce using rule 96 (empty -> .)
    FLOAT           reduce using rule 96 (empty -> .)
    BOOLEAN         reduce using rule 96 (empty -> .)

    class_body_decl                shift and go to state 10
    field_decl                     shift and go to state 11
    method_decl                    shift and go to state 12
    constructor_decl               shift and go to state 13
    modifier                       shift and go to state 14
    empty                          shift and go to state 18

state 9

    (4) class_decl -> CLASS ID EXTENDS ID . { class_body_decl }

    {               shift and go to state 19


state 10

    (5) class_decl -> CLASS ID { class_body_decl . }
    (6) class_body_decl -> class_body_decl . class_body_decl
    (6) class_body_decl -> . class_body_decl class_body_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) field_decl -> . modifier var_decl
    (23) method_decl -> . modifier type ID ( optional_formals ) block
    (24) method_decl -> . modifier VOID ID ( optional_formals ) block
    (25) constructor_decl -> . modifier ID ( optional_formals ) block
    (11) modifier -> . PRIVATE STATIC
    (12) modifier -> . PRIVATE
    (13) modifier -> . PUBLIC STATIC
    (14) modifier -> . PUBLIC
    (15) modifier -> . STATIC
    (16) modifier -> . empty
    (96) empty -> .

    }               shift and go to state 21
    PRIVATE         shift and go to state 15
    PUBLIC          shift and go to state 17
    STATIC          shift and go to state 16
    VOID            reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    INT             reduce using rule 96 (empty -> .)
    FLOAT           reduce using rule 96 (empty -> .)
    BOOLEAN         reduce using rule 96 (empty -> .)

    class_body_decl                shift and go to state 20
    field_decl                     shift and go to state 11
    method_decl                    shift and go to state 12
    constructor_decl               shift and go to state 13
    modifier                       shift and go to state 14
    empty                          shift and go to state 18

state 11

    (7) class_body_decl -> field_decl .

    }               reduce using rule 7 (class_body_decl -> field_decl .)
    PRIVATE         reduce using rule 7 (class_body_decl -> field_decl .)
    PUBLIC          reduce using rule 7 (class_body_decl -> field_decl .)
    STATIC          reduce using rule 7 (class_body_decl -> field_decl .)
    VOID            reduce using rule 7 (class_body_decl -> field_decl .)
    ID              reduce using rule 7 (class_body_decl -> field_decl .)
    INT             reduce using rule 7 (class_body_decl -> field_decl .)
    FLOAT           reduce using rule 7 (class_body_decl -> field_decl .)
    BOOLEAN         reduce using rule 7 (class_body_decl -> field_decl .)


state 12

    (8) class_body_decl -> method_decl .

    }               reduce using rule 8 (class_body_decl -> method_decl .)
    PRIVATE         reduce using rule 8 (class_body_decl -> method_decl .)
    PUBLIC          reduce using rule 8 (class_body_decl -> method_decl .)
    STATIC          reduce using rule 8 (class_body_decl -> method_decl .)
    VOID            reduce using rule 8 (class_body_decl -> method_decl .)
    ID              reduce using rule 8 (class_body_decl -> method_decl .)
    INT             reduce using rule 8 (class_body_decl -> method_decl .)
    FLOAT           reduce using rule 8 (class_body_decl -> method_decl .)
    BOOLEAN         reduce using rule 8 (class_body_decl -> method_decl .)


state 13

    (9) class_body_decl -> constructor_decl .

    }               reduce using rule 9 (class_body_decl -> constructor_decl .)
    PRIVATE         reduce using rule 9 (class_body_decl -> constructor_decl .)
    PUBLIC          reduce using rule 9 (class_body_decl -> constructor_decl .)
    STATIC          reduce using rule 9 (class_body_decl -> constructor_decl .)
    VOID            reduce using rule 9 (class_body_decl -> constructor_decl .)
    ID              reduce using rule 9 (class_body_decl -> constructor_decl .)
    INT             reduce using rule 9 (class_body_decl -> constructor_decl .)
    FLOAT           reduce using rule 9 (class_body_decl -> constructor_decl .)
    BOOLEAN         reduce using rule 9 (class_body_decl -> constructor_decl .)


state 14

    (10) field_decl -> modifier . var_decl
    (23) method_decl -> modifier . type ID ( optional_formals ) block
    (24) method_decl -> modifier . VOID ID ( optional_formals ) block
    (25) constructor_decl -> modifier . ID ( optional_formals ) block
    (17) var_decl -> . type variable ;
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    VOID            shift and go to state 25
    ID              shift and go to state 24
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28

    var_decl                       shift and go to state 22
    type                           shift and go to state 23

state 15

    (11) modifier -> PRIVATE . STATIC
    (12) modifier -> PRIVATE .

    STATIC          shift and go to state 29
    VOID            reduce using rule 12 (modifier -> PRIVATE .)
    ID              reduce using rule 12 (modifier -> PRIVATE .)
    INT             reduce using rule 12 (modifier -> PRIVATE .)
    FLOAT           reduce using rule 12 (modifier -> PRIVATE .)
    BOOLEAN         reduce using rule 12 (modifier -> PRIVATE .)


state 16

    (15) modifier -> STATIC .

    VOID            reduce using rule 15 (modifier -> STATIC .)
    ID              reduce using rule 15 (modifier -> STATIC .)
    INT             reduce using rule 15 (modifier -> STATIC .)
    FLOAT           reduce using rule 15 (modifier -> STATIC .)
    BOOLEAN         reduce using rule 15 (modifier -> STATIC .)


state 17

    (13) modifier -> PUBLIC . STATIC
    (14) modifier -> PUBLIC .

    STATIC          shift and go to state 30
    VOID            reduce using rule 14 (modifier -> PUBLIC .)
    ID              reduce using rule 14 (modifier -> PUBLIC .)
    INT             reduce using rule 14 (modifier -> PUBLIC .)
    FLOAT           reduce using rule 14 (modifier -> PUBLIC .)
    BOOLEAN         reduce using rule 14 (modifier -> PUBLIC .)


state 18

    (16) modifier -> empty .

    VOID            reduce using rule 16 (modifier -> empty .)
    ID              reduce using rule 16 (modifier -> empty .)
    INT             reduce using rule 16 (modifier -> empty .)
    FLOAT           reduce using rule 16 (modifier -> empty .)
    BOOLEAN         reduce using rule 16 (modifier -> empty .)


state 19

    (4) class_decl -> CLASS ID EXTENDS ID { . class_body_decl }
    (6) class_body_decl -> . class_body_decl class_body_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) field_decl -> . modifier var_decl
    (23) method_decl -> . modifier type ID ( optional_formals ) block
    (24) method_decl -> . modifier VOID ID ( optional_formals ) block
    (25) constructor_decl -> . modifier ID ( optional_formals ) block
    (11) modifier -> . PRIVATE STATIC
    (12) modifier -> . PRIVATE
    (13) modifier -> . PUBLIC STATIC
    (14) modifier -> . PUBLIC
    (15) modifier -> . STATIC
    (16) modifier -> . empty
    (96) empty -> .

    PRIVATE         shift and go to state 15
    PUBLIC          shift and go to state 17
    STATIC          shift and go to state 16
    VOID            reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    INT             reduce using rule 96 (empty -> .)
    FLOAT           reduce using rule 96 (empty -> .)
    BOOLEAN         reduce using rule 96 (empty -> .)

    class_body_decl                shift and go to state 31
    field_decl                     shift and go to state 11
    method_decl                    shift and go to state 12
    constructor_decl               shift and go to state 13
    modifier                       shift and go to state 14
    empty                          shift and go to state 18

state 20

    (6) class_body_decl -> class_body_decl class_body_decl .
    (6) class_body_decl -> class_body_decl . class_body_decl
    (6) class_body_decl -> . class_body_decl class_body_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) field_decl -> . modifier var_decl
    (23) method_decl -> . modifier type ID ( optional_formals ) block
    (24) method_decl -> . modifier VOID ID ( optional_formals ) block
    (25) constructor_decl -> . modifier ID ( optional_formals ) block
    (11) modifier -> . PRIVATE STATIC
    (12) modifier -> . PRIVATE
    (13) modifier -> . PUBLIC STATIC
    (14) modifier -> . PUBLIC
    (15) modifier -> . STATIC
    (16) modifier -> . empty
    (96) empty -> .

  ! shift/reduce conflict for PRIVATE resolved as shift
  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! reduce/reduce conflict for VOID resolved using rule 6 (class_body_decl -> class_body_decl class_body_decl .)
  ! reduce/reduce conflict for ID resolved using rule 6 (class_body_decl -> class_body_decl class_body_decl .)
  ! reduce/reduce conflict for INT resolved using rule 6 (class_body_decl -> class_body_decl class_body_decl .)
  ! reduce/reduce conflict for FLOAT resolved using rule 6 (class_body_decl -> class_body_decl class_body_decl .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 6 (class_body_decl -> class_body_decl class_body_decl .)
    }               reduce using rule 6 (class_body_decl -> class_body_decl class_body_decl .)
    VOID            reduce using rule 6 (class_body_decl -> class_body_decl class_body_decl .)
    ID              reduce using rule 6 (class_body_decl -> class_body_decl class_body_decl .)
    INT             reduce using rule 6 (class_body_decl -> class_body_decl class_body_decl .)
    FLOAT           reduce using rule 6 (class_body_decl -> class_body_decl class_body_decl .)
    BOOLEAN         reduce using rule 6 (class_body_decl -> class_body_decl class_body_decl .)
    PRIVATE         shift and go to state 15
    PUBLIC          shift and go to state 17
    STATIC          shift and go to state 16

  ! PRIVATE         [ reduce using rule 6 (class_body_decl -> class_body_decl class_body_decl .) ]
  ! PUBLIC          [ reduce using rule 6 (class_body_decl -> class_body_decl class_body_decl .) ]
  ! STATIC          [ reduce using rule 6 (class_body_decl -> class_body_decl class_body_decl .) ]
  ! VOID            [ reduce using rule 96 (empty -> .) ]
  ! ID              [ reduce using rule 96 (empty -> .) ]
  ! INT             [ reduce using rule 96 (empty -> .) ]
  ! FLOAT           [ reduce using rule 96 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 96 (empty -> .) ]

    class_body_decl                shift and go to state 20
    field_decl                     shift and go to state 11
    method_decl                    shift and go to state 12
    constructor_decl               shift and go to state 13
    modifier                       shift and go to state 14
    empty                          shift and go to state 18

state 21

    (5) class_decl -> CLASS ID { class_body_decl } .

    CLASS           reduce using rule 5 (class_decl -> CLASS ID { class_body_decl } .)
    $end            reduce using rule 5 (class_decl -> CLASS ID { class_body_decl } .)


state 22

    (10) field_decl -> modifier var_decl .

    }               reduce using rule 10 (field_decl -> modifier var_decl .)
    PRIVATE         reduce using rule 10 (field_decl -> modifier var_decl .)
    PUBLIC          reduce using rule 10 (field_decl -> modifier var_decl .)
    STATIC          reduce using rule 10 (field_decl -> modifier var_decl .)
    VOID            reduce using rule 10 (field_decl -> modifier var_decl .)
    ID              reduce using rule 10 (field_decl -> modifier var_decl .)
    INT             reduce using rule 10 (field_decl -> modifier var_decl .)
    FLOAT           reduce using rule 10 (field_decl -> modifier var_decl .)
    BOOLEAN         reduce using rule 10 (field_decl -> modifier var_decl .)


state 23

    (23) method_decl -> modifier type . ID ( optional_formals ) block
    (17) var_decl -> type . variable ;
    (22) variable -> . ID

    ID              shift and go to state 32

    variable                       shift and go to state 33

state 24

    (25) constructor_decl -> modifier ID . ( optional_formals ) block
    (21) type -> ID .

    (               shift and go to state 34
    ID              reduce using rule 21 (type -> ID .)


state 25

    (24) method_decl -> modifier VOID . ID ( optional_formals ) block

    ID              shift and go to state 35


state 26

    (18) type -> INT .

    ID              reduce using rule 18 (type -> INT .)


state 27

    (19) type -> FLOAT .

    ID              reduce using rule 19 (type -> FLOAT .)


state 28

    (20) type -> BOOLEAN .

    ID              reduce using rule 20 (type -> BOOLEAN .)


state 29

    (11) modifier -> PRIVATE STATIC .

    VOID            reduce using rule 11 (modifier -> PRIVATE STATIC .)
    ID              reduce using rule 11 (modifier -> PRIVATE STATIC .)
    INT             reduce using rule 11 (modifier -> PRIVATE STATIC .)
    FLOAT           reduce using rule 11 (modifier -> PRIVATE STATIC .)
    BOOLEAN         reduce using rule 11 (modifier -> PRIVATE STATIC .)


state 30

    (13) modifier -> PUBLIC STATIC .

    VOID            reduce using rule 13 (modifier -> PUBLIC STATIC .)
    ID              reduce using rule 13 (modifier -> PUBLIC STATIC .)
    INT             reduce using rule 13 (modifier -> PUBLIC STATIC .)
    FLOAT           reduce using rule 13 (modifier -> PUBLIC STATIC .)
    BOOLEAN         reduce using rule 13 (modifier -> PUBLIC STATIC .)


state 31

    (4) class_decl -> CLASS ID EXTENDS ID { class_body_decl . }
    (6) class_body_decl -> class_body_decl . class_body_decl
    (6) class_body_decl -> . class_body_decl class_body_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) field_decl -> . modifier var_decl
    (23) method_decl -> . modifier type ID ( optional_formals ) block
    (24) method_decl -> . modifier VOID ID ( optional_formals ) block
    (25) constructor_decl -> . modifier ID ( optional_formals ) block
    (11) modifier -> . PRIVATE STATIC
    (12) modifier -> . PRIVATE
    (13) modifier -> . PUBLIC STATIC
    (14) modifier -> . PUBLIC
    (15) modifier -> . STATIC
    (16) modifier -> . empty
    (96) empty -> .

    }               shift and go to state 36
    PRIVATE         shift and go to state 15
    PUBLIC          shift and go to state 17
    STATIC          shift and go to state 16
    VOID            reduce using rule 96 (empty -> .)
    ID              reduce using rule 96 (empty -> .)
    INT             reduce using rule 96 (empty -> .)
    FLOAT           reduce using rule 96 (empty -> .)
    BOOLEAN         reduce using rule 96 (empty -> .)

    class_body_decl                shift and go to state 20
    field_decl                     shift and go to state 11
    method_decl                    shift and go to state 12
    constructor_decl               shift and go to state 13
    modifier                       shift and go to state 14
    empty                          shift and go to state 18

state 32

    (23) method_decl -> modifier type ID . ( optional_formals ) block
    (22) variable -> ID .

    (               shift and go to state 37
    ;               reduce using rule 22 (variable -> ID .)


state 33

    (17) var_decl -> type variable . ;

    ;               shift and go to state 38


state 34

    (25) constructor_decl -> modifier ID ( . optional_formals ) block
    (26) optional_formals -> . formals
    (27) optional_formals -> . empty
    (28) formals -> . formal_param , formals
    (29) formals -> . formal_param
    (96) empty -> .
    (30) formal_param -> . type variable
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    )               reduce using rule 96 (empty -> .)
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 39

    optional_formals               shift and go to state 40
    formals                        shift and go to state 41
    empty                          shift and go to state 42
    formal_param                   shift and go to state 43
    type                           shift and go to state 44

state 35

    (24) method_decl -> modifier VOID ID . ( optional_formals ) block

    (               shift and go to state 45


state 36

    (4) class_decl -> CLASS ID EXTENDS ID { class_body_decl } .

    CLASS           reduce using rule 4 (class_decl -> CLASS ID EXTENDS ID { class_body_decl } .)
    $end            reduce using rule 4 (class_decl -> CLASS ID EXTENDS ID { class_body_decl } .)


state 37

    (23) method_decl -> modifier type ID ( . optional_formals ) block
    (26) optional_formals -> . formals
    (27) optional_formals -> . empty
    (28) formals -> . formal_param , formals
    (29) formals -> . formal_param
    (96) empty -> .
    (30) formal_param -> . type variable
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    )               reduce using rule 96 (empty -> .)
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 39

    type                           shift and go to state 44
    optional_formals               shift and go to state 46
    formals                        shift and go to state 41
    empty                          shift and go to state 42
    formal_param                   shift and go to state 43

state 38

    (17) var_decl -> type variable ; .

    }               reduce using rule 17 (var_decl -> type variable ; .)
    PRIVATE         reduce using rule 17 (var_decl -> type variable ; .)
    PUBLIC          reduce using rule 17 (var_decl -> type variable ; .)
    STATIC          reduce using rule 17 (var_decl -> type variable ; .)
    VOID            reduce using rule 17 (var_decl -> type variable ; .)
    ID              reduce using rule 17 (var_decl -> type variable ; .)
    INT             reduce using rule 17 (var_decl -> type variable ; .)
    FLOAT           reduce using rule 17 (var_decl -> type variable ; .)
    BOOLEAN         reduce using rule 17 (var_decl -> type variable ; .)
    IF              reduce using rule 17 (var_decl -> type variable ; .)
    WHILE           reduce using rule 17 (var_decl -> type variable ; .)
    FOR             reduce using rule 17 (var_decl -> type variable ; .)
    RETURN          reduce using rule 17 (var_decl -> type variable ; .)
    BREAK           reduce using rule 17 (var_decl -> type variable ; .)
    CONTINUE        reduce using rule 17 (var_decl -> type variable ; .)
    ;               reduce using rule 17 (var_decl -> type variable ; .)
    {               reduce using rule 17 (var_decl -> type variable ; .)
    PLUS            reduce using rule 17 (var_decl -> type variable ; .)
    MINUS           reduce using rule 17 (var_decl -> type variable ; .)
    THIS            reduce using rule 17 (var_decl -> type variable ; .)
    SUPER           reduce using rule 17 (var_decl -> type variable ; .)
    (               reduce using rule 17 (var_decl -> type variable ; .)
    NEW             reduce using rule 17 (var_decl -> type variable ; .)
    INT_CONST       reduce using rule 17 (var_decl -> type variable ; .)
    FLOAT_CONST     reduce using rule 17 (var_decl -> type variable ; .)
    STRING_CONST    reduce using rule 17 (var_decl -> type variable ; .)
    NULL            reduce using rule 17 (var_decl -> type variable ; .)
    TRUE            reduce using rule 17 (var_decl -> type variable ; .)
    FALSE           reduce using rule 17 (var_decl -> type variable ; .)
    ELSE            reduce using rule 17 (var_decl -> type variable ; .)


state 39

    (21) type -> ID .

    ID              reduce using rule 21 (type -> ID .)


state 40

    (25) constructor_decl -> modifier ID ( optional_formals . ) block

    )               shift and go to state 47


state 41

    (26) optional_formals -> formals .

    )               reduce using rule 26 (optional_formals -> formals .)


state 42

    (27) optional_formals -> empty .

    )               reduce using rule 27 (optional_formals -> empty .)


state 43

    (28) formals -> formal_param . , formals
    (29) formals -> formal_param .

    ,               shift and go to state 48
    )               reduce using rule 29 (formals -> formal_param .)


state 44

    (30) formal_param -> type . variable
    (22) variable -> . ID

    ID              shift and go to state 50

    variable                       shift and go to state 49

state 45

    (24) method_decl -> modifier VOID ID ( . optional_formals ) block
    (26) optional_formals -> . formals
    (27) optional_formals -> . empty
    (28) formals -> . formal_param , formals
    (29) formals -> . formal_param
    (96) empty -> .
    (30) formal_param -> . type variable
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    )               reduce using rule 96 (empty -> .)
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 39

    optional_formals               shift and go to state 51
    formals                        shift and go to state 41
    empty                          shift and go to state 42
    formal_param                   shift and go to state 43
    type                           shift and go to state 44

state 46

    (23) method_decl -> modifier type ID ( optional_formals . ) block

    )               shift and go to state 52


state 47

    (25) constructor_decl -> modifier ID ( optional_formals ) . block
    (31) block -> . { stmt }
    (32) block -> . { }

    {               shift and go to state 54

    block                          shift and go to state 53

state 48

    (28) formals -> formal_param , . formals
    (28) formals -> . formal_param , formals
    (29) formals -> . formal_param
    (30) formal_param -> . type variable
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 39

    formal_param                   shift and go to state 43
    formals                        shift and go to state 55
    type                           shift and go to state 44

state 49

    (30) formal_param -> type variable .

    ,               reduce using rule 30 (formal_param -> type variable .)
    )               reduce using rule 30 (formal_param -> type variable .)


state 50

    (22) variable -> ID .

    ,               reduce using rule 22 (variable -> ID .)
    )               reduce using rule 22 (variable -> ID .)
    ;               reduce using rule 22 (variable -> ID .)


state 51

    (24) method_decl -> modifier VOID ID ( optional_formals . ) block

    )               shift and go to state 56


state 52

    (23) method_decl -> modifier type ID ( optional_formals ) . block
    (31) block -> . { stmt }
    (32) block -> . { }

    {               shift and go to state 54

    block                          shift and go to state 57

state 53

    (25) constructor_decl -> modifier ID ( optional_formals ) block .

    }               reduce using rule 25 (constructor_decl -> modifier ID ( optional_formals ) block .)
    PRIVATE         reduce using rule 25 (constructor_decl -> modifier ID ( optional_formals ) block .)
    PUBLIC          reduce using rule 25 (constructor_decl -> modifier ID ( optional_formals ) block .)
    STATIC          reduce using rule 25 (constructor_decl -> modifier ID ( optional_formals ) block .)
    VOID            reduce using rule 25 (constructor_decl -> modifier ID ( optional_formals ) block .)
    ID              reduce using rule 25 (constructor_decl -> modifier ID ( optional_formals ) block .)
    INT             reduce using rule 25 (constructor_decl -> modifier ID ( optional_formals ) block .)
    FLOAT           reduce using rule 25 (constructor_decl -> modifier ID ( optional_formals ) block .)
    BOOLEAN         reduce using rule 25 (constructor_decl -> modifier ID ( optional_formals ) block .)


state 54

    (31) block -> { . stmt }
    (32) block -> { . }
    (33) stmt -> . stmt stmt
    (34) stmt -> . IF ( expr ) stmt ELSE stmt
    (35) stmt -> . IF ( expr ) stmt
    (36) stmt -> . WHILE ( expr ) stmt
    (37) stmt -> . FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (38) stmt -> . RETURN optional_expr ;
    (39) stmt -> . stmt_expr ;
    (40) stmt -> . BREAK ;
    (41) stmt -> . CONTINUE ;
    (42) stmt -> . block
    (43) stmt -> . var_decl
    (44) stmt -> . ;
    (94) stmt_expr -> . assign
    (95) stmt_expr -> . method_invocation
    (31) block -> . { stmt }
    (32) block -> . { }
    (17) var_decl -> . type variable ;
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE

    }               shift and go to state 59
    IF              shift and go to state 60
    WHILE           shift and go to state 62
    FOR             shift and go to state 63
    RETURN          shift and go to state 65
    BREAK           shift and go to state 67
    CONTINUE        shift and go to state 68
    ;               shift and go to state 64
    {               shift and go to state 54
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 77
    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88

    stmt                           shift and go to state 58
    stmt_expr                      shift and go to state 66
    block                          shift and go to state 69
    var_decl                       shift and go to state 70
    assign                         shift and go to state 71
    method_invocation              shift and go to state 72
    type                           shift and go to state 73
    field_access                   shift and go to state 74
    primary                        shift and go to state 78
    literal                        shift and go to state 79

state 55

    (28) formals -> formal_param , formals .

    )               reduce using rule 28 (formals -> formal_param , formals .)


state 56

    (24) method_decl -> modifier VOID ID ( optional_formals ) . block
    (31) block -> . { stmt }
    (32) block -> . { }

    {               shift and go to state 54

    block                          shift and go to state 89

state 57

    (23) method_decl -> modifier type ID ( optional_formals ) block .

    }               reduce using rule 23 (method_decl -> modifier type ID ( optional_formals ) block .)
    PRIVATE         reduce using rule 23 (method_decl -> modifier type ID ( optional_formals ) block .)
    PUBLIC          reduce using rule 23 (method_decl -> modifier type ID ( optional_formals ) block .)
    STATIC          reduce using rule 23 (method_decl -> modifier type ID ( optional_formals ) block .)
    VOID            reduce using rule 23 (method_decl -> modifier type ID ( optional_formals ) block .)
    ID              reduce using rule 23 (method_decl -> modifier type ID ( optional_formals ) block .)
    INT             reduce using rule 23 (method_decl -> modifier type ID ( optional_formals ) block .)
    FLOAT           reduce using rule 23 (method_decl -> modifier type ID ( optional_formals ) block .)
    BOOLEAN         reduce using rule 23 (method_decl -> modifier type ID ( optional_formals ) block .)


state 58

    (31) block -> { stmt . }
    (33) stmt -> stmt . stmt
    (33) stmt -> . stmt stmt
    (34) stmt -> . IF ( expr ) stmt ELSE stmt
    (35) stmt -> . IF ( expr ) stmt
    (36) stmt -> . WHILE ( expr ) stmt
    (37) stmt -> . FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (38) stmt -> . RETURN optional_expr ;
    (39) stmt -> . stmt_expr ;
    (40) stmt -> . BREAK ;
    (41) stmt -> . CONTINUE ;
    (42) stmt -> . block
    (43) stmt -> . var_decl
    (44) stmt -> . ;
    (94) stmt_expr -> . assign
    (95) stmt_expr -> . method_invocation
    (31) block -> . { stmt }
    (32) block -> . { }
    (17) var_decl -> . type variable ;
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE

    }               shift and go to state 91
    IF              shift and go to state 60
    WHILE           shift and go to state 62
    FOR             shift and go to state 63
    RETURN          shift and go to state 65
    BREAK           shift and go to state 67
    CONTINUE        shift and go to state 68
    ;               shift and go to state 64
    {               shift and go to state 54
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 77
    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88

    stmt                           shift and go to state 90
    stmt_expr                      shift and go to state 66
    block                          shift and go to state 69
    var_decl                       shift and go to state 70
    assign                         shift and go to state 71
    method_invocation              shift and go to state 72
    type                           shift and go to state 73
    field_access                   shift and go to state 74
    primary                        shift and go to state 78
    literal                        shift and go to state 79

state 59

    (32) block -> { } .

    }               reduce using rule 32 (block -> { } .)
    PRIVATE         reduce using rule 32 (block -> { } .)
    PUBLIC          reduce using rule 32 (block -> { } .)
    STATIC          reduce using rule 32 (block -> { } .)
    VOID            reduce using rule 32 (block -> { } .)
    ID              reduce using rule 32 (block -> { } .)
    INT             reduce using rule 32 (block -> { } .)
    FLOAT           reduce using rule 32 (block -> { } .)
    BOOLEAN         reduce using rule 32 (block -> { } .)
    IF              reduce using rule 32 (block -> { } .)
    WHILE           reduce using rule 32 (block -> { } .)
    FOR             reduce using rule 32 (block -> { } .)
    RETURN          reduce using rule 32 (block -> { } .)
    BREAK           reduce using rule 32 (block -> { } .)
    CONTINUE        reduce using rule 32 (block -> { } .)
    ;               reduce using rule 32 (block -> { } .)
    {               reduce using rule 32 (block -> { } .)
    PLUS            reduce using rule 32 (block -> { } .)
    MINUS           reduce using rule 32 (block -> { } .)
    THIS            reduce using rule 32 (block -> { } .)
    SUPER           reduce using rule 32 (block -> { } .)
    (               reduce using rule 32 (block -> { } .)
    NEW             reduce using rule 32 (block -> { } .)
    INT_CONST       reduce using rule 32 (block -> { } .)
    FLOAT_CONST     reduce using rule 32 (block -> { } .)
    STRING_CONST    reduce using rule 32 (block -> { } .)
    NULL            reduce using rule 32 (block -> { } .)
    TRUE            reduce using rule 32 (block -> { } .)
    FALSE           reduce using rule 32 (block -> { } .)
    ELSE            reduce using rule 32 (block -> { } .)


state 60

    (34) stmt -> IF . ( expr ) stmt ELSE stmt
    (35) stmt -> IF . ( expr ) stmt

    (               shift and go to state 92


state 61

    (58) primary -> ( . expr )
    (69) expr -> . primary
    (70) expr -> . assign
    (71) expr -> . expr arith_op expr
    (72) expr -> . expr bool_op expr
    (73) expr -> . expr unary_op expr
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )

    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88
    ID              shift and go to state 96

    expr                           shift and go to state 93
    primary                        shift and go to state 94
    assign                         shift and go to state 95
    literal                        shift and go to state 79
    field_access                   shift and go to state 97
    method_invocation              shift and go to state 98

state 62

    (36) stmt -> WHILE . ( expr ) stmt

    (               shift and go to state 99


state 63

    (37) stmt -> FOR . ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt

    (               shift and go to state 100


state 64

    (44) stmt -> ; .

    }               reduce using rule 44 (stmt -> ; .)
    IF              reduce using rule 44 (stmt -> ; .)
    WHILE           reduce using rule 44 (stmt -> ; .)
    FOR             reduce using rule 44 (stmt -> ; .)
    RETURN          reduce using rule 44 (stmt -> ; .)
    BREAK           reduce using rule 44 (stmt -> ; .)
    CONTINUE        reduce using rule 44 (stmt -> ; .)
    ;               reduce using rule 44 (stmt -> ; .)
    {               reduce using rule 44 (stmt -> ; .)
    PLUS            reduce using rule 44 (stmt -> ; .)
    MINUS           reduce using rule 44 (stmt -> ; .)
    INT             reduce using rule 44 (stmt -> ; .)
    FLOAT           reduce using rule 44 (stmt -> ; .)
    BOOLEAN         reduce using rule 44 (stmt -> ; .)
    ID              reduce using rule 44 (stmt -> ; .)
    THIS            reduce using rule 44 (stmt -> ; .)
    SUPER           reduce using rule 44 (stmt -> ; .)
    (               reduce using rule 44 (stmt -> ; .)
    NEW             reduce using rule 44 (stmt -> ; .)
    INT_CONST       reduce using rule 44 (stmt -> ; .)
    FLOAT_CONST     reduce using rule 44 (stmt -> ; .)
    STRING_CONST    reduce using rule 44 (stmt -> ; .)
    NULL            reduce using rule 44 (stmt -> ; .)
    TRUE            reduce using rule 44 (stmt -> ; .)
    FALSE           reduce using rule 44 (stmt -> ; .)
    ELSE            reduce using rule 44 (stmt -> ; .)


state 65

    (38) stmt -> RETURN . optional_expr ;
    (45) optional_expr -> . expr
    (46) optional_expr -> . empty
    (69) expr -> . primary
    (70) expr -> . assign
    (71) expr -> . expr arith_op expr
    (72) expr -> . expr bool_op expr
    (73) expr -> . expr unary_op expr
    (96) empty -> .
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )

    ;               reduce using rule 96 (empty -> .)
    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88
    ID              shift and go to state 96

    optional_expr                  shift and go to state 101
    expr                           shift and go to state 102
    empty                          shift and go to state 103
    primary                        shift and go to state 94
    assign                         shift and go to state 95
    literal                        shift and go to state 79
    field_access                   shift and go to state 97
    method_invocation              shift and go to state 98

state 66

    (39) stmt -> stmt_expr . ;

    ;               shift and go to state 104


state 67

    (40) stmt -> BREAK . ;

    ;               shift and go to state 105


state 68

    (41) stmt -> CONTINUE . ;

    ;               shift and go to state 106


state 69

    (42) stmt -> block .

    }               reduce using rule 42 (stmt -> block .)
    IF              reduce using rule 42 (stmt -> block .)
    WHILE           reduce using rule 42 (stmt -> block .)
    FOR             reduce using rule 42 (stmt -> block .)
    RETURN          reduce using rule 42 (stmt -> block .)
    BREAK           reduce using rule 42 (stmt -> block .)
    CONTINUE        reduce using rule 42 (stmt -> block .)
    ;               reduce using rule 42 (stmt -> block .)
    {               reduce using rule 42 (stmt -> block .)
    PLUS            reduce using rule 42 (stmt -> block .)
    MINUS           reduce using rule 42 (stmt -> block .)
    INT             reduce using rule 42 (stmt -> block .)
    FLOAT           reduce using rule 42 (stmt -> block .)
    BOOLEAN         reduce using rule 42 (stmt -> block .)
    ID              reduce using rule 42 (stmt -> block .)
    THIS            reduce using rule 42 (stmt -> block .)
    SUPER           reduce using rule 42 (stmt -> block .)
    (               reduce using rule 42 (stmt -> block .)
    NEW             reduce using rule 42 (stmt -> block .)
    INT_CONST       reduce using rule 42 (stmt -> block .)
    FLOAT_CONST     reduce using rule 42 (stmt -> block .)
    STRING_CONST    reduce using rule 42 (stmt -> block .)
    NULL            reduce using rule 42 (stmt -> block .)
    TRUE            reduce using rule 42 (stmt -> block .)
    FALSE           reduce using rule 42 (stmt -> block .)
    ELSE            reduce using rule 42 (stmt -> block .)


state 70

    (43) stmt -> var_decl .

    }               reduce using rule 43 (stmt -> var_decl .)
    IF              reduce using rule 43 (stmt -> var_decl .)
    WHILE           reduce using rule 43 (stmt -> var_decl .)
    FOR             reduce using rule 43 (stmt -> var_decl .)
    RETURN          reduce using rule 43 (stmt -> var_decl .)
    BREAK           reduce using rule 43 (stmt -> var_decl .)
    CONTINUE        reduce using rule 43 (stmt -> var_decl .)
    ;               reduce using rule 43 (stmt -> var_decl .)
    {               reduce using rule 43 (stmt -> var_decl .)
    PLUS            reduce using rule 43 (stmt -> var_decl .)
    MINUS           reduce using rule 43 (stmt -> var_decl .)
    INT             reduce using rule 43 (stmt -> var_decl .)
    FLOAT           reduce using rule 43 (stmt -> var_decl .)
    BOOLEAN         reduce using rule 43 (stmt -> var_decl .)
    ID              reduce using rule 43 (stmt -> var_decl .)
    THIS            reduce using rule 43 (stmt -> var_decl .)
    SUPER           reduce using rule 43 (stmt -> var_decl .)
    (               reduce using rule 43 (stmt -> var_decl .)
    NEW             reduce using rule 43 (stmt -> var_decl .)
    INT_CONST       reduce using rule 43 (stmt -> var_decl .)
    FLOAT_CONST     reduce using rule 43 (stmt -> var_decl .)
    STRING_CONST    reduce using rule 43 (stmt -> var_decl .)
    NULL            reduce using rule 43 (stmt -> var_decl .)
    TRUE            reduce using rule 43 (stmt -> var_decl .)
    FALSE           reduce using rule 43 (stmt -> var_decl .)
    ELSE            reduce using rule 43 (stmt -> var_decl .)


state 71

    (94) stmt_expr -> assign .

    ;               reduce using rule 94 (stmt_expr -> assign .)
    )               reduce using rule 94 (stmt_expr -> assign .)


state 72

    (95) stmt_expr -> method_invocation .
    (62) primary -> method_invocation .

    ;               reduce using rule 95 (stmt_expr -> method_invocation .)
    )               reduce using rule 95 (stmt_expr -> method_invocation .)
    .               reduce using rule 62 (primary -> method_invocation .)


state 73

    (17) var_decl -> type . variable ;
    (22) variable -> . ID

    ID              shift and go to state 50

    variable                       shift and go to state 33

state 74

    (74) assign -> field_access . = expr
    (75) assign -> field_access . PLUS PLUS
    (77) assign -> field_access . MINUS MINUS
    (67) method_invocation -> field_access . ( arguments )
    (68) method_invocation -> field_access . ( )
    (61) primary -> field_access .

    =               shift and go to state 107
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    (               shift and go to state 110
    .               reduce using rule 61 (primary -> field_access .)


state 75

    (76) assign -> PLUS . PLUS field_access

    PLUS            shift and go to state 111


state 76

    (78) assign -> MINUS . MINUS field_access

    MINUS           shift and go to state 112


state 77

    (21) type -> ID .
    (66) field_access -> ID .

    ID              reduce using rule 21 (type -> ID .)
    =               reduce using rule 66 (field_access -> ID .)
    PLUS            reduce using rule 66 (field_access -> ID .)
    MINUS           reduce using rule 66 (field_access -> ID .)
    (               reduce using rule 66 (field_access -> ID .)
    .               reduce using rule 66 (field_access -> ID .)


state 78

    (65) field_access -> primary . . ID

    .               shift and go to state 113


state 79

    (55) primary -> literal .

    .               reduce using rule 55 (primary -> literal .)
    )               reduce using rule 55 (primary -> literal .)
    PLUS            reduce using rule 55 (primary -> literal .)
    MINUS           reduce using rule 55 (primary -> literal .)
    TIMES           reduce using rule 55 (primary -> literal .)
    DIVIDE          reduce using rule 55 (primary -> literal .)
    AND             reduce using rule 55 (primary -> literal .)
    OR              reduce using rule 55 (primary -> literal .)
    EQUALITY        reduce using rule 55 (primary -> literal .)
    INEQUALITY      reduce using rule 55 (primary -> literal .)
    LESSER          reduce using rule 55 (primary -> literal .)
    GREATER         reduce using rule 55 (primary -> literal .)
    LEQ             reduce using rule 55 (primary -> literal .)
    GEQ             reduce using rule 55 (primary -> literal .)
    NOT             reduce using rule 55 (primary -> literal .)
    ;               reduce using rule 55 (primary -> literal .)
    ,               reduce using rule 55 (primary -> literal .)


state 80

    (56) primary -> THIS .

    .               reduce using rule 56 (primary -> THIS .)
    )               reduce using rule 56 (primary -> THIS .)
    PLUS            reduce using rule 56 (primary -> THIS .)
    MINUS           reduce using rule 56 (primary -> THIS .)
    TIMES           reduce using rule 56 (primary -> THIS .)
    DIVIDE          reduce using rule 56 (primary -> THIS .)
    AND             reduce using rule 56 (primary -> THIS .)
    OR              reduce using rule 56 (primary -> THIS .)
    EQUALITY        reduce using rule 56 (primary -> THIS .)
    INEQUALITY      reduce using rule 56 (primary -> THIS .)
    LESSER          reduce using rule 56 (primary -> THIS .)
    GREATER         reduce using rule 56 (primary -> THIS .)
    LEQ             reduce using rule 56 (primary -> THIS .)
    GEQ             reduce using rule 56 (primary -> THIS .)
    NOT             reduce using rule 56 (primary -> THIS .)
    ;               reduce using rule 56 (primary -> THIS .)
    ,               reduce using rule 56 (primary -> THIS .)


state 81

    (57) primary -> SUPER .

    .               reduce using rule 57 (primary -> SUPER .)
    )               reduce using rule 57 (primary -> SUPER .)
    PLUS            reduce using rule 57 (primary -> SUPER .)
    MINUS           reduce using rule 57 (primary -> SUPER .)
    TIMES           reduce using rule 57 (primary -> SUPER .)
    DIVIDE          reduce using rule 57 (primary -> SUPER .)
    AND             reduce using rule 57 (primary -> SUPER .)
    OR              reduce using rule 57 (primary -> SUPER .)
    EQUALITY        reduce using rule 57 (primary -> SUPER .)
    INEQUALITY      reduce using rule 57 (primary -> SUPER .)
    LESSER          reduce using rule 57 (primary -> SUPER .)
    GREATER         reduce using rule 57 (primary -> SUPER .)
    LEQ             reduce using rule 57 (primary -> SUPER .)
    GEQ             reduce using rule 57 (primary -> SUPER .)
    NOT             reduce using rule 57 (primary -> SUPER .)
    ;               reduce using rule 57 (primary -> SUPER .)
    ,               reduce using rule 57 (primary -> SUPER .)


state 82

    (59) primary -> NEW . ID ( arguments )
    (60) primary -> NEW . ID ( )

    ID              shift and go to state 114


state 83

    (49) literal -> INT_CONST .

    .               reduce using rule 49 (literal -> INT_CONST .)
    )               reduce using rule 49 (literal -> INT_CONST .)
    PLUS            reduce using rule 49 (literal -> INT_CONST .)
    MINUS           reduce using rule 49 (literal -> INT_CONST .)
    TIMES           reduce using rule 49 (literal -> INT_CONST .)
    DIVIDE          reduce using rule 49 (literal -> INT_CONST .)
    AND             reduce using rule 49 (literal -> INT_CONST .)
    OR              reduce using rule 49 (literal -> INT_CONST .)
    EQUALITY        reduce using rule 49 (literal -> INT_CONST .)
    INEQUALITY      reduce using rule 49 (literal -> INT_CONST .)
    LESSER          reduce using rule 49 (literal -> INT_CONST .)
    GREATER         reduce using rule 49 (literal -> INT_CONST .)
    LEQ             reduce using rule 49 (literal -> INT_CONST .)
    GEQ             reduce using rule 49 (literal -> INT_CONST .)
    NOT             reduce using rule 49 (literal -> INT_CONST .)
    ;               reduce using rule 49 (literal -> INT_CONST .)
    ,               reduce using rule 49 (literal -> INT_CONST .)


state 84

    (50) literal -> FLOAT_CONST .

    .               reduce using rule 50 (literal -> FLOAT_CONST .)
    )               reduce using rule 50 (literal -> FLOAT_CONST .)
    PLUS            reduce using rule 50 (literal -> FLOAT_CONST .)
    MINUS           reduce using rule 50 (literal -> FLOAT_CONST .)
    TIMES           reduce using rule 50 (literal -> FLOAT_CONST .)
    DIVIDE          reduce using rule 50 (literal -> FLOAT_CONST .)
    AND             reduce using rule 50 (literal -> FLOAT_CONST .)
    OR              reduce using rule 50 (literal -> FLOAT_CONST .)
    EQUALITY        reduce using rule 50 (literal -> FLOAT_CONST .)
    INEQUALITY      reduce using rule 50 (literal -> FLOAT_CONST .)
    LESSER          reduce using rule 50 (literal -> FLOAT_CONST .)
    GREATER         reduce using rule 50 (literal -> FLOAT_CONST .)
    LEQ             reduce using rule 50 (literal -> FLOAT_CONST .)
    GEQ             reduce using rule 50 (literal -> FLOAT_CONST .)
    NOT             reduce using rule 50 (literal -> FLOAT_CONST .)
    ;               reduce using rule 50 (literal -> FLOAT_CONST .)
    ,               reduce using rule 50 (literal -> FLOAT_CONST .)


state 85

    (51) literal -> STRING_CONST .

    .               reduce using rule 51 (literal -> STRING_CONST .)
    )               reduce using rule 51 (literal -> STRING_CONST .)
    PLUS            reduce using rule 51 (literal -> STRING_CONST .)
    MINUS           reduce using rule 51 (literal -> STRING_CONST .)
    TIMES           reduce using rule 51 (literal -> STRING_CONST .)
    DIVIDE          reduce using rule 51 (literal -> STRING_CONST .)
    AND             reduce using rule 51 (literal -> STRING_CONST .)
    OR              reduce using rule 51 (literal -> STRING_CONST .)
    EQUALITY        reduce using rule 51 (literal -> STRING_CONST .)
    INEQUALITY      reduce using rule 51 (literal -> STRING_CONST .)
    LESSER          reduce using rule 51 (literal -> STRING_CONST .)
    GREATER         reduce using rule 51 (literal -> STRING_CONST .)
    LEQ             reduce using rule 51 (literal -> STRING_CONST .)
    GEQ             reduce using rule 51 (literal -> STRING_CONST .)
    NOT             reduce using rule 51 (literal -> STRING_CONST .)
    ;               reduce using rule 51 (literal -> STRING_CONST .)
    ,               reduce using rule 51 (literal -> STRING_CONST .)


state 86

    (52) literal -> NULL .

    .               reduce using rule 52 (literal -> NULL .)
    )               reduce using rule 52 (literal -> NULL .)
    PLUS            reduce using rule 52 (literal -> NULL .)
    MINUS           reduce using rule 52 (literal -> NULL .)
    TIMES           reduce using rule 52 (literal -> NULL .)
    DIVIDE          reduce using rule 52 (literal -> NULL .)
    AND             reduce using rule 52 (literal -> NULL .)
    OR              reduce using rule 52 (literal -> NULL .)
    EQUALITY        reduce using rule 52 (literal -> NULL .)
    INEQUALITY      reduce using rule 52 (literal -> NULL .)
    LESSER          reduce using rule 52 (literal -> NULL .)
    GREATER         reduce using rule 52 (literal -> NULL .)
    LEQ             reduce using rule 52 (literal -> NULL .)
    GEQ             reduce using rule 52 (literal -> NULL .)
    NOT             reduce using rule 52 (literal -> NULL .)
    ;               reduce using rule 52 (literal -> NULL .)
    ,               reduce using rule 52 (literal -> NULL .)


state 87

    (53) literal -> TRUE .

    .               reduce using rule 53 (literal -> TRUE .)
    )               reduce using rule 53 (literal -> TRUE .)
    PLUS            reduce using rule 53 (literal -> TRUE .)
    MINUS           reduce using rule 53 (literal -> TRUE .)
    TIMES           reduce using rule 53 (literal -> TRUE .)
    DIVIDE          reduce using rule 53 (literal -> TRUE .)
    AND             reduce using rule 53 (literal -> TRUE .)
    OR              reduce using rule 53 (literal -> TRUE .)
    EQUALITY        reduce using rule 53 (literal -> TRUE .)
    INEQUALITY      reduce using rule 53 (literal -> TRUE .)
    LESSER          reduce using rule 53 (literal -> TRUE .)
    GREATER         reduce using rule 53 (literal -> TRUE .)
    LEQ             reduce using rule 53 (literal -> TRUE .)
    GEQ             reduce using rule 53 (literal -> TRUE .)
    NOT             reduce using rule 53 (literal -> TRUE .)
    ;               reduce using rule 53 (literal -> TRUE .)
    ,               reduce using rule 53 (literal -> TRUE .)


state 88

    (54) literal -> FALSE .

    .               reduce using rule 54 (literal -> FALSE .)
    )               reduce using rule 54 (literal -> FALSE .)
    PLUS            reduce using rule 54 (literal -> FALSE .)
    MINUS           reduce using rule 54 (literal -> FALSE .)
    TIMES           reduce using rule 54 (literal -> FALSE .)
    DIVIDE          reduce using rule 54 (literal -> FALSE .)
    AND             reduce using rule 54 (literal -> FALSE .)
    OR              reduce using rule 54 (literal -> FALSE .)
    EQUALITY        reduce using rule 54 (literal -> FALSE .)
    INEQUALITY      reduce using rule 54 (literal -> FALSE .)
    LESSER          reduce using rule 54 (literal -> FALSE .)
    GREATER         reduce using rule 54 (literal -> FALSE .)
    LEQ             reduce using rule 54 (literal -> FALSE .)
    GEQ             reduce using rule 54 (literal -> FALSE .)
    NOT             reduce using rule 54 (literal -> FALSE .)
    ;               reduce using rule 54 (literal -> FALSE .)
    ,               reduce using rule 54 (literal -> FALSE .)


state 89

    (24) method_decl -> modifier VOID ID ( optional_formals ) block .

    }               reduce using rule 24 (method_decl -> modifier VOID ID ( optional_formals ) block .)
    PRIVATE         reduce using rule 24 (method_decl -> modifier VOID ID ( optional_formals ) block .)
    PUBLIC          reduce using rule 24 (method_decl -> modifier VOID ID ( optional_formals ) block .)
    STATIC          reduce using rule 24 (method_decl -> modifier VOID ID ( optional_formals ) block .)
    VOID            reduce using rule 24 (method_decl -> modifier VOID ID ( optional_formals ) block .)
    ID              reduce using rule 24 (method_decl -> modifier VOID ID ( optional_formals ) block .)
    INT             reduce using rule 24 (method_decl -> modifier VOID ID ( optional_formals ) block .)
    FLOAT           reduce using rule 24 (method_decl -> modifier VOID ID ( optional_formals ) block .)
    BOOLEAN         reduce using rule 24 (method_decl -> modifier VOID ID ( optional_formals ) block .)


state 90

    (33) stmt -> stmt stmt .
    (33) stmt -> stmt . stmt
    (33) stmt -> . stmt stmt
    (34) stmt -> . IF ( expr ) stmt ELSE stmt
    (35) stmt -> . IF ( expr ) stmt
    (36) stmt -> . WHILE ( expr ) stmt
    (37) stmt -> . FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (38) stmt -> . RETURN optional_expr ;
    (39) stmt -> . stmt_expr ;
    (40) stmt -> . BREAK ;
    (41) stmt -> . CONTINUE ;
    (42) stmt -> . block
    (43) stmt -> . var_decl
    (44) stmt -> . ;
    (94) stmt_expr -> . assign
    (95) stmt_expr -> . method_invocation
    (31) block -> . { stmt }
    (32) block -> . { }
    (17) var_decl -> . type variable ;
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INT_CONST resolved as shift
  ! shift/reduce conflict for FLOAT_CONST resolved as shift
  ! shift/reduce conflict for STRING_CONST resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    }               reduce using rule 33 (stmt -> stmt stmt .)
    ELSE            reduce using rule 33 (stmt -> stmt stmt .)
    IF              shift and go to state 60
    WHILE           shift and go to state 62
    FOR             shift and go to state 63
    RETURN          shift and go to state 65
    BREAK           shift and go to state 67
    CONTINUE        shift and go to state 68
    ;               shift and go to state 64
    {               shift and go to state 54
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 77
    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88

  ! IF              [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! WHILE           [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! FOR             [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! RETURN          [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! BREAK           [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! CONTINUE        [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! ;               [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! {               [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! PLUS            [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! MINUS           [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! INT             [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! FLOAT           [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! BOOLEAN         [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! ID              [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! THIS            [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! SUPER           [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! (               [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! NEW             [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! INT_CONST       [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! FLOAT_CONST     [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! STRING_CONST    [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! NULL            [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! TRUE            [ reduce using rule 33 (stmt -> stmt stmt .) ]
  ! FALSE           [ reduce using rule 33 (stmt -> stmt stmt .) ]

    stmt                           shift and go to state 90
    stmt_expr                      shift and go to state 66
    block                          shift and go to state 69
    var_decl                       shift and go to state 70
    assign                         shift and go to state 71
    method_invocation              shift and go to state 72
    type                           shift and go to state 73
    field_access                   shift and go to state 74
    primary                        shift and go to state 78
    literal                        shift and go to state 79

state 91

    (31) block -> { stmt } .

    }               reduce using rule 31 (block -> { stmt } .)
    PRIVATE         reduce using rule 31 (block -> { stmt } .)
    PUBLIC          reduce using rule 31 (block -> { stmt } .)
    STATIC          reduce using rule 31 (block -> { stmt } .)
    VOID            reduce using rule 31 (block -> { stmt } .)
    ID              reduce using rule 31 (block -> { stmt } .)
    INT             reduce using rule 31 (block -> { stmt } .)
    FLOAT           reduce using rule 31 (block -> { stmt } .)
    BOOLEAN         reduce using rule 31 (block -> { stmt } .)
    IF              reduce using rule 31 (block -> { stmt } .)
    WHILE           reduce using rule 31 (block -> { stmt } .)
    FOR             reduce using rule 31 (block -> { stmt } .)
    RETURN          reduce using rule 31 (block -> { stmt } .)
    BREAK           reduce using rule 31 (block -> { stmt } .)
    CONTINUE        reduce using rule 31 (block -> { stmt } .)
    ;               reduce using rule 31 (block -> { stmt } .)
    {               reduce using rule 31 (block -> { stmt } .)
    PLUS            reduce using rule 31 (block -> { stmt } .)
    MINUS           reduce using rule 31 (block -> { stmt } .)
    THIS            reduce using rule 31 (block -> { stmt } .)
    SUPER           reduce using rule 31 (block -> { stmt } .)
    (               reduce using rule 31 (block -> { stmt } .)
    NEW             reduce using rule 31 (block -> { stmt } .)
    INT_CONST       reduce using rule 31 (block -> { stmt } .)
    FLOAT_CONST     reduce using rule 31 (block -> { stmt } .)
    STRING_CONST    reduce using rule 31 (block -> { stmt } .)
    NULL            reduce using rule 31 (block -> { stmt } .)
    TRUE            reduce using rule 31 (block -> { stmt } .)
    FALSE           reduce using rule 31 (block -> { stmt } .)
    ELSE            reduce using rule 31 (block -> { stmt } .)


state 92

    (34) stmt -> IF ( . expr ) stmt ELSE stmt
    (35) stmt -> IF ( . expr ) stmt
    (69) expr -> . primary
    (70) expr -> . assign
    (71) expr -> . expr arith_op expr
    (72) expr -> . expr bool_op expr
    (73) expr -> . expr unary_op expr
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )

    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88
    ID              shift and go to state 96

    expr                           shift and go to state 115
    primary                        shift and go to state 94
    assign                         shift and go to state 95
    literal                        shift and go to state 79
    field_access                   shift and go to state 97
    method_invocation              shift and go to state 98

state 93

    (58) primary -> ( expr . )
    (71) expr -> expr . arith_op expr
    (72) expr -> expr . bool_op expr
    (73) expr -> expr . unary_op expr
    (79) arith_op -> . PLUS
    (80) arith_op -> . MINUS
    (81) arith_op -> . TIMES
    (82) arith_op -> . DIVIDE
    (83) bool_op -> . AND
    (84) bool_op -> . OR
    (85) bool_op -> . EQUALITY
    (86) bool_op -> . INEQUALITY
    (87) bool_op -> . LESSER
    (88) bool_op -> . GREATER
    (89) bool_op -> . LEQ
    (90) bool_op -> . GEQ
    (91) unary_op -> . PLUS
    (92) unary_op -> . MINUS
    (93) unary_op -> . NOT

    )               shift and go to state 116
    PLUS            shift and go to state 120
    MINUS           shift and go to state 121
    TIMES           shift and go to state 122
    DIVIDE          shift and go to state 123
    AND             shift and go to state 124
    OR              shift and go to state 125
    EQUALITY        shift and go to state 126
    INEQUALITY      shift and go to state 127
    LESSER          shift and go to state 128
    GREATER         shift and go to state 129
    LEQ             shift and go to state 130
    GEQ             shift and go to state 131
    NOT             shift and go to state 132

    arith_op                       shift and go to state 117
    bool_op                        shift and go to state 118
    unary_op                       shift and go to state 119

state 94

    (69) expr -> primary .
    (65) field_access -> primary . . ID

    )               reduce using rule 69 (expr -> primary .)
    PLUS            reduce using rule 69 (expr -> primary .)
    MINUS           reduce using rule 69 (expr -> primary .)
    TIMES           reduce using rule 69 (expr -> primary .)
    DIVIDE          reduce using rule 69 (expr -> primary .)
    AND             reduce using rule 69 (expr -> primary .)
    OR              reduce using rule 69 (expr -> primary .)
    EQUALITY        reduce using rule 69 (expr -> primary .)
    INEQUALITY      reduce using rule 69 (expr -> primary .)
    LESSER          reduce using rule 69 (expr -> primary .)
    GREATER         reduce using rule 69 (expr -> primary .)
    LEQ             reduce using rule 69 (expr -> primary .)
    GEQ             reduce using rule 69 (expr -> primary .)
    NOT             reduce using rule 69 (expr -> primary .)
    ;               reduce using rule 69 (expr -> primary .)
    ,               reduce using rule 69 (expr -> primary .)
    .               shift and go to state 113


state 95

    (70) expr -> assign .

    )               reduce using rule 70 (expr -> assign .)
    PLUS            reduce using rule 70 (expr -> assign .)
    MINUS           reduce using rule 70 (expr -> assign .)
    TIMES           reduce using rule 70 (expr -> assign .)
    DIVIDE          reduce using rule 70 (expr -> assign .)
    AND             reduce using rule 70 (expr -> assign .)
    OR              reduce using rule 70 (expr -> assign .)
    EQUALITY        reduce using rule 70 (expr -> assign .)
    INEQUALITY      reduce using rule 70 (expr -> assign .)
    LESSER          reduce using rule 70 (expr -> assign .)
    GREATER         reduce using rule 70 (expr -> assign .)
    LEQ             reduce using rule 70 (expr -> assign .)
    GEQ             reduce using rule 70 (expr -> assign .)
    NOT             reduce using rule 70 (expr -> assign .)
    ;               reduce using rule 70 (expr -> assign .)
    ,               reduce using rule 70 (expr -> assign .)


state 96

    (66) field_access -> ID .

    =               reduce using rule 66 (field_access -> ID .)
    PLUS            reduce using rule 66 (field_access -> ID .)
    MINUS           reduce using rule 66 (field_access -> ID .)
    (               reduce using rule 66 (field_access -> ID .)
    .               reduce using rule 66 (field_access -> ID .)
    )               reduce using rule 66 (field_access -> ID .)
    TIMES           reduce using rule 66 (field_access -> ID .)
    DIVIDE          reduce using rule 66 (field_access -> ID .)
    AND             reduce using rule 66 (field_access -> ID .)
    OR              reduce using rule 66 (field_access -> ID .)
    EQUALITY        reduce using rule 66 (field_access -> ID .)
    INEQUALITY      reduce using rule 66 (field_access -> ID .)
    LESSER          reduce using rule 66 (field_access -> ID .)
    GREATER         reduce using rule 66 (field_access -> ID .)
    LEQ             reduce using rule 66 (field_access -> ID .)
    GEQ             reduce using rule 66 (field_access -> ID .)
    NOT             reduce using rule 66 (field_access -> ID .)
    ;               reduce using rule 66 (field_access -> ID .)
    ,               reduce using rule 66 (field_access -> ID .)


state 97

    (61) primary -> field_access .
    (74) assign -> field_access . = expr
    (75) assign -> field_access . PLUS PLUS
    (77) assign -> field_access . MINUS MINUS
    (67) method_invocation -> field_access . ( arguments )
    (68) method_invocation -> field_access . ( )

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    .               reduce using rule 61 (primary -> field_access .)
    )               reduce using rule 61 (primary -> field_access .)
    TIMES           reduce using rule 61 (primary -> field_access .)
    DIVIDE          reduce using rule 61 (primary -> field_access .)
    AND             reduce using rule 61 (primary -> field_access .)
    OR              reduce using rule 61 (primary -> field_access .)
    EQUALITY        reduce using rule 61 (primary -> field_access .)
    INEQUALITY      reduce using rule 61 (primary -> field_access .)
    LESSER          reduce using rule 61 (primary -> field_access .)
    GREATER         reduce using rule 61 (primary -> field_access .)
    LEQ             reduce using rule 61 (primary -> field_access .)
    GEQ             reduce using rule 61 (primary -> field_access .)
    NOT             reduce using rule 61 (primary -> field_access .)
    ;               reduce using rule 61 (primary -> field_access .)
    ,               reduce using rule 61 (primary -> field_access .)
    =               shift and go to state 107
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    (               shift and go to state 110

  ! PLUS            [ reduce using rule 61 (primary -> field_access .) ]
  ! MINUS           [ reduce using rule 61 (primary -> field_access .) ]


state 98

    (62) primary -> method_invocation .

    .               reduce using rule 62 (primary -> method_invocation .)
    )               reduce using rule 62 (primary -> method_invocation .)
    PLUS            reduce using rule 62 (primary -> method_invocation .)
    MINUS           reduce using rule 62 (primary -> method_invocation .)
    TIMES           reduce using rule 62 (primary -> method_invocation .)
    DIVIDE          reduce using rule 62 (primary -> method_invocation .)
    AND             reduce using rule 62 (primary -> method_invocation .)
    OR              reduce using rule 62 (primary -> method_invocation .)
    EQUALITY        reduce using rule 62 (primary -> method_invocation .)
    INEQUALITY      reduce using rule 62 (primary -> method_invocation .)
    LESSER          reduce using rule 62 (primary -> method_invocation .)
    GREATER         reduce using rule 62 (primary -> method_invocation .)
    LEQ             reduce using rule 62 (primary -> method_invocation .)
    GEQ             reduce using rule 62 (primary -> method_invocation .)
    NOT             reduce using rule 62 (primary -> method_invocation .)
    ;               reduce using rule 62 (primary -> method_invocation .)
    ,               reduce using rule 62 (primary -> method_invocation .)


state 99

    (36) stmt -> WHILE ( . expr ) stmt
    (69) expr -> . primary
    (70) expr -> . assign
    (71) expr -> . expr arith_op expr
    (72) expr -> . expr bool_op expr
    (73) expr -> . expr unary_op expr
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )

    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88
    ID              shift and go to state 96

    expr                           shift and go to state 133
    primary                        shift and go to state 94
    assign                         shift and go to state 95
    literal                        shift and go to state 79
    field_access                   shift and go to state 97
    method_invocation              shift and go to state 98

state 100

    (37) stmt -> FOR ( . optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (47) optional_stmt_expr -> . stmt_expr
    (48) optional_stmt_expr -> . empty
    (94) stmt_expr -> . assign
    (95) stmt_expr -> . method_invocation
    (96) empty -> .
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE

    ;               reduce using rule 96 (empty -> .)
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    ID              shift and go to state 96
    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88

    optional_stmt_expr             shift and go to state 134
    stmt_expr                      shift and go to state 135
    empty                          shift and go to state 136
    assign                         shift and go to state 71
    method_invocation              shift and go to state 72
    field_access                   shift and go to state 74
    primary                        shift and go to state 78
    literal                        shift and go to state 79

state 101

    (38) stmt -> RETURN optional_expr . ;

    ;               shift and go to state 137


state 102

    (45) optional_expr -> expr .
    (71) expr -> expr . arith_op expr
    (72) expr -> expr . bool_op expr
    (73) expr -> expr . unary_op expr
    (79) arith_op -> . PLUS
    (80) arith_op -> . MINUS
    (81) arith_op -> . TIMES
    (82) arith_op -> . DIVIDE
    (83) bool_op -> . AND
    (84) bool_op -> . OR
    (85) bool_op -> . EQUALITY
    (86) bool_op -> . INEQUALITY
    (87) bool_op -> . LESSER
    (88) bool_op -> . GREATER
    (89) bool_op -> . LEQ
    (90) bool_op -> . GEQ
    (91) unary_op -> . PLUS
    (92) unary_op -> . MINUS
    (93) unary_op -> . NOT

    ;               reduce using rule 45 (optional_expr -> expr .)
    PLUS            shift and go to state 120
    MINUS           shift and go to state 121
    TIMES           shift and go to state 122
    DIVIDE          shift and go to state 123
    AND             shift and go to state 124
    OR              shift and go to state 125
    EQUALITY        shift and go to state 126
    INEQUALITY      shift and go to state 127
    LESSER          shift and go to state 128
    GREATER         shift and go to state 129
    LEQ             shift and go to state 130
    GEQ             shift and go to state 131
    NOT             shift and go to state 132

    arith_op                       shift and go to state 117
    bool_op                        shift and go to state 118
    unary_op                       shift and go to state 119

state 103

    (46) optional_expr -> empty .

    ;               reduce using rule 46 (optional_expr -> empty .)


state 104

    (39) stmt -> stmt_expr ; .

    }               reduce using rule 39 (stmt -> stmt_expr ; .)
    IF              reduce using rule 39 (stmt -> stmt_expr ; .)
    WHILE           reduce using rule 39 (stmt -> stmt_expr ; .)
    FOR             reduce using rule 39 (stmt -> stmt_expr ; .)
    RETURN          reduce using rule 39 (stmt -> stmt_expr ; .)
    BREAK           reduce using rule 39 (stmt -> stmt_expr ; .)
    CONTINUE        reduce using rule 39 (stmt -> stmt_expr ; .)
    ;               reduce using rule 39 (stmt -> stmt_expr ; .)
    {               reduce using rule 39 (stmt -> stmt_expr ; .)
    PLUS            reduce using rule 39 (stmt -> stmt_expr ; .)
    MINUS           reduce using rule 39 (stmt -> stmt_expr ; .)
    INT             reduce using rule 39 (stmt -> stmt_expr ; .)
    FLOAT           reduce using rule 39 (stmt -> stmt_expr ; .)
    BOOLEAN         reduce using rule 39 (stmt -> stmt_expr ; .)
    ID              reduce using rule 39 (stmt -> stmt_expr ; .)
    THIS            reduce using rule 39 (stmt -> stmt_expr ; .)
    SUPER           reduce using rule 39 (stmt -> stmt_expr ; .)
    (               reduce using rule 39 (stmt -> stmt_expr ; .)
    NEW             reduce using rule 39 (stmt -> stmt_expr ; .)
    INT_CONST       reduce using rule 39 (stmt -> stmt_expr ; .)
    FLOAT_CONST     reduce using rule 39 (stmt -> stmt_expr ; .)
    STRING_CONST    reduce using rule 39 (stmt -> stmt_expr ; .)
    NULL            reduce using rule 39 (stmt -> stmt_expr ; .)
    TRUE            reduce using rule 39 (stmt -> stmt_expr ; .)
    FALSE           reduce using rule 39 (stmt -> stmt_expr ; .)
    ELSE            reduce using rule 39 (stmt -> stmt_expr ; .)


state 105

    (40) stmt -> BREAK ; .

    }               reduce using rule 40 (stmt -> BREAK ; .)
    IF              reduce using rule 40 (stmt -> BREAK ; .)
    WHILE           reduce using rule 40 (stmt -> BREAK ; .)
    FOR             reduce using rule 40 (stmt -> BREAK ; .)
    RETURN          reduce using rule 40 (stmt -> BREAK ; .)
    BREAK           reduce using rule 40 (stmt -> BREAK ; .)
    CONTINUE        reduce using rule 40 (stmt -> BREAK ; .)
    ;               reduce using rule 40 (stmt -> BREAK ; .)
    {               reduce using rule 40 (stmt -> BREAK ; .)
    PLUS            reduce using rule 40 (stmt -> BREAK ; .)
    MINUS           reduce using rule 40 (stmt -> BREAK ; .)
    INT             reduce using rule 40 (stmt -> BREAK ; .)
    FLOAT           reduce using rule 40 (stmt -> BREAK ; .)
    BOOLEAN         reduce using rule 40 (stmt -> BREAK ; .)
    ID              reduce using rule 40 (stmt -> BREAK ; .)
    THIS            reduce using rule 40 (stmt -> BREAK ; .)
    SUPER           reduce using rule 40 (stmt -> BREAK ; .)
    (               reduce using rule 40 (stmt -> BREAK ; .)
    NEW             reduce using rule 40 (stmt -> BREAK ; .)
    INT_CONST       reduce using rule 40 (stmt -> BREAK ; .)
    FLOAT_CONST     reduce using rule 40 (stmt -> BREAK ; .)
    STRING_CONST    reduce using rule 40 (stmt -> BREAK ; .)
    NULL            reduce using rule 40 (stmt -> BREAK ; .)
    TRUE            reduce using rule 40 (stmt -> BREAK ; .)
    FALSE           reduce using rule 40 (stmt -> BREAK ; .)
    ELSE            reduce using rule 40 (stmt -> BREAK ; .)


state 106

    (41) stmt -> CONTINUE ; .

    }               reduce using rule 41 (stmt -> CONTINUE ; .)
    IF              reduce using rule 41 (stmt -> CONTINUE ; .)
    WHILE           reduce using rule 41 (stmt -> CONTINUE ; .)
    FOR             reduce using rule 41 (stmt -> CONTINUE ; .)
    RETURN          reduce using rule 41 (stmt -> CONTINUE ; .)
    BREAK           reduce using rule 41 (stmt -> CONTINUE ; .)
    CONTINUE        reduce using rule 41 (stmt -> CONTINUE ; .)
    ;               reduce using rule 41 (stmt -> CONTINUE ; .)
    {               reduce using rule 41 (stmt -> CONTINUE ; .)
    PLUS            reduce using rule 41 (stmt -> CONTINUE ; .)
    MINUS           reduce using rule 41 (stmt -> CONTINUE ; .)
    INT             reduce using rule 41 (stmt -> CONTINUE ; .)
    FLOAT           reduce using rule 41 (stmt -> CONTINUE ; .)
    BOOLEAN         reduce using rule 41 (stmt -> CONTINUE ; .)
    ID              reduce using rule 41 (stmt -> CONTINUE ; .)
    THIS            reduce using rule 41 (stmt -> CONTINUE ; .)
    SUPER           reduce using rule 41 (stmt -> CONTINUE ; .)
    (               reduce using rule 41 (stmt -> CONTINUE ; .)
    NEW             reduce using rule 41 (stmt -> CONTINUE ; .)
    INT_CONST       reduce using rule 41 (stmt -> CONTINUE ; .)
    FLOAT_CONST     reduce using rule 41 (stmt -> CONTINUE ; .)
    STRING_CONST    reduce using rule 41 (stmt -> CONTINUE ; .)
    NULL            reduce using rule 41 (stmt -> CONTINUE ; .)
    TRUE            reduce using rule 41 (stmt -> CONTINUE ; .)
    FALSE           reduce using rule 41 (stmt -> CONTINUE ; .)
    ELSE            reduce using rule 41 (stmt -> CONTINUE ; .)


state 107

    (74) assign -> field_access = . expr
    (69) expr -> . primary
    (70) expr -> . assign
    (71) expr -> . expr arith_op expr
    (72) expr -> . expr bool_op expr
    (73) expr -> . expr unary_op expr
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )

    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88
    ID              shift and go to state 96

    field_access                   shift and go to state 97
    expr                           shift and go to state 138
    primary                        shift and go to state 94
    assign                         shift and go to state 95
    literal                        shift and go to state 79
    method_invocation              shift and go to state 98

state 108

    (75) assign -> field_access PLUS . PLUS

    PLUS            shift and go to state 139


state 109

    (77) assign -> field_access MINUS . MINUS

    MINUS           shift and go to state 140


state 110

    (67) method_invocation -> field_access ( . arguments )
    (68) method_invocation -> field_access ( . )
    (63) arguments -> . expr
    (64) arguments -> . expr , arguments
    (69) expr -> . primary
    (70) expr -> . assign
    (71) expr -> . expr arith_op expr
    (72) expr -> . expr bool_op expr
    (73) expr -> . expr unary_op expr
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )

    )               shift and go to state 142
    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88
    ID              shift and go to state 96

    field_access                   shift and go to state 97
    arguments                      shift and go to state 141
    expr                           shift and go to state 143
    primary                        shift and go to state 94
    assign                         shift and go to state 95
    literal                        shift and go to state 79
    method_invocation              shift and go to state 98

state 111

    (76) assign -> PLUS PLUS . field_access
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )

    ID              shift and go to state 96
    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88

    field_access                   shift and go to state 144
    primary                        shift and go to state 78
    literal                        shift and go to state 79
    method_invocation              shift and go to state 98

state 112

    (78) assign -> MINUS MINUS . field_access
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )

    ID              shift and go to state 96
    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88

    field_access                   shift and go to state 145
    primary                        shift and go to state 78
    literal                        shift and go to state 79
    method_invocation              shift and go to state 98

state 113

    (65) field_access -> primary . . ID

    ID              shift and go to state 146


state 114

    (59) primary -> NEW ID . ( arguments )
    (60) primary -> NEW ID . ( )

    (               shift and go to state 147


state 115

    (34) stmt -> IF ( expr . ) stmt ELSE stmt
    (35) stmt -> IF ( expr . ) stmt
    (71) expr -> expr . arith_op expr
    (72) expr -> expr . bool_op expr
    (73) expr -> expr . unary_op expr
    (79) arith_op -> . PLUS
    (80) arith_op -> . MINUS
    (81) arith_op -> . TIMES
    (82) arith_op -> . DIVIDE
    (83) bool_op -> . AND
    (84) bool_op -> . OR
    (85) bool_op -> . EQUALITY
    (86) bool_op -> . INEQUALITY
    (87) bool_op -> . LESSER
    (88) bool_op -> . GREATER
    (89) bool_op -> . LEQ
    (90) bool_op -> . GEQ
    (91) unary_op -> . PLUS
    (92) unary_op -> . MINUS
    (93) unary_op -> . NOT

    )               shift and go to state 148
    PLUS            shift and go to state 120
    MINUS           shift and go to state 121
    TIMES           shift and go to state 122
    DIVIDE          shift and go to state 123
    AND             shift and go to state 124
    OR              shift and go to state 125
    EQUALITY        shift and go to state 126
    INEQUALITY      shift and go to state 127
    LESSER          shift and go to state 128
    GREATER         shift and go to state 129
    LEQ             shift and go to state 130
    GEQ             shift and go to state 131
    NOT             shift and go to state 132

    arith_op                       shift and go to state 117
    bool_op                        shift and go to state 118
    unary_op                       shift and go to state 119

state 116

    (58) primary -> ( expr ) .

    .               reduce using rule 58 (primary -> ( expr ) .)
    )               reduce using rule 58 (primary -> ( expr ) .)
    PLUS            reduce using rule 58 (primary -> ( expr ) .)
    MINUS           reduce using rule 58 (primary -> ( expr ) .)
    TIMES           reduce using rule 58 (primary -> ( expr ) .)
    DIVIDE          reduce using rule 58 (primary -> ( expr ) .)
    AND             reduce using rule 58 (primary -> ( expr ) .)
    OR              reduce using rule 58 (primary -> ( expr ) .)
    EQUALITY        reduce using rule 58 (primary -> ( expr ) .)
    INEQUALITY      reduce using rule 58 (primary -> ( expr ) .)
    LESSER          reduce using rule 58 (primary -> ( expr ) .)
    GREATER         reduce using rule 58 (primary -> ( expr ) .)
    LEQ             reduce using rule 58 (primary -> ( expr ) .)
    GEQ             reduce using rule 58 (primary -> ( expr ) .)
    NOT             reduce using rule 58 (primary -> ( expr ) .)
    ;               reduce using rule 58 (primary -> ( expr ) .)
    ,               reduce using rule 58 (primary -> ( expr ) .)


state 117

    (71) expr -> expr arith_op . expr
    (69) expr -> . primary
    (70) expr -> . assign
    (71) expr -> . expr arith_op expr
    (72) expr -> . expr bool_op expr
    (73) expr -> . expr unary_op expr
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )

    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88
    ID              shift and go to state 96

    expr                           shift and go to state 149
    primary                        shift and go to state 94
    assign                         shift and go to state 95
    literal                        shift and go to state 79
    field_access                   shift and go to state 97
    method_invocation              shift and go to state 98

state 118

    (72) expr -> expr bool_op . expr
    (69) expr -> . primary
    (70) expr -> . assign
    (71) expr -> . expr arith_op expr
    (72) expr -> . expr bool_op expr
    (73) expr -> . expr unary_op expr
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )

    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88
    ID              shift and go to state 96

    expr                           shift and go to state 150
    primary                        shift and go to state 94
    assign                         shift and go to state 95
    literal                        shift and go to state 79
    field_access                   shift and go to state 97
    method_invocation              shift and go to state 98

state 119

    (73) expr -> expr unary_op . expr
    (69) expr -> . primary
    (70) expr -> . assign
    (71) expr -> . expr arith_op expr
    (72) expr -> . expr bool_op expr
    (73) expr -> . expr unary_op expr
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )

    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88
    ID              shift and go to state 96

    expr                           shift and go to state 151
    primary                        shift and go to state 94
    assign                         shift and go to state 95
    literal                        shift and go to state 79
    field_access                   shift and go to state 97
    method_invocation              shift and go to state 98

state 120

    (79) arith_op -> PLUS .
    (91) unary_op -> PLUS .

  ! reduce/reduce conflict for THIS resolved using rule 79 (arith_op -> PLUS .)
  ! reduce/reduce conflict for SUPER resolved using rule 79 (arith_op -> PLUS .)
  ! reduce/reduce conflict for ( resolved using rule 79 (arith_op -> PLUS .)
  ! reduce/reduce conflict for NEW resolved using rule 79 (arith_op -> PLUS .)
  ! reduce/reduce conflict for PLUS resolved using rule 79 (arith_op -> PLUS .)
  ! reduce/reduce conflict for MINUS resolved using rule 79 (arith_op -> PLUS .)
  ! reduce/reduce conflict for INT_CONST resolved using rule 79 (arith_op -> PLUS .)
  ! reduce/reduce conflict for FLOAT_CONST resolved using rule 79 (arith_op -> PLUS .)
  ! reduce/reduce conflict for STRING_CONST resolved using rule 79 (arith_op -> PLUS .)
  ! reduce/reduce conflict for NULL resolved using rule 79 (arith_op -> PLUS .)
  ! reduce/reduce conflict for TRUE resolved using rule 79 (arith_op -> PLUS .)
  ! reduce/reduce conflict for FALSE resolved using rule 79 (arith_op -> PLUS .)
  ! reduce/reduce conflict for ID resolved using rule 79 (arith_op -> PLUS .)
    THIS            reduce using rule 79 (arith_op -> PLUS .)
    SUPER           reduce using rule 79 (arith_op -> PLUS .)
    (               reduce using rule 79 (arith_op -> PLUS .)
    NEW             reduce using rule 79 (arith_op -> PLUS .)
    PLUS            reduce using rule 79 (arith_op -> PLUS .)
    MINUS           reduce using rule 79 (arith_op -> PLUS .)
    INT_CONST       reduce using rule 79 (arith_op -> PLUS .)
    FLOAT_CONST     reduce using rule 79 (arith_op -> PLUS .)
    STRING_CONST    reduce using rule 79 (arith_op -> PLUS .)
    NULL            reduce using rule 79 (arith_op -> PLUS .)
    TRUE            reduce using rule 79 (arith_op -> PLUS .)
    FALSE           reduce using rule 79 (arith_op -> PLUS .)
    ID              reduce using rule 79 (arith_op -> PLUS .)

  ! THIS            [ reduce using rule 91 (unary_op -> PLUS .) ]
  ! SUPER           [ reduce using rule 91 (unary_op -> PLUS .) ]
  ! (               [ reduce using rule 91 (unary_op -> PLUS .) ]
  ! NEW             [ reduce using rule 91 (unary_op -> PLUS .) ]
  ! PLUS            [ reduce using rule 91 (unary_op -> PLUS .) ]
  ! MINUS           [ reduce using rule 91 (unary_op -> PLUS .) ]
  ! INT_CONST       [ reduce using rule 91 (unary_op -> PLUS .) ]
  ! FLOAT_CONST     [ reduce using rule 91 (unary_op -> PLUS .) ]
  ! STRING_CONST    [ reduce using rule 91 (unary_op -> PLUS .) ]
  ! NULL            [ reduce using rule 91 (unary_op -> PLUS .) ]
  ! TRUE            [ reduce using rule 91 (unary_op -> PLUS .) ]
  ! FALSE           [ reduce using rule 91 (unary_op -> PLUS .) ]
  ! ID              [ reduce using rule 91 (unary_op -> PLUS .) ]


state 121

    (80) arith_op -> MINUS .
    (92) unary_op -> MINUS .

  ! reduce/reduce conflict for THIS resolved using rule 80 (arith_op -> MINUS .)
  ! reduce/reduce conflict for SUPER resolved using rule 80 (arith_op -> MINUS .)
  ! reduce/reduce conflict for ( resolved using rule 80 (arith_op -> MINUS .)
  ! reduce/reduce conflict for NEW resolved using rule 80 (arith_op -> MINUS .)
  ! reduce/reduce conflict for PLUS resolved using rule 80 (arith_op -> MINUS .)
  ! reduce/reduce conflict for MINUS resolved using rule 80 (arith_op -> MINUS .)
  ! reduce/reduce conflict for INT_CONST resolved using rule 80 (arith_op -> MINUS .)
  ! reduce/reduce conflict for FLOAT_CONST resolved using rule 80 (arith_op -> MINUS .)
  ! reduce/reduce conflict for STRING_CONST resolved using rule 80 (arith_op -> MINUS .)
  ! reduce/reduce conflict for NULL resolved using rule 80 (arith_op -> MINUS .)
  ! reduce/reduce conflict for TRUE resolved using rule 80 (arith_op -> MINUS .)
  ! reduce/reduce conflict for FALSE resolved using rule 80 (arith_op -> MINUS .)
  ! reduce/reduce conflict for ID resolved using rule 80 (arith_op -> MINUS .)
    THIS            reduce using rule 80 (arith_op -> MINUS .)
    SUPER           reduce using rule 80 (arith_op -> MINUS .)
    (               reduce using rule 80 (arith_op -> MINUS .)
    NEW             reduce using rule 80 (arith_op -> MINUS .)
    PLUS            reduce using rule 80 (arith_op -> MINUS .)
    MINUS           reduce using rule 80 (arith_op -> MINUS .)
    INT_CONST       reduce using rule 80 (arith_op -> MINUS .)
    FLOAT_CONST     reduce using rule 80 (arith_op -> MINUS .)
    STRING_CONST    reduce using rule 80 (arith_op -> MINUS .)
    NULL            reduce using rule 80 (arith_op -> MINUS .)
    TRUE            reduce using rule 80 (arith_op -> MINUS .)
    FALSE           reduce using rule 80 (arith_op -> MINUS .)
    ID              reduce using rule 80 (arith_op -> MINUS .)

  ! THIS            [ reduce using rule 92 (unary_op -> MINUS .) ]
  ! SUPER           [ reduce using rule 92 (unary_op -> MINUS .) ]
  ! (               [ reduce using rule 92 (unary_op -> MINUS .) ]
  ! NEW             [ reduce using rule 92 (unary_op -> MINUS .) ]
  ! PLUS            [ reduce using rule 92 (unary_op -> MINUS .) ]
  ! MINUS           [ reduce using rule 92 (unary_op -> MINUS .) ]
  ! INT_CONST       [ reduce using rule 92 (unary_op -> MINUS .) ]
  ! FLOAT_CONST     [ reduce using rule 92 (unary_op -> MINUS .) ]
  ! STRING_CONST    [ reduce using rule 92 (unary_op -> MINUS .) ]
  ! NULL            [ reduce using rule 92 (unary_op -> MINUS .) ]
  ! TRUE            [ reduce using rule 92 (unary_op -> MINUS .) ]
  ! FALSE           [ reduce using rule 92 (unary_op -> MINUS .) ]
  ! ID              [ reduce using rule 92 (unary_op -> MINUS .) ]


state 122

    (81) arith_op -> TIMES .

    THIS            reduce using rule 81 (arith_op -> TIMES .)
    SUPER           reduce using rule 81 (arith_op -> TIMES .)
    (               reduce using rule 81 (arith_op -> TIMES .)
    NEW             reduce using rule 81 (arith_op -> TIMES .)
    PLUS            reduce using rule 81 (arith_op -> TIMES .)
    MINUS           reduce using rule 81 (arith_op -> TIMES .)
    INT_CONST       reduce using rule 81 (arith_op -> TIMES .)
    FLOAT_CONST     reduce using rule 81 (arith_op -> TIMES .)
    STRING_CONST    reduce using rule 81 (arith_op -> TIMES .)
    NULL            reduce using rule 81 (arith_op -> TIMES .)
    TRUE            reduce using rule 81 (arith_op -> TIMES .)
    FALSE           reduce using rule 81 (arith_op -> TIMES .)
    ID              reduce using rule 81 (arith_op -> TIMES .)


state 123

    (82) arith_op -> DIVIDE .

    THIS            reduce using rule 82 (arith_op -> DIVIDE .)
    SUPER           reduce using rule 82 (arith_op -> DIVIDE .)
    (               reduce using rule 82 (arith_op -> DIVIDE .)
    NEW             reduce using rule 82 (arith_op -> DIVIDE .)
    PLUS            reduce using rule 82 (arith_op -> DIVIDE .)
    MINUS           reduce using rule 82 (arith_op -> DIVIDE .)
    INT_CONST       reduce using rule 82 (arith_op -> DIVIDE .)
    FLOAT_CONST     reduce using rule 82 (arith_op -> DIVIDE .)
    STRING_CONST    reduce using rule 82 (arith_op -> DIVIDE .)
    NULL            reduce using rule 82 (arith_op -> DIVIDE .)
    TRUE            reduce using rule 82 (arith_op -> DIVIDE .)
    FALSE           reduce using rule 82 (arith_op -> DIVIDE .)
    ID              reduce using rule 82 (arith_op -> DIVIDE .)


state 124

    (83) bool_op -> AND .

    THIS            reduce using rule 83 (bool_op -> AND .)
    SUPER           reduce using rule 83 (bool_op -> AND .)
    (               reduce using rule 83 (bool_op -> AND .)
    NEW             reduce using rule 83 (bool_op -> AND .)
    PLUS            reduce using rule 83 (bool_op -> AND .)
    MINUS           reduce using rule 83 (bool_op -> AND .)
    INT_CONST       reduce using rule 83 (bool_op -> AND .)
    FLOAT_CONST     reduce using rule 83 (bool_op -> AND .)
    STRING_CONST    reduce using rule 83 (bool_op -> AND .)
    NULL            reduce using rule 83 (bool_op -> AND .)
    TRUE            reduce using rule 83 (bool_op -> AND .)
    FALSE           reduce using rule 83 (bool_op -> AND .)
    ID              reduce using rule 83 (bool_op -> AND .)


state 125

    (84) bool_op -> OR .

    THIS            reduce using rule 84 (bool_op -> OR .)
    SUPER           reduce using rule 84 (bool_op -> OR .)
    (               reduce using rule 84 (bool_op -> OR .)
    NEW             reduce using rule 84 (bool_op -> OR .)
    PLUS            reduce using rule 84 (bool_op -> OR .)
    MINUS           reduce using rule 84 (bool_op -> OR .)
    INT_CONST       reduce using rule 84 (bool_op -> OR .)
    FLOAT_CONST     reduce using rule 84 (bool_op -> OR .)
    STRING_CONST    reduce using rule 84 (bool_op -> OR .)
    NULL            reduce using rule 84 (bool_op -> OR .)
    TRUE            reduce using rule 84 (bool_op -> OR .)
    FALSE           reduce using rule 84 (bool_op -> OR .)
    ID              reduce using rule 84 (bool_op -> OR .)


state 126

    (85) bool_op -> EQUALITY .

    THIS            reduce using rule 85 (bool_op -> EQUALITY .)
    SUPER           reduce using rule 85 (bool_op -> EQUALITY .)
    (               reduce using rule 85 (bool_op -> EQUALITY .)
    NEW             reduce using rule 85 (bool_op -> EQUALITY .)
    PLUS            reduce using rule 85 (bool_op -> EQUALITY .)
    MINUS           reduce using rule 85 (bool_op -> EQUALITY .)
    INT_CONST       reduce using rule 85 (bool_op -> EQUALITY .)
    FLOAT_CONST     reduce using rule 85 (bool_op -> EQUALITY .)
    STRING_CONST    reduce using rule 85 (bool_op -> EQUALITY .)
    NULL            reduce using rule 85 (bool_op -> EQUALITY .)
    TRUE            reduce using rule 85 (bool_op -> EQUALITY .)
    FALSE           reduce using rule 85 (bool_op -> EQUALITY .)
    ID              reduce using rule 85 (bool_op -> EQUALITY .)


state 127

    (86) bool_op -> INEQUALITY .

    THIS            reduce using rule 86 (bool_op -> INEQUALITY .)
    SUPER           reduce using rule 86 (bool_op -> INEQUALITY .)
    (               reduce using rule 86 (bool_op -> INEQUALITY .)
    NEW             reduce using rule 86 (bool_op -> INEQUALITY .)
    PLUS            reduce using rule 86 (bool_op -> INEQUALITY .)
    MINUS           reduce using rule 86 (bool_op -> INEQUALITY .)
    INT_CONST       reduce using rule 86 (bool_op -> INEQUALITY .)
    FLOAT_CONST     reduce using rule 86 (bool_op -> INEQUALITY .)
    STRING_CONST    reduce using rule 86 (bool_op -> INEQUALITY .)
    NULL            reduce using rule 86 (bool_op -> INEQUALITY .)
    TRUE            reduce using rule 86 (bool_op -> INEQUALITY .)
    FALSE           reduce using rule 86 (bool_op -> INEQUALITY .)
    ID              reduce using rule 86 (bool_op -> INEQUALITY .)


state 128

    (87) bool_op -> LESSER .

    THIS            reduce using rule 87 (bool_op -> LESSER .)
    SUPER           reduce using rule 87 (bool_op -> LESSER .)
    (               reduce using rule 87 (bool_op -> LESSER .)
    NEW             reduce using rule 87 (bool_op -> LESSER .)
    PLUS            reduce using rule 87 (bool_op -> LESSER .)
    MINUS           reduce using rule 87 (bool_op -> LESSER .)
    INT_CONST       reduce using rule 87 (bool_op -> LESSER .)
    FLOAT_CONST     reduce using rule 87 (bool_op -> LESSER .)
    STRING_CONST    reduce using rule 87 (bool_op -> LESSER .)
    NULL            reduce using rule 87 (bool_op -> LESSER .)
    TRUE            reduce using rule 87 (bool_op -> LESSER .)
    FALSE           reduce using rule 87 (bool_op -> LESSER .)
    ID              reduce using rule 87 (bool_op -> LESSER .)


state 129

    (88) bool_op -> GREATER .

    THIS            reduce using rule 88 (bool_op -> GREATER .)
    SUPER           reduce using rule 88 (bool_op -> GREATER .)
    (               reduce using rule 88 (bool_op -> GREATER .)
    NEW             reduce using rule 88 (bool_op -> GREATER .)
    PLUS            reduce using rule 88 (bool_op -> GREATER .)
    MINUS           reduce using rule 88 (bool_op -> GREATER .)
    INT_CONST       reduce using rule 88 (bool_op -> GREATER .)
    FLOAT_CONST     reduce using rule 88 (bool_op -> GREATER .)
    STRING_CONST    reduce using rule 88 (bool_op -> GREATER .)
    NULL            reduce using rule 88 (bool_op -> GREATER .)
    TRUE            reduce using rule 88 (bool_op -> GREATER .)
    FALSE           reduce using rule 88 (bool_op -> GREATER .)
    ID              reduce using rule 88 (bool_op -> GREATER .)


state 130

    (89) bool_op -> LEQ .

    THIS            reduce using rule 89 (bool_op -> LEQ .)
    SUPER           reduce using rule 89 (bool_op -> LEQ .)
    (               reduce using rule 89 (bool_op -> LEQ .)
    NEW             reduce using rule 89 (bool_op -> LEQ .)
    PLUS            reduce using rule 89 (bool_op -> LEQ .)
    MINUS           reduce using rule 89 (bool_op -> LEQ .)
    INT_CONST       reduce using rule 89 (bool_op -> LEQ .)
    FLOAT_CONST     reduce using rule 89 (bool_op -> LEQ .)
    STRING_CONST    reduce using rule 89 (bool_op -> LEQ .)
    NULL            reduce using rule 89 (bool_op -> LEQ .)
    TRUE            reduce using rule 89 (bool_op -> LEQ .)
    FALSE           reduce using rule 89 (bool_op -> LEQ .)
    ID              reduce using rule 89 (bool_op -> LEQ .)


state 131

    (90) bool_op -> GEQ .

    THIS            reduce using rule 90 (bool_op -> GEQ .)
    SUPER           reduce using rule 90 (bool_op -> GEQ .)
    (               reduce using rule 90 (bool_op -> GEQ .)
    NEW             reduce using rule 90 (bool_op -> GEQ .)
    PLUS            reduce using rule 90 (bool_op -> GEQ .)
    MINUS           reduce using rule 90 (bool_op -> GEQ .)
    INT_CONST       reduce using rule 90 (bool_op -> GEQ .)
    FLOAT_CONST     reduce using rule 90 (bool_op -> GEQ .)
    STRING_CONST    reduce using rule 90 (bool_op -> GEQ .)
    NULL            reduce using rule 90 (bool_op -> GEQ .)
    TRUE            reduce using rule 90 (bool_op -> GEQ .)
    FALSE           reduce using rule 90 (bool_op -> GEQ .)
    ID              reduce using rule 90 (bool_op -> GEQ .)


state 132

    (93) unary_op -> NOT .

    THIS            reduce using rule 93 (unary_op -> NOT .)
    SUPER           reduce using rule 93 (unary_op -> NOT .)
    (               reduce using rule 93 (unary_op -> NOT .)
    NEW             reduce using rule 93 (unary_op -> NOT .)
    PLUS            reduce using rule 93 (unary_op -> NOT .)
    MINUS           reduce using rule 93 (unary_op -> NOT .)
    INT_CONST       reduce using rule 93 (unary_op -> NOT .)
    FLOAT_CONST     reduce using rule 93 (unary_op -> NOT .)
    STRING_CONST    reduce using rule 93 (unary_op -> NOT .)
    NULL            reduce using rule 93 (unary_op -> NOT .)
    TRUE            reduce using rule 93 (unary_op -> NOT .)
    FALSE           reduce using rule 93 (unary_op -> NOT .)
    ID              reduce using rule 93 (unary_op -> NOT .)


state 133

    (36) stmt -> WHILE ( expr . ) stmt
    (71) expr -> expr . arith_op expr
    (72) expr -> expr . bool_op expr
    (73) expr -> expr . unary_op expr
    (79) arith_op -> . PLUS
    (80) arith_op -> . MINUS
    (81) arith_op -> . TIMES
    (82) arith_op -> . DIVIDE
    (83) bool_op -> . AND
    (84) bool_op -> . OR
    (85) bool_op -> . EQUALITY
    (86) bool_op -> . INEQUALITY
    (87) bool_op -> . LESSER
    (88) bool_op -> . GREATER
    (89) bool_op -> . LEQ
    (90) bool_op -> . GEQ
    (91) unary_op -> . PLUS
    (92) unary_op -> . MINUS
    (93) unary_op -> . NOT

    )               shift and go to state 152
    PLUS            shift and go to state 120
    MINUS           shift and go to state 121
    TIMES           shift and go to state 122
    DIVIDE          shift and go to state 123
    AND             shift and go to state 124
    OR              shift and go to state 125
    EQUALITY        shift and go to state 126
    INEQUALITY      shift and go to state 127
    LESSER          shift and go to state 128
    GREATER         shift and go to state 129
    LEQ             shift and go to state 130
    GEQ             shift and go to state 131
    NOT             shift and go to state 132

    arith_op                       shift and go to state 117
    bool_op                        shift and go to state 118
    unary_op                       shift and go to state 119

state 134

    (37) stmt -> FOR ( optional_stmt_expr . ; optional_expr ; optional_stmt_expr ) stmt

    ;               shift and go to state 153


state 135

    (47) optional_stmt_expr -> stmt_expr .

    ;               reduce using rule 47 (optional_stmt_expr -> stmt_expr .)
    )               reduce using rule 47 (optional_stmt_expr -> stmt_expr .)


state 136

    (48) optional_stmt_expr -> empty .

    ;               reduce using rule 48 (optional_stmt_expr -> empty .)
    )               reduce using rule 48 (optional_stmt_expr -> empty .)


state 137

    (38) stmt -> RETURN optional_expr ; .

    }               reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    IF              reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    WHILE           reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    FOR             reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    RETURN          reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    BREAK           reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    CONTINUE        reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    ;               reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    {               reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    PLUS            reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    MINUS           reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    INT             reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    FLOAT           reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    BOOLEAN         reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    ID              reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    THIS            reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    SUPER           reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    (               reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    NEW             reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    INT_CONST       reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    FLOAT_CONST     reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    STRING_CONST    reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    NULL            reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    TRUE            reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    FALSE           reduce using rule 38 (stmt -> RETURN optional_expr ; .)
    ELSE            reduce using rule 38 (stmt -> RETURN optional_expr ; .)


state 138

    (74) assign -> field_access = expr .
    (71) expr -> expr . arith_op expr
    (72) expr -> expr . bool_op expr
    (73) expr -> expr . unary_op expr
    (79) arith_op -> . PLUS
    (80) arith_op -> . MINUS
    (81) arith_op -> . TIMES
    (82) arith_op -> . DIVIDE
    (83) bool_op -> . AND
    (84) bool_op -> . OR
    (85) bool_op -> . EQUALITY
    (86) bool_op -> . INEQUALITY
    (87) bool_op -> . LESSER
    (88) bool_op -> . GREATER
    (89) bool_op -> . LEQ
    (90) bool_op -> . GEQ
    (91) unary_op -> . PLUS
    (92) unary_op -> . MINUS
    (93) unary_op -> . NOT

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQUALITY resolved as shift
  ! shift/reduce conflict for INEQUALITY resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    ;               reduce using rule 74 (assign -> field_access = expr .)
    )               reduce using rule 74 (assign -> field_access = expr .)
    ,               reduce using rule 74 (assign -> field_access = expr .)
    PLUS            shift and go to state 120
    MINUS           shift and go to state 121
    TIMES           shift and go to state 122
    DIVIDE          shift and go to state 123
    AND             shift and go to state 124
    OR              shift and go to state 125
    EQUALITY        shift and go to state 126
    INEQUALITY      shift and go to state 127
    LESSER          shift and go to state 128
    GREATER         shift and go to state 129
    LEQ             shift and go to state 130
    GEQ             shift and go to state 131
    NOT             shift and go to state 132

  ! PLUS            [ reduce using rule 74 (assign -> field_access = expr .) ]
  ! MINUS           [ reduce using rule 74 (assign -> field_access = expr .) ]
  ! TIMES           [ reduce using rule 74 (assign -> field_access = expr .) ]
  ! DIVIDE          [ reduce using rule 74 (assign -> field_access = expr .) ]
  ! AND             [ reduce using rule 74 (assign -> field_access = expr .) ]
  ! OR              [ reduce using rule 74 (assign -> field_access = expr .) ]
  ! EQUALITY        [ reduce using rule 74 (assign -> field_access = expr .) ]
  ! INEQUALITY      [ reduce using rule 74 (assign -> field_access = expr .) ]
  ! LESSER          [ reduce using rule 74 (assign -> field_access = expr .) ]
  ! GREATER         [ reduce using rule 74 (assign -> field_access = expr .) ]
  ! LEQ             [ reduce using rule 74 (assign -> field_access = expr .) ]
  ! GEQ             [ reduce using rule 74 (assign -> field_access = expr .) ]
  ! NOT             [ reduce using rule 74 (assign -> field_access = expr .) ]

    arith_op                       shift and go to state 117
    bool_op                        shift and go to state 118
    unary_op                       shift and go to state 119

state 139

    (75) assign -> field_access PLUS PLUS .

    ;               reduce using rule 75 (assign -> field_access PLUS PLUS .)
    )               reduce using rule 75 (assign -> field_access PLUS PLUS .)
    PLUS            reduce using rule 75 (assign -> field_access PLUS PLUS .)
    MINUS           reduce using rule 75 (assign -> field_access PLUS PLUS .)
    TIMES           reduce using rule 75 (assign -> field_access PLUS PLUS .)
    DIVIDE          reduce using rule 75 (assign -> field_access PLUS PLUS .)
    AND             reduce using rule 75 (assign -> field_access PLUS PLUS .)
    OR              reduce using rule 75 (assign -> field_access PLUS PLUS .)
    EQUALITY        reduce using rule 75 (assign -> field_access PLUS PLUS .)
    INEQUALITY      reduce using rule 75 (assign -> field_access PLUS PLUS .)
    LESSER          reduce using rule 75 (assign -> field_access PLUS PLUS .)
    GREATER         reduce using rule 75 (assign -> field_access PLUS PLUS .)
    LEQ             reduce using rule 75 (assign -> field_access PLUS PLUS .)
    GEQ             reduce using rule 75 (assign -> field_access PLUS PLUS .)
    NOT             reduce using rule 75 (assign -> field_access PLUS PLUS .)
    ,               reduce using rule 75 (assign -> field_access PLUS PLUS .)


state 140

    (77) assign -> field_access MINUS MINUS .

    ;               reduce using rule 77 (assign -> field_access MINUS MINUS .)
    )               reduce using rule 77 (assign -> field_access MINUS MINUS .)
    PLUS            reduce using rule 77 (assign -> field_access MINUS MINUS .)
    MINUS           reduce using rule 77 (assign -> field_access MINUS MINUS .)
    TIMES           reduce using rule 77 (assign -> field_access MINUS MINUS .)
    DIVIDE          reduce using rule 77 (assign -> field_access MINUS MINUS .)
    AND             reduce using rule 77 (assign -> field_access MINUS MINUS .)
    OR              reduce using rule 77 (assign -> field_access MINUS MINUS .)
    EQUALITY        reduce using rule 77 (assign -> field_access MINUS MINUS .)
    INEQUALITY      reduce using rule 77 (assign -> field_access MINUS MINUS .)
    LESSER          reduce using rule 77 (assign -> field_access MINUS MINUS .)
    GREATER         reduce using rule 77 (assign -> field_access MINUS MINUS .)
    LEQ             reduce using rule 77 (assign -> field_access MINUS MINUS .)
    GEQ             reduce using rule 77 (assign -> field_access MINUS MINUS .)
    NOT             reduce using rule 77 (assign -> field_access MINUS MINUS .)
    ,               reduce using rule 77 (assign -> field_access MINUS MINUS .)


state 141

    (67) method_invocation -> field_access ( arguments . )

    )               shift and go to state 154


state 142

    (68) method_invocation -> field_access ( ) .

    ;               reduce using rule 68 (method_invocation -> field_access ( ) .)
    .               reduce using rule 68 (method_invocation -> field_access ( ) .)
    )               reduce using rule 68 (method_invocation -> field_access ( ) .)
    PLUS            reduce using rule 68 (method_invocation -> field_access ( ) .)
    MINUS           reduce using rule 68 (method_invocation -> field_access ( ) .)
    TIMES           reduce using rule 68 (method_invocation -> field_access ( ) .)
    DIVIDE          reduce using rule 68 (method_invocation -> field_access ( ) .)
    AND             reduce using rule 68 (method_invocation -> field_access ( ) .)
    OR              reduce using rule 68 (method_invocation -> field_access ( ) .)
    EQUALITY        reduce using rule 68 (method_invocation -> field_access ( ) .)
    INEQUALITY      reduce using rule 68 (method_invocation -> field_access ( ) .)
    LESSER          reduce using rule 68 (method_invocation -> field_access ( ) .)
    GREATER         reduce using rule 68 (method_invocation -> field_access ( ) .)
    LEQ             reduce using rule 68 (method_invocation -> field_access ( ) .)
    GEQ             reduce using rule 68 (method_invocation -> field_access ( ) .)
    NOT             reduce using rule 68 (method_invocation -> field_access ( ) .)
    ,               reduce using rule 68 (method_invocation -> field_access ( ) .)


state 143

    (63) arguments -> expr .
    (64) arguments -> expr . , arguments
    (71) expr -> expr . arith_op expr
    (72) expr -> expr . bool_op expr
    (73) expr -> expr . unary_op expr
    (79) arith_op -> . PLUS
    (80) arith_op -> . MINUS
    (81) arith_op -> . TIMES
    (82) arith_op -> . DIVIDE
    (83) bool_op -> . AND
    (84) bool_op -> . OR
    (85) bool_op -> . EQUALITY
    (86) bool_op -> . INEQUALITY
    (87) bool_op -> . LESSER
    (88) bool_op -> . GREATER
    (89) bool_op -> . LEQ
    (90) bool_op -> . GEQ
    (91) unary_op -> . PLUS
    (92) unary_op -> . MINUS
    (93) unary_op -> . NOT

    )               reduce using rule 63 (arguments -> expr .)
    ,               shift and go to state 155
    PLUS            shift and go to state 120
    MINUS           shift and go to state 121
    TIMES           shift and go to state 122
    DIVIDE          shift and go to state 123
    AND             shift and go to state 124
    OR              shift and go to state 125
    EQUALITY        shift and go to state 126
    INEQUALITY      shift and go to state 127
    LESSER          shift and go to state 128
    GREATER         shift and go to state 129
    LEQ             shift and go to state 130
    GEQ             shift and go to state 131
    NOT             shift and go to state 132

    arith_op                       shift and go to state 117
    bool_op                        shift and go to state 118
    unary_op                       shift and go to state 119

state 144

    (76) assign -> PLUS PLUS field_access .
    (61) primary -> field_access .
    (67) method_invocation -> field_access . ( arguments )
    (68) method_invocation -> field_access . ( )

    ;               reduce using rule 76 (assign -> PLUS PLUS field_access .)
    )               reduce using rule 76 (assign -> PLUS PLUS field_access .)
    PLUS            reduce using rule 76 (assign -> PLUS PLUS field_access .)
    MINUS           reduce using rule 76 (assign -> PLUS PLUS field_access .)
    TIMES           reduce using rule 76 (assign -> PLUS PLUS field_access .)
    DIVIDE          reduce using rule 76 (assign -> PLUS PLUS field_access .)
    AND             reduce using rule 76 (assign -> PLUS PLUS field_access .)
    OR              reduce using rule 76 (assign -> PLUS PLUS field_access .)
    EQUALITY        reduce using rule 76 (assign -> PLUS PLUS field_access .)
    INEQUALITY      reduce using rule 76 (assign -> PLUS PLUS field_access .)
    LESSER          reduce using rule 76 (assign -> PLUS PLUS field_access .)
    GREATER         reduce using rule 76 (assign -> PLUS PLUS field_access .)
    LEQ             reduce using rule 76 (assign -> PLUS PLUS field_access .)
    GEQ             reduce using rule 76 (assign -> PLUS PLUS field_access .)
    NOT             reduce using rule 76 (assign -> PLUS PLUS field_access .)
    ,               reduce using rule 76 (assign -> PLUS PLUS field_access .)
    .               reduce using rule 61 (primary -> field_access .)
    (               shift and go to state 110


state 145

    (78) assign -> MINUS MINUS field_access .
    (61) primary -> field_access .
    (67) method_invocation -> field_access . ( arguments )
    (68) method_invocation -> field_access . ( )

    ;               reduce using rule 78 (assign -> MINUS MINUS field_access .)
    )               reduce using rule 78 (assign -> MINUS MINUS field_access .)
    PLUS            reduce using rule 78 (assign -> MINUS MINUS field_access .)
    MINUS           reduce using rule 78 (assign -> MINUS MINUS field_access .)
    TIMES           reduce using rule 78 (assign -> MINUS MINUS field_access .)
    DIVIDE          reduce using rule 78 (assign -> MINUS MINUS field_access .)
    AND             reduce using rule 78 (assign -> MINUS MINUS field_access .)
    OR              reduce using rule 78 (assign -> MINUS MINUS field_access .)
    EQUALITY        reduce using rule 78 (assign -> MINUS MINUS field_access .)
    INEQUALITY      reduce using rule 78 (assign -> MINUS MINUS field_access .)
    LESSER          reduce using rule 78 (assign -> MINUS MINUS field_access .)
    GREATER         reduce using rule 78 (assign -> MINUS MINUS field_access .)
    LEQ             reduce using rule 78 (assign -> MINUS MINUS field_access .)
    GEQ             reduce using rule 78 (assign -> MINUS MINUS field_access .)
    NOT             reduce using rule 78 (assign -> MINUS MINUS field_access .)
    ,               reduce using rule 78 (assign -> MINUS MINUS field_access .)
    .               reduce using rule 61 (primary -> field_access .)
    (               shift and go to state 110


state 146

    (65) field_access -> primary . ID .

    =               reduce using rule 65 (field_access -> primary . ID .)
    PLUS            reduce using rule 65 (field_access -> primary . ID .)
    MINUS           reduce using rule 65 (field_access -> primary . ID .)
    (               reduce using rule 65 (field_access -> primary . ID .)
    .               reduce using rule 65 (field_access -> primary . ID .)
    )               reduce using rule 65 (field_access -> primary . ID .)
    TIMES           reduce using rule 65 (field_access -> primary . ID .)
    DIVIDE          reduce using rule 65 (field_access -> primary . ID .)
    AND             reduce using rule 65 (field_access -> primary . ID .)
    OR              reduce using rule 65 (field_access -> primary . ID .)
    EQUALITY        reduce using rule 65 (field_access -> primary . ID .)
    INEQUALITY      reduce using rule 65 (field_access -> primary . ID .)
    LESSER          reduce using rule 65 (field_access -> primary . ID .)
    GREATER         reduce using rule 65 (field_access -> primary . ID .)
    LEQ             reduce using rule 65 (field_access -> primary . ID .)
    GEQ             reduce using rule 65 (field_access -> primary . ID .)
    NOT             reduce using rule 65 (field_access -> primary . ID .)
    ;               reduce using rule 65 (field_access -> primary . ID .)
    ,               reduce using rule 65 (field_access -> primary . ID .)


state 147

    (59) primary -> NEW ID ( . arguments )
    (60) primary -> NEW ID ( . )
    (63) arguments -> . expr
    (64) arguments -> . expr , arguments
    (69) expr -> . primary
    (70) expr -> . assign
    (71) expr -> . expr arith_op expr
    (72) expr -> . expr bool_op expr
    (73) expr -> . expr unary_op expr
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )

    )               shift and go to state 157
    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88
    ID              shift and go to state 96

    arguments                      shift and go to state 156
    expr                           shift and go to state 143
    primary                        shift and go to state 94
    assign                         shift and go to state 95
    literal                        shift and go to state 79
    field_access                   shift and go to state 97
    method_invocation              shift and go to state 98

state 148

    (34) stmt -> IF ( expr ) . stmt ELSE stmt
    (35) stmt -> IF ( expr ) . stmt
    (33) stmt -> . stmt stmt
    (34) stmt -> . IF ( expr ) stmt ELSE stmt
    (35) stmt -> . IF ( expr ) stmt
    (36) stmt -> . WHILE ( expr ) stmt
    (37) stmt -> . FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (38) stmt -> . RETURN optional_expr ;
    (39) stmt -> . stmt_expr ;
    (40) stmt -> . BREAK ;
    (41) stmt -> . CONTINUE ;
    (42) stmt -> . block
    (43) stmt -> . var_decl
    (44) stmt -> . ;
    (94) stmt_expr -> . assign
    (95) stmt_expr -> . method_invocation
    (31) block -> . { stmt }
    (32) block -> . { }
    (17) var_decl -> . type variable ;
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE

    IF              shift and go to state 60
    WHILE           shift and go to state 62
    FOR             shift and go to state 63
    RETURN          shift and go to state 65
    BREAK           shift and go to state 67
    CONTINUE        shift and go to state 68
    ;               shift and go to state 64
    {               shift and go to state 54
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 77
    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88

    stmt                           shift and go to state 158
    stmt_expr                      shift and go to state 66
    block                          shift and go to state 69
    var_decl                       shift and go to state 70
    assign                         shift and go to state 71
    method_invocation              shift and go to state 72
    type                           shift and go to state 73
    field_access                   shift and go to state 74
    primary                        shift and go to state 78
    literal                        shift and go to state 79

state 149

    (71) expr -> expr arith_op expr .
    (71) expr -> expr . arith_op expr
    (72) expr -> expr . bool_op expr
    (73) expr -> expr . unary_op expr
    (79) arith_op -> . PLUS
    (80) arith_op -> . MINUS
    (81) arith_op -> . TIMES
    (82) arith_op -> . DIVIDE
    (83) bool_op -> . AND
    (84) bool_op -> . OR
    (85) bool_op -> . EQUALITY
    (86) bool_op -> . INEQUALITY
    (87) bool_op -> . LESSER
    (88) bool_op -> . GREATER
    (89) bool_op -> . LEQ
    (90) bool_op -> . GEQ
    (91) unary_op -> . PLUS
    (92) unary_op -> . MINUS
    (93) unary_op -> . NOT

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQUALITY resolved as shift
  ! shift/reduce conflict for INEQUALITY resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    )               reduce using rule 71 (expr -> expr arith_op expr .)
    ;               reduce using rule 71 (expr -> expr arith_op expr .)
    ,               reduce using rule 71 (expr -> expr arith_op expr .)
    PLUS            shift and go to state 120
    MINUS           shift and go to state 121
    TIMES           shift and go to state 122
    DIVIDE          shift and go to state 123
    AND             shift and go to state 124
    OR              shift and go to state 125
    EQUALITY        shift and go to state 126
    INEQUALITY      shift and go to state 127
    LESSER          shift and go to state 128
    GREATER         shift and go to state 129
    LEQ             shift and go to state 130
    GEQ             shift and go to state 131
    NOT             shift and go to state 132

  ! PLUS            [ reduce using rule 71 (expr -> expr arith_op expr .) ]
  ! MINUS           [ reduce using rule 71 (expr -> expr arith_op expr .) ]
  ! TIMES           [ reduce using rule 71 (expr -> expr arith_op expr .) ]
  ! DIVIDE          [ reduce using rule 71 (expr -> expr arith_op expr .) ]
  ! AND             [ reduce using rule 71 (expr -> expr arith_op expr .) ]
  ! OR              [ reduce using rule 71 (expr -> expr arith_op expr .) ]
  ! EQUALITY        [ reduce using rule 71 (expr -> expr arith_op expr .) ]
  ! INEQUALITY      [ reduce using rule 71 (expr -> expr arith_op expr .) ]
  ! LESSER          [ reduce using rule 71 (expr -> expr arith_op expr .) ]
  ! GREATER         [ reduce using rule 71 (expr -> expr arith_op expr .) ]
  ! LEQ             [ reduce using rule 71 (expr -> expr arith_op expr .) ]
  ! GEQ             [ reduce using rule 71 (expr -> expr arith_op expr .) ]
  ! NOT             [ reduce using rule 71 (expr -> expr arith_op expr .) ]

    arith_op                       shift and go to state 117
    bool_op                        shift and go to state 118
    unary_op                       shift and go to state 119

state 150

    (72) expr -> expr bool_op expr .
    (71) expr -> expr . arith_op expr
    (72) expr -> expr . bool_op expr
    (73) expr -> expr . unary_op expr
    (79) arith_op -> . PLUS
    (80) arith_op -> . MINUS
    (81) arith_op -> . TIMES
    (82) arith_op -> . DIVIDE
    (83) bool_op -> . AND
    (84) bool_op -> . OR
    (85) bool_op -> . EQUALITY
    (86) bool_op -> . INEQUALITY
    (87) bool_op -> . LESSER
    (88) bool_op -> . GREATER
    (89) bool_op -> . LEQ
    (90) bool_op -> . GEQ
    (91) unary_op -> . PLUS
    (92) unary_op -> . MINUS
    (93) unary_op -> . NOT

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQUALITY resolved as shift
  ! shift/reduce conflict for INEQUALITY resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    )               reduce using rule 72 (expr -> expr bool_op expr .)
    ;               reduce using rule 72 (expr -> expr bool_op expr .)
    ,               reduce using rule 72 (expr -> expr bool_op expr .)
    PLUS            shift and go to state 120
    MINUS           shift and go to state 121
    TIMES           shift and go to state 122
    DIVIDE          shift and go to state 123
    AND             shift and go to state 124
    OR              shift and go to state 125
    EQUALITY        shift and go to state 126
    INEQUALITY      shift and go to state 127
    LESSER          shift and go to state 128
    GREATER         shift and go to state 129
    LEQ             shift and go to state 130
    GEQ             shift and go to state 131
    NOT             shift and go to state 132

  ! PLUS            [ reduce using rule 72 (expr -> expr bool_op expr .) ]
  ! MINUS           [ reduce using rule 72 (expr -> expr bool_op expr .) ]
  ! TIMES           [ reduce using rule 72 (expr -> expr bool_op expr .) ]
  ! DIVIDE          [ reduce using rule 72 (expr -> expr bool_op expr .) ]
  ! AND             [ reduce using rule 72 (expr -> expr bool_op expr .) ]
  ! OR              [ reduce using rule 72 (expr -> expr bool_op expr .) ]
  ! EQUALITY        [ reduce using rule 72 (expr -> expr bool_op expr .) ]
  ! INEQUALITY      [ reduce using rule 72 (expr -> expr bool_op expr .) ]
  ! LESSER          [ reduce using rule 72 (expr -> expr bool_op expr .) ]
  ! GREATER         [ reduce using rule 72 (expr -> expr bool_op expr .) ]
  ! LEQ             [ reduce using rule 72 (expr -> expr bool_op expr .) ]
  ! GEQ             [ reduce using rule 72 (expr -> expr bool_op expr .) ]
  ! NOT             [ reduce using rule 72 (expr -> expr bool_op expr .) ]

    bool_op                        shift and go to state 118
    arith_op                       shift and go to state 117
    unary_op                       shift and go to state 119

state 151

    (73) expr -> expr unary_op expr .
    (71) expr -> expr . arith_op expr
    (72) expr -> expr . bool_op expr
    (73) expr -> expr . unary_op expr
    (79) arith_op -> . PLUS
    (80) arith_op -> . MINUS
    (81) arith_op -> . TIMES
    (82) arith_op -> . DIVIDE
    (83) bool_op -> . AND
    (84) bool_op -> . OR
    (85) bool_op -> . EQUALITY
    (86) bool_op -> . INEQUALITY
    (87) bool_op -> . LESSER
    (88) bool_op -> . GREATER
    (89) bool_op -> . LEQ
    (90) bool_op -> . GEQ
    (91) unary_op -> . PLUS
    (92) unary_op -> . MINUS
    (93) unary_op -> . NOT

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQUALITY resolved as shift
  ! shift/reduce conflict for INEQUALITY resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    )               reduce using rule 73 (expr -> expr unary_op expr .)
    ;               reduce using rule 73 (expr -> expr unary_op expr .)
    ,               reduce using rule 73 (expr -> expr unary_op expr .)
    PLUS            shift and go to state 120
    MINUS           shift and go to state 121
    TIMES           shift and go to state 122
    DIVIDE          shift and go to state 123
    AND             shift and go to state 124
    OR              shift and go to state 125
    EQUALITY        shift and go to state 126
    INEQUALITY      shift and go to state 127
    LESSER          shift and go to state 128
    GREATER         shift and go to state 129
    LEQ             shift and go to state 130
    GEQ             shift and go to state 131
    NOT             shift and go to state 132

  ! PLUS            [ reduce using rule 73 (expr -> expr unary_op expr .) ]
  ! MINUS           [ reduce using rule 73 (expr -> expr unary_op expr .) ]
  ! TIMES           [ reduce using rule 73 (expr -> expr unary_op expr .) ]
  ! DIVIDE          [ reduce using rule 73 (expr -> expr unary_op expr .) ]
  ! AND             [ reduce using rule 73 (expr -> expr unary_op expr .) ]
  ! OR              [ reduce using rule 73 (expr -> expr unary_op expr .) ]
  ! EQUALITY        [ reduce using rule 73 (expr -> expr unary_op expr .) ]
  ! INEQUALITY      [ reduce using rule 73 (expr -> expr unary_op expr .) ]
  ! LESSER          [ reduce using rule 73 (expr -> expr unary_op expr .) ]
  ! GREATER         [ reduce using rule 73 (expr -> expr unary_op expr .) ]
  ! LEQ             [ reduce using rule 73 (expr -> expr unary_op expr .) ]
  ! GEQ             [ reduce using rule 73 (expr -> expr unary_op expr .) ]
  ! NOT             [ reduce using rule 73 (expr -> expr unary_op expr .) ]

    unary_op                       shift and go to state 119
    arith_op                       shift and go to state 117
    bool_op                        shift and go to state 118

state 152

    (36) stmt -> WHILE ( expr ) . stmt
    (33) stmt -> . stmt stmt
    (34) stmt -> . IF ( expr ) stmt ELSE stmt
    (35) stmt -> . IF ( expr ) stmt
    (36) stmt -> . WHILE ( expr ) stmt
    (37) stmt -> . FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (38) stmt -> . RETURN optional_expr ;
    (39) stmt -> . stmt_expr ;
    (40) stmt -> . BREAK ;
    (41) stmt -> . CONTINUE ;
    (42) stmt -> . block
    (43) stmt -> . var_decl
    (44) stmt -> . ;
    (94) stmt_expr -> . assign
    (95) stmt_expr -> . method_invocation
    (31) block -> . { stmt }
    (32) block -> . { }
    (17) var_decl -> . type variable ;
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE

    IF              shift and go to state 60
    WHILE           shift and go to state 62
    FOR             shift and go to state 63
    RETURN          shift and go to state 65
    BREAK           shift and go to state 67
    CONTINUE        shift and go to state 68
    ;               shift and go to state 64
    {               shift and go to state 54
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 77
    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88

    stmt                           shift and go to state 159
    stmt_expr                      shift and go to state 66
    block                          shift and go to state 69
    var_decl                       shift and go to state 70
    assign                         shift and go to state 71
    method_invocation              shift and go to state 72
    type                           shift and go to state 73
    field_access                   shift and go to state 74
    primary                        shift and go to state 78
    literal                        shift and go to state 79

state 153

    (37) stmt -> FOR ( optional_stmt_expr ; . optional_expr ; optional_stmt_expr ) stmt
    (45) optional_expr -> . expr
    (46) optional_expr -> . empty
    (69) expr -> . primary
    (70) expr -> . assign
    (71) expr -> . expr arith_op expr
    (72) expr -> . expr bool_op expr
    (73) expr -> . expr unary_op expr
    (96) empty -> .
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )

    ;               reduce using rule 96 (empty -> .)
    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88
    ID              shift and go to state 96

    optional_expr                  shift and go to state 160
    expr                           shift and go to state 102
    empty                          shift and go to state 103
    primary                        shift and go to state 94
    assign                         shift and go to state 95
    literal                        shift and go to state 79
    field_access                   shift and go to state 97
    method_invocation              shift and go to state 98

state 154

    (67) method_invocation -> field_access ( arguments ) .

    ;               reduce using rule 67 (method_invocation -> field_access ( arguments ) .)
    .               reduce using rule 67 (method_invocation -> field_access ( arguments ) .)
    )               reduce using rule 67 (method_invocation -> field_access ( arguments ) .)
    PLUS            reduce using rule 67 (method_invocation -> field_access ( arguments ) .)
    MINUS           reduce using rule 67 (method_invocation -> field_access ( arguments ) .)
    TIMES           reduce using rule 67 (method_invocation -> field_access ( arguments ) .)
    DIVIDE          reduce using rule 67 (method_invocation -> field_access ( arguments ) .)
    AND             reduce using rule 67 (method_invocation -> field_access ( arguments ) .)
    OR              reduce using rule 67 (method_invocation -> field_access ( arguments ) .)
    EQUALITY        reduce using rule 67 (method_invocation -> field_access ( arguments ) .)
    INEQUALITY      reduce using rule 67 (method_invocation -> field_access ( arguments ) .)
    LESSER          reduce using rule 67 (method_invocation -> field_access ( arguments ) .)
    GREATER         reduce using rule 67 (method_invocation -> field_access ( arguments ) .)
    LEQ             reduce using rule 67 (method_invocation -> field_access ( arguments ) .)
    GEQ             reduce using rule 67 (method_invocation -> field_access ( arguments ) .)
    NOT             reduce using rule 67 (method_invocation -> field_access ( arguments ) .)
    ,               reduce using rule 67 (method_invocation -> field_access ( arguments ) .)


state 155

    (64) arguments -> expr , . arguments
    (63) arguments -> . expr
    (64) arguments -> . expr , arguments
    (69) expr -> . primary
    (70) expr -> . assign
    (71) expr -> . expr arith_op expr
    (72) expr -> . expr bool_op expr
    (73) expr -> . expr unary_op expr
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )

    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88
    ID              shift and go to state 96

    expr                           shift and go to state 143
    arguments                      shift and go to state 161
    primary                        shift and go to state 94
    assign                         shift and go to state 95
    literal                        shift and go to state 79
    field_access                   shift and go to state 97
    method_invocation              shift and go to state 98

state 156

    (59) primary -> NEW ID ( arguments . )

    )               shift and go to state 162


state 157

    (60) primary -> NEW ID ( ) .

    .               reduce using rule 60 (primary -> NEW ID ( ) .)
    )               reduce using rule 60 (primary -> NEW ID ( ) .)
    PLUS            reduce using rule 60 (primary -> NEW ID ( ) .)
    MINUS           reduce using rule 60 (primary -> NEW ID ( ) .)
    TIMES           reduce using rule 60 (primary -> NEW ID ( ) .)
    DIVIDE          reduce using rule 60 (primary -> NEW ID ( ) .)
    AND             reduce using rule 60 (primary -> NEW ID ( ) .)
    OR              reduce using rule 60 (primary -> NEW ID ( ) .)
    EQUALITY        reduce using rule 60 (primary -> NEW ID ( ) .)
    INEQUALITY      reduce using rule 60 (primary -> NEW ID ( ) .)
    LESSER          reduce using rule 60 (primary -> NEW ID ( ) .)
    GREATER         reduce using rule 60 (primary -> NEW ID ( ) .)
    LEQ             reduce using rule 60 (primary -> NEW ID ( ) .)
    GEQ             reduce using rule 60 (primary -> NEW ID ( ) .)
    NOT             reduce using rule 60 (primary -> NEW ID ( ) .)
    ;               reduce using rule 60 (primary -> NEW ID ( ) .)
    ,               reduce using rule 60 (primary -> NEW ID ( ) .)


state 158

    (34) stmt -> IF ( expr ) stmt . ELSE stmt
    (35) stmt -> IF ( expr ) stmt .
    (33) stmt -> stmt . stmt
    (33) stmt -> . stmt stmt
    (34) stmt -> . IF ( expr ) stmt ELSE stmt
    (35) stmt -> . IF ( expr ) stmt
    (36) stmt -> . WHILE ( expr ) stmt
    (37) stmt -> . FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (38) stmt -> . RETURN optional_expr ;
    (39) stmt -> . stmt_expr ;
    (40) stmt -> . BREAK ;
    (41) stmt -> . CONTINUE ;
    (42) stmt -> . block
    (43) stmt -> . var_decl
    (44) stmt -> . ;
    (94) stmt_expr -> . assign
    (95) stmt_expr -> . method_invocation
    (31) block -> . { stmt }
    (32) block -> . { }
    (17) var_decl -> . type variable ;
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INT_CONST resolved as shift
  ! shift/reduce conflict for FLOAT_CONST resolved as shift
  ! shift/reduce conflict for STRING_CONST resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    ELSE            shift and go to state 163
    }               reduce using rule 35 (stmt -> IF ( expr ) stmt .)
    IF              shift and go to state 60
    WHILE           shift and go to state 62
    FOR             shift and go to state 63
    RETURN          shift and go to state 65
    BREAK           shift and go to state 67
    CONTINUE        shift and go to state 68
    ;               shift and go to state 64
    {               shift and go to state 54
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 77
    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88

  ! IF              [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! WHILE           [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! FOR             [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! RETURN          [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! BREAK           [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! CONTINUE        [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! ;               [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! {               [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! PLUS            [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! MINUS           [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! INT             [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! FLOAT           [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! BOOLEAN         [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! ID              [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! THIS            [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! SUPER           [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! (               [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! NEW             [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! INT_CONST       [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! FLOAT_CONST     [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! STRING_CONST    [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! NULL            [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! TRUE            [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! FALSE           [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]
  ! ELSE            [ reduce using rule 35 (stmt -> IF ( expr ) stmt .) ]

    stmt                           shift and go to state 90
    stmt_expr                      shift and go to state 66
    block                          shift and go to state 69
    var_decl                       shift and go to state 70
    assign                         shift and go to state 71
    method_invocation              shift and go to state 72
    type                           shift and go to state 73
    field_access                   shift and go to state 74
    primary                        shift and go to state 78
    literal                        shift and go to state 79

state 159

    (36) stmt -> WHILE ( expr ) stmt .
    (33) stmt -> stmt . stmt
    (33) stmt -> . stmt stmt
    (34) stmt -> . IF ( expr ) stmt ELSE stmt
    (35) stmt -> . IF ( expr ) stmt
    (36) stmt -> . WHILE ( expr ) stmt
    (37) stmt -> . FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (38) stmt -> . RETURN optional_expr ;
    (39) stmt -> . stmt_expr ;
    (40) stmt -> . BREAK ;
    (41) stmt -> . CONTINUE ;
    (42) stmt -> . block
    (43) stmt -> . var_decl
    (44) stmt -> . ;
    (94) stmt_expr -> . assign
    (95) stmt_expr -> . method_invocation
    (31) block -> . { stmt }
    (32) block -> . { }
    (17) var_decl -> . type variable ;
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INT_CONST resolved as shift
  ! shift/reduce conflict for FLOAT_CONST resolved as shift
  ! shift/reduce conflict for STRING_CONST resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    }               reduce using rule 36 (stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 36 (stmt -> WHILE ( expr ) stmt .)
    IF              shift and go to state 60
    WHILE           shift and go to state 62
    FOR             shift and go to state 63
    RETURN          shift and go to state 65
    BREAK           shift and go to state 67
    CONTINUE        shift and go to state 68
    ;               shift and go to state 64
    {               shift and go to state 54
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 77
    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88

  ! IF              [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! WHILE           [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! FOR             [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! RETURN          [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! BREAK           [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! CONTINUE        [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! ;               [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! {               [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! PLUS            [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! MINUS           [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! INT             [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! FLOAT           [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! BOOLEAN         [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! ID              [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! THIS            [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! SUPER           [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! (               [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! NEW             [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! INT_CONST       [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! FLOAT_CONST     [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! STRING_CONST    [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! NULL            [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! TRUE            [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]
  ! FALSE           [ reduce using rule 36 (stmt -> WHILE ( expr ) stmt .) ]

    stmt                           shift and go to state 90
    stmt_expr                      shift and go to state 66
    block                          shift and go to state 69
    var_decl                       shift and go to state 70
    assign                         shift and go to state 71
    method_invocation              shift and go to state 72
    type                           shift and go to state 73
    field_access                   shift and go to state 74
    primary                        shift and go to state 78
    literal                        shift and go to state 79

state 160

    (37) stmt -> FOR ( optional_stmt_expr ; optional_expr . ; optional_stmt_expr ) stmt

    ;               shift and go to state 164


state 161

    (64) arguments -> expr , arguments .

    )               reduce using rule 64 (arguments -> expr , arguments .)


state 162

    (59) primary -> NEW ID ( arguments ) .

    .               reduce using rule 59 (primary -> NEW ID ( arguments ) .)
    )               reduce using rule 59 (primary -> NEW ID ( arguments ) .)
    PLUS            reduce using rule 59 (primary -> NEW ID ( arguments ) .)
    MINUS           reduce using rule 59 (primary -> NEW ID ( arguments ) .)
    TIMES           reduce using rule 59 (primary -> NEW ID ( arguments ) .)
    DIVIDE          reduce using rule 59 (primary -> NEW ID ( arguments ) .)
    AND             reduce using rule 59 (primary -> NEW ID ( arguments ) .)
    OR              reduce using rule 59 (primary -> NEW ID ( arguments ) .)
    EQUALITY        reduce using rule 59 (primary -> NEW ID ( arguments ) .)
    INEQUALITY      reduce using rule 59 (primary -> NEW ID ( arguments ) .)
    LESSER          reduce using rule 59 (primary -> NEW ID ( arguments ) .)
    GREATER         reduce using rule 59 (primary -> NEW ID ( arguments ) .)
    LEQ             reduce using rule 59 (primary -> NEW ID ( arguments ) .)
    GEQ             reduce using rule 59 (primary -> NEW ID ( arguments ) .)
    NOT             reduce using rule 59 (primary -> NEW ID ( arguments ) .)
    ;               reduce using rule 59 (primary -> NEW ID ( arguments ) .)
    ,               reduce using rule 59 (primary -> NEW ID ( arguments ) .)


state 163

    (34) stmt -> IF ( expr ) stmt ELSE . stmt
    (33) stmt -> . stmt stmt
    (34) stmt -> . IF ( expr ) stmt ELSE stmt
    (35) stmt -> . IF ( expr ) stmt
    (36) stmt -> . WHILE ( expr ) stmt
    (37) stmt -> . FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (38) stmt -> . RETURN optional_expr ;
    (39) stmt -> . stmt_expr ;
    (40) stmt -> . BREAK ;
    (41) stmt -> . CONTINUE ;
    (42) stmt -> . block
    (43) stmt -> . var_decl
    (44) stmt -> . ;
    (94) stmt_expr -> . assign
    (95) stmt_expr -> . method_invocation
    (31) block -> . { stmt }
    (32) block -> . { }
    (17) var_decl -> . type variable ;
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE

    IF              shift and go to state 60
    WHILE           shift and go to state 62
    FOR             shift and go to state 63
    RETURN          shift and go to state 65
    BREAK           shift and go to state 67
    CONTINUE        shift and go to state 68
    ;               shift and go to state 64
    {               shift and go to state 54
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 77
    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88

    stmt                           shift and go to state 165
    stmt_expr                      shift and go to state 66
    block                          shift and go to state 69
    var_decl                       shift and go to state 70
    assign                         shift and go to state 71
    method_invocation              shift and go to state 72
    type                           shift and go to state 73
    field_access                   shift and go to state 74
    primary                        shift and go to state 78
    literal                        shift and go to state 79

state 164

    (37) stmt -> FOR ( optional_stmt_expr ; optional_expr ; . optional_stmt_expr ) stmt
    (47) optional_stmt_expr -> . stmt_expr
    (48) optional_stmt_expr -> . empty
    (94) stmt_expr -> . assign
    (95) stmt_expr -> . method_invocation
    (96) empty -> .
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE

    )               reduce using rule 96 (empty -> .)
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    ID              shift and go to state 96
    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88

    optional_stmt_expr             shift and go to state 166
    stmt_expr                      shift and go to state 135
    empty                          shift and go to state 136
    assign                         shift and go to state 71
    method_invocation              shift and go to state 72
    field_access                   shift and go to state 74
    primary                        shift and go to state 78
    literal                        shift and go to state 79

state 165

    (34) stmt -> IF ( expr ) stmt ELSE stmt .
    (33) stmt -> stmt . stmt
    (33) stmt -> . stmt stmt
    (34) stmt -> . IF ( expr ) stmt ELSE stmt
    (35) stmt -> . IF ( expr ) stmt
    (36) stmt -> . WHILE ( expr ) stmt
    (37) stmt -> . FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (38) stmt -> . RETURN optional_expr ;
    (39) stmt -> . stmt_expr ;
    (40) stmt -> . BREAK ;
    (41) stmt -> . CONTINUE ;
    (42) stmt -> . block
    (43) stmt -> . var_decl
    (44) stmt -> . ;
    (94) stmt_expr -> . assign
    (95) stmt_expr -> . method_invocation
    (31) block -> . { stmt }
    (32) block -> . { }
    (17) var_decl -> . type variable ;
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INT_CONST resolved as shift
  ! shift/reduce conflict for FLOAT_CONST resolved as shift
  ! shift/reduce conflict for STRING_CONST resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    }               reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              shift and go to state 60
    WHILE           shift and go to state 62
    FOR             shift and go to state 63
    RETURN          shift and go to state 65
    BREAK           shift and go to state 67
    CONTINUE        shift and go to state 68
    ;               shift and go to state 64
    {               shift and go to state 54
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 77
    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88

  ! IF              [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! WHILE           [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! FOR             [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! RETURN          [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! BREAK           [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! CONTINUE        [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! ;               [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! {               [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! PLUS            [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! MINUS           [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! INT             [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! FLOAT           [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! BOOLEAN         [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! ID              [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! THIS            [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! SUPER           [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! (               [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! NEW             [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! INT_CONST       [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! FLOAT_CONST     [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! STRING_CONST    [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! NULL            [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! TRUE            [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! FALSE           [ reduce using rule 34 (stmt -> IF ( expr ) stmt ELSE stmt .) ]

    stmt                           shift and go to state 90
    stmt_expr                      shift and go to state 66
    block                          shift and go to state 69
    var_decl                       shift and go to state 70
    assign                         shift and go to state 71
    method_invocation              shift and go to state 72
    type                           shift and go to state 73
    field_access                   shift and go to state 74
    primary                        shift and go to state 78
    literal                        shift and go to state 79

state 166

    (37) stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr . ) stmt

    )               shift and go to state 167


state 167

    (37) stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) . stmt
    (33) stmt -> . stmt stmt
    (34) stmt -> . IF ( expr ) stmt ELSE stmt
    (35) stmt -> . IF ( expr ) stmt
    (36) stmt -> . WHILE ( expr ) stmt
    (37) stmt -> . FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (38) stmt -> . RETURN optional_expr ;
    (39) stmt -> . stmt_expr ;
    (40) stmt -> . BREAK ;
    (41) stmt -> . CONTINUE ;
    (42) stmt -> . block
    (43) stmt -> . var_decl
    (44) stmt -> . ;
    (94) stmt_expr -> . assign
    (95) stmt_expr -> . method_invocation
    (31) block -> . { stmt }
    (32) block -> . { }
    (17) var_decl -> . type variable ;
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE

    IF              shift and go to state 60
    WHILE           shift and go to state 62
    FOR             shift and go to state 63
    RETURN          shift and go to state 65
    BREAK           shift and go to state 67
    CONTINUE        shift and go to state 68
    ;               shift and go to state 64
    {               shift and go to state 54
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 77
    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88

    stmt                           shift and go to state 168
    stmt_expr                      shift and go to state 66
    block                          shift and go to state 69
    var_decl                       shift and go to state 70
    assign                         shift and go to state 71
    method_invocation              shift and go to state 72
    type                           shift and go to state 73
    field_access                   shift and go to state 74
    primary                        shift and go to state 78
    literal                        shift and go to state 79

state 168

    (37) stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .
    (33) stmt -> stmt . stmt
    (33) stmt -> . stmt stmt
    (34) stmt -> . IF ( expr ) stmt ELSE stmt
    (35) stmt -> . IF ( expr ) stmt
    (36) stmt -> . WHILE ( expr ) stmt
    (37) stmt -> . FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (38) stmt -> . RETURN optional_expr ;
    (39) stmt -> . stmt_expr ;
    (40) stmt -> . BREAK ;
    (41) stmt -> . CONTINUE ;
    (42) stmt -> . block
    (43) stmt -> . var_decl
    (44) stmt -> . ;
    (94) stmt_expr -> . assign
    (95) stmt_expr -> . method_invocation
    (31) block -> . { stmt }
    (32) block -> . { }
    (17) var_decl -> . type variable ;
    (74) assign -> . field_access = expr
    (75) assign -> . field_access PLUS PLUS
    (76) assign -> . PLUS PLUS field_access
    (77) assign -> . field_access MINUS MINUS
    (78) assign -> . MINUS MINUS field_access
    (67) method_invocation -> . field_access ( arguments )
    (68) method_invocation -> . field_access ( )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (65) field_access -> . primary . ID
    (66) field_access -> . ID
    (55) primary -> . literal
    (56) primary -> . THIS
    (57) primary -> . SUPER
    (58) primary -> . ( expr )
    (59) primary -> . NEW ID ( arguments )
    (60) primary -> . NEW ID ( )
    (61) primary -> . field_access
    (62) primary -> . method_invocation
    (49) literal -> . INT_CONST
    (50) literal -> . FLOAT_CONST
    (51) literal -> . STRING_CONST
    (52) literal -> . NULL
    (53) literal -> . TRUE
    (54) literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INT_CONST resolved as shift
  ! shift/reduce conflict for FLOAT_CONST resolved as shift
  ! shift/reduce conflict for STRING_CONST resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    }               reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .)
    ELSE            reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .)
    IF              shift and go to state 60
    WHILE           shift and go to state 62
    FOR             shift and go to state 63
    RETURN          shift and go to state 65
    BREAK           shift and go to state 67
    CONTINUE        shift and go to state 68
    ;               shift and go to state 64
    {               shift and go to state 54
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 77
    THIS            shift and go to state 80
    SUPER           shift and go to state 81
    (               shift and go to state 61
    NEW             shift and go to state 82
    INT_CONST       shift and go to state 83
    FLOAT_CONST     shift and go to state 84
    STRING_CONST    shift and go to state 85
    NULL            shift and go to state 86
    TRUE            shift and go to state 87
    FALSE           shift and go to state 88

  ! IF              [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! WHILE           [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! FOR             [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! RETURN          [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! BREAK           [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! CONTINUE        [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! ;               [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! {               [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! PLUS            [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! MINUS           [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! INT             [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! FLOAT           [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! BOOLEAN         [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! ID              [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! THIS            [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! SUPER           [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! (               [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! NEW             [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! INT_CONST       [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! FLOAT_CONST     [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! STRING_CONST    [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! NULL            [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! TRUE            [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! FALSE           [ reduce using rule 37 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]

    stmt                           shift and go to state 90
    stmt_expr                      shift and go to state 66
    block                          shift and go to state 69
    var_decl                       shift and go to state 70
    assign                         shift and go to state 71
    method_invocation              shift and go to state 72
    type                           shift and go to state 73
    field_access                   shift and go to state 74
    primary                        shift and go to state 78
    literal                        shift and go to state 79
WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for CLASS in state 5 resolved as shift
WARNING: shift/reduce conflict for PRIVATE in state 20 resolved as shift
WARNING: shift/reduce conflict for PUBLIC in state 20 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 20 resolved as shift
WARNING: shift/reduce conflict for IF in state 90 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 90 resolved as shift
WARNING: shift/reduce conflict for FOR in state 90 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 90 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 90 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 90 resolved as shift
WARNING: shift/reduce conflict for ; in state 90 resolved as shift
WARNING: shift/reduce conflict for { in state 90 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 90 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 90 resolved as shift
WARNING: shift/reduce conflict for INT in state 90 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 90 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 90 resolved as shift
WARNING: shift/reduce conflict for ID in state 90 resolved as shift
WARNING: shift/reduce conflict for THIS in state 90 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 90 resolved as shift
WARNING: shift/reduce conflict for ( in state 90 resolved as shift
WARNING: shift/reduce conflict for NEW in state 90 resolved as shift
WARNING: shift/reduce conflict for INT_CONST in state 90 resolved as shift
WARNING: shift/reduce conflict for FLOAT_CONST in state 90 resolved as shift
WARNING: shift/reduce conflict for STRING_CONST in state 90 resolved as shift
WARNING: shift/reduce conflict for NULL in state 90 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 90 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 90 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 97 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 97 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 138 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 138 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 138 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 138 resolved as shift
WARNING: shift/reduce conflict for AND in state 138 resolved as shift
WARNING: shift/reduce conflict for OR in state 138 resolved as shift
WARNING: shift/reduce conflict for EQUALITY in state 138 resolved as shift
WARNING: shift/reduce conflict for INEQUALITY in state 138 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 138 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 138 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 138 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 138 resolved as shift
WARNING: shift/reduce conflict for NOT in state 138 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 149 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 149 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 149 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 149 resolved as shift
WARNING: shift/reduce conflict for AND in state 149 resolved as shift
WARNING: shift/reduce conflict for OR in state 149 resolved as shift
WARNING: shift/reduce conflict for EQUALITY in state 149 resolved as shift
WARNING: shift/reduce conflict for INEQUALITY in state 149 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 149 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 149 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 149 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 149 resolved as shift
WARNING: shift/reduce conflict for NOT in state 149 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 150 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 150 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 150 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 150 resolved as shift
WARNING: shift/reduce conflict for AND in state 150 resolved as shift
WARNING: shift/reduce conflict for OR in state 150 resolved as shift
WARNING: shift/reduce conflict for EQUALITY in state 150 resolved as shift
WARNING: shift/reduce conflict for INEQUALITY in state 150 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 150 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 150 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 150 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 150 resolved as shift
WARNING: shift/reduce conflict for NOT in state 150 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 151 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 151 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 151 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 151 resolved as shift
WARNING: shift/reduce conflict for AND in state 151 resolved as shift
WARNING: shift/reduce conflict for OR in state 151 resolved as shift
WARNING: shift/reduce conflict for EQUALITY in state 151 resolved as shift
WARNING: shift/reduce conflict for INEQUALITY in state 151 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 151 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 151 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 151 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 151 resolved as shift
WARNING: shift/reduce conflict for NOT in state 151 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 158 resolved as shift
WARNING: shift/reduce conflict for IF in state 158 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 158 resolved as shift
WARNING: shift/reduce conflict for FOR in state 158 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 158 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 158 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 158 resolved as shift
WARNING: shift/reduce conflict for ; in state 158 resolved as shift
WARNING: shift/reduce conflict for { in state 158 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 158 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 158 resolved as shift
WARNING: shift/reduce conflict for INT in state 158 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 158 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 158 resolved as shift
WARNING: shift/reduce conflict for ID in state 158 resolved as shift
WARNING: shift/reduce conflict for THIS in state 158 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 158 resolved as shift
WARNING: shift/reduce conflict for ( in state 158 resolved as shift
WARNING: shift/reduce conflict for NEW in state 158 resolved as shift
WARNING: shift/reduce conflict for INT_CONST in state 158 resolved as shift
WARNING: shift/reduce conflict for FLOAT_CONST in state 158 resolved as shift
WARNING: shift/reduce conflict for STRING_CONST in state 158 resolved as shift
WARNING: shift/reduce conflict for NULL in state 158 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 158 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 158 resolved as shift
WARNING: shift/reduce conflict for IF in state 159 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 159 resolved as shift
WARNING: shift/reduce conflict for FOR in state 159 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 159 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 159 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 159 resolved as shift
WARNING: shift/reduce conflict for ; in state 159 resolved as shift
WARNING: shift/reduce conflict for { in state 159 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 159 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 159 resolved as shift
WARNING: shift/reduce conflict for INT in state 159 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 159 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 159 resolved as shift
WARNING: shift/reduce conflict for ID in state 159 resolved as shift
WARNING: shift/reduce conflict for THIS in state 159 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 159 resolved as shift
WARNING: shift/reduce conflict for ( in state 159 resolved as shift
WARNING: shift/reduce conflict for NEW in state 159 resolved as shift
WARNING: shift/reduce conflict for INT_CONST in state 159 resolved as shift
WARNING: shift/reduce conflict for FLOAT_CONST in state 159 resolved as shift
WARNING: shift/reduce conflict for STRING_CONST in state 159 resolved as shift
WARNING: shift/reduce conflict for NULL in state 159 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 159 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 159 resolved as shift
WARNING: shift/reduce conflict for IF in state 165 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 165 resolved as shift
WARNING: shift/reduce conflict for FOR in state 165 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 165 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 165 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 165 resolved as shift
WARNING: shift/reduce conflict for ; in state 165 resolved as shift
WARNING: shift/reduce conflict for { in state 165 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 165 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 165 resolved as shift
WARNING: shift/reduce conflict for INT in state 165 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 165 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 165 resolved as shift
WARNING: shift/reduce conflict for ID in state 165 resolved as shift
WARNING: shift/reduce conflict for THIS in state 165 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 165 resolved as shift
WARNING: shift/reduce conflict for ( in state 165 resolved as shift
WARNING: shift/reduce conflict for NEW in state 165 resolved as shift
WARNING: shift/reduce conflict for INT_CONST in state 165 resolved as shift
WARNING: shift/reduce conflict for FLOAT_CONST in state 165 resolved as shift
WARNING: shift/reduce conflict for STRING_CONST in state 165 resolved as shift
WARNING: shift/reduce conflict for NULL in state 165 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 165 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 165 resolved as shift
WARNING: shift/reduce conflict for IF in state 168 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 168 resolved as shift
WARNING: shift/reduce conflict for FOR in state 168 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 168 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 168 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 168 resolved as shift
WARNING: shift/reduce conflict for ; in state 168 resolved as shift
WARNING: shift/reduce conflict for { in state 168 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 168 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 168 resolved as shift
WARNING: shift/reduce conflict for INT in state 168 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 168 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 168 resolved as shift
WARNING: shift/reduce conflict for ID in state 168 resolved as shift
WARNING: shift/reduce conflict for THIS in state 168 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 168 resolved as shift
WARNING: shift/reduce conflict for ( in state 168 resolved as shift
WARNING: shift/reduce conflict for NEW in state 168 resolved as shift
WARNING: shift/reduce conflict for INT_CONST in state 168 resolved as shift
WARNING: shift/reduce conflict for FLOAT_CONST in state 168 resolved as shift
WARNING: shift/reduce conflict for STRING_CONST in state 168 resolved as shift
WARNING: shift/reduce conflict for NULL in state 168 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 168 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 168 resolved as shift
WARNING: reduce/reduce conflict in state 20 resolved using rule (class_body_decl -> class_body_decl class_body_decl)
WARNING: rejected rule (empty -> <empty>) in state 20
WARNING: reduce/reduce conflict in state 120 resolved using rule (arith_op -> PLUS)
WARNING: rejected rule (unary_op -> PLUS) in state 120
WARNING: reduce/reduce conflict in state 121 resolved using rule (arith_op -> MINUS)
WARNING: rejected rule (unary_op -> MINUS) in state 121
WARNING: Rule (unary_op -> PLUS) is never reduced
WARNING: Rule (unary_op -> MINUS) is never reduced
