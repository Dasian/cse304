Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DO

Grammar

Rule 0     S' -> program
Rule 1     program -> class_decl
Rule 2     program -> empty
Rule 3     class_decl -> class_decl class_decl
Rule 4     class_decl -> CLASS ID EXTENDS ID { class_body_decl }
Rule 5     class_decl -> CLASS ID { class_body_decl }
Rule 6     class_body_decl -> class_body_decl class_body_decl
Rule 7     class_body_decl -> field_decl
Rule 8     class_body_decl -> method_decl
Rule 9     class_body_decl -> constructor_decl
Rule 10    field_decl -> modifier var_decl
Rule 11    modifier -> PRIVATE STATIC
Rule 12    modifier -> PRIVATE
Rule 13    modifier -> PUBLIC STATIC
Rule 14    modifier -> PUBLIC
Rule 15    modifier -> STATIC
Rule 16    modifier -> empty
Rule 17    var_decl -> type variables ;
Rule 18    type -> INT
Rule 19    type -> FLOAT
Rule 20    type -> BOOLEAN
Rule 21    type -> ID
Rule 22    variables -> variable
Rule 23    variables -> variable , variables
Rule 24    variable -> ID
Rule 25    method_decl -> modifier type ID ( optional_formals ) block
Rule 26    method_decl -> modifier VOID ID ( optional_formals ) block
Rule 27    constructor_decl -> modifier ID ( optional_formals ) block
Rule 28    optional_formals -> formals
Rule 29    optional_formals -> empty
Rule 30    formals -> formal_param , formals
Rule 31    formals -> formal_param
Rule 32    formal_param -> type variable
Rule 33    block -> { stmt }
Rule 34    block -> { }
Rule 35    stmt -> stmt stmt
Rule 36    stmt -> IF ( expr ) stmt ELSE stmt
Rule 37    stmt -> IF ( expr ) stmt
Rule 38    stmt -> WHILE ( expr ) stmt
Rule 39    stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
Rule 40    stmt -> RETURN optional_expr ;
Rule 41    stmt -> stmt_expr ;
Rule 42    stmt -> BREAK ;
Rule 43    stmt -> CONTINUE ;
Rule 44    stmt -> block
Rule 45    stmt -> var_decl
Rule 46    stmt -> ;
Rule 47    optional_expr -> expr
Rule 48    optional_expr -> empty
Rule 49    optional_stmt_expr -> stmt_expr
Rule 50    optional_stmt_expr -> empty
Rule 51    literal -> INT_CONST
Rule 52    literal -> FLOAT_CONST
Rule 53    literal -> STRING_CONST
Rule 54    literal -> NULL
Rule 55    literal -> TRUE
Rule 56    literal -> FALSE
Rule 57    primary -> literal
Rule 58    primary -> THIS
Rule 59    primary -> SUPER
Rule 60    primary -> ( expr )
Rule 61    primary -> NEW ID ( arguments )
Rule 62    primary -> NEW ID ( )
Rule 63    primary -> field_access
Rule 64    primary -> method_invocation
Rule 65    arguments -> expr
Rule 66    arguments -> expr , arguments
Rule 67    field_access -> primary . ID
Rule 68    field_access -> ID
Rule 69    method_invocation -> field_access ( arguments )
Rule 70    method_invocation -> field_access ( )
Rule 71    expr -> primary
Rule 72    expr -> assign
Rule 73    expr -> expr arith_op expr
Rule 74    expr -> expr bool_op expr
Rule 75    expr -> unary_op expr
Rule 76    assign -> field_access ASSIGN expr
Rule 77    assign -> field_access PLUS PLUS
Rule 78    assign -> PLUS PLUS field_access
Rule 79    assign -> field_access MINUS MINUS
Rule 80    assign -> MINUS MINUS field_access
Rule 81    arith_op -> PLUS
Rule 82    arith_op -> MINUS
Rule 83    arith_op -> TIMES
Rule 84    arith_op -> DIVIDE
Rule 85    bool_op -> AND
Rule 86    bool_op -> OR
Rule 87    bool_op -> EQUALITY
Rule 88    bool_op -> INEQUALITY
Rule 89    bool_op -> LESSER
Rule 90    bool_op -> GREATER
Rule 91    bool_op -> LEQ
Rule 92    bool_op -> GEQ
Rule 93    unary_op -> PLUS
Rule 94    unary_op -> MINUS
Rule 95    unary_op -> NOT
Rule 96    stmt_expr -> assign
Rule 97    stmt_expr -> method_invocation
Rule 98    empty -> <empty>

Terminals, with rules where they appear

(                    : 25 26 27 36 37 38 39 60 61 62 69 70
)                    : 25 26 27 36 37 38 39 60 61 62 69 70
,                    : 23 30 66
.                    : 67
;                    : 17 39 39 40 41 42 43 46
AND                  : 85
ASSIGN               : 76
BOOLEAN              : 20
BREAK                : 42
CLASS                : 4 5
CONTINUE             : 43
DIVIDE               : 84
DO                   : 
ELSE                 : 36
EQUALITY             : 87
EXTENDS              : 4
FALSE                : 56
FLOAT                : 19
FLOAT_CONST          : 52
FOR                  : 39
GEQ                  : 92
GREATER              : 90
ID                   : 4 4 5 21 24 25 26 27 61 62 67 68
IF                   : 36 37
INEQUALITY           : 88
INT                  : 18
INT_CONST            : 51
LEQ                  : 91
LESSER               : 89
MINUS                : 79 79 80 80 82 94
NEW                  : 61 62
NOT                  : 95
NULL                 : 54
OR                   : 86
PLUS                 : 77 77 78 78 81 93
PRIVATE              : 11 12
PUBLIC               : 13 14
RETURN               : 40
STATIC               : 11 13 15
STRING_CONST         : 53
SUPER                : 59
THIS                 : 58
TIMES                : 83
TRUE                 : 55
VOID                 : 26
WHILE                : 38
error                : 
{                    : 4 5 33 34
}                    : 4 5 33 34

Nonterminals, with rules where they appear

arguments            : 61 66 69
arith_op             : 73
assign               : 72 96
block                : 25 26 27 44
bool_op              : 74
class_body_decl      : 4 5 6 6
class_decl           : 1 3 3
constructor_decl     : 9
empty                : 2 16 29 48 50
expr                 : 36 37 38 47 60 65 66 73 73 74 74 75 76
field_access         : 63 69 70 76 77 78 79 80
field_decl           : 7
formal_param         : 30 31
formals              : 28 30
literal              : 57
method_decl          : 8
method_invocation    : 64 97
modifier             : 10 25 26 27
optional_expr        : 39 40
optional_formals     : 25 26 27
optional_stmt_expr   : 39 39
primary              : 67 71
program              : 0
stmt                 : 33 35 35 36 36 37 38 39
stmt_expr            : 41 49
type                 : 17 25 32
unary_op             : 75
var_decl             : 10 45
variable             : 22 23 32
variables            : 17 23

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . class_decl
    (2) program -> . empty
    (3) class_decl -> . class_decl class_decl
    (4) class_decl -> . CLASS ID EXTENDS ID { class_body_decl }
    (5) class_decl -> . CLASS ID { class_body_decl }
    (98) empty -> .

    CLASS           shift and go to state 4
    $end            reduce using rule 98 (empty -> .)

    program                        shift and go to state 1
    class_decl                     shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> class_decl .
    (3) class_decl -> class_decl . class_decl
    (3) class_decl -> . class_decl class_decl
    (4) class_decl -> . CLASS ID EXTENDS ID { class_body_decl }
    (5) class_decl -> . CLASS ID { class_body_decl }

    $end            reduce using rule 1 (program -> class_decl .)
    CLASS           shift and go to state 4

    class_decl                     shift and go to state 5

state 3

    (2) program -> empty .

    $end            reduce using rule 2 (program -> empty .)


state 4

    (4) class_decl -> CLASS . ID EXTENDS ID { class_body_decl }
    (5) class_decl -> CLASS . ID { class_body_decl }

    ID              shift and go to state 6


state 5

    (3) class_decl -> class_decl class_decl .
    (3) class_decl -> class_decl . class_decl
    (3) class_decl -> . class_decl class_decl
    (4) class_decl -> . CLASS ID EXTENDS ID { class_body_decl }
    (5) class_decl -> . CLASS ID { class_body_decl }

  ! shift/reduce conflict for CLASS resolved as shift
    $end            reduce using rule 3 (class_decl -> class_decl class_decl .)
    CLASS           shift and go to state 4

  ! CLASS           [ reduce using rule 3 (class_decl -> class_decl class_decl .) ]

    class_decl                     shift and go to state 5

state 6

    (4) class_decl -> CLASS ID . EXTENDS ID { class_body_decl }
    (5) class_decl -> CLASS ID . { class_body_decl }

    EXTENDS         shift and go to state 7
    {               shift and go to state 8


state 7

    (4) class_decl -> CLASS ID EXTENDS . ID { class_body_decl }

    ID              shift and go to state 9


state 8

    (5) class_decl -> CLASS ID { . class_body_decl }
    (6) class_body_decl -> . class_body_decl class_body_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) field_decl -> . modifier var_decl
    (25) method_decl -> . modifier type ID ( optional_formals ) block
    (26) method_decl -> . modifier VOID ID ( optional_formals ) block
    (27) constructor_decl -> . modifier ID ( optional_formals ) block
    (11) modifier -> . PRIVATE STATIC
    (12) modifier -> . PRIVATE
    (13) modifier -> . PUBLIC STATIC
    (14) modifier -> . PUBLIC
    (15) modifier -> . STATIC
    (16) modifier -> . empty
    (98) empty -> .

    PRIVATE         shift and go to state 15
    PUBLIC          shift and go to state 17
    STATIC          shift and go to state 16
    VOID            reduce using rule 98 (empty -> .)
    ID              reduce using rule 98 (empty -> .)
    INT             reduce using rule 98 (empty -> .)
    FLOAT           reduce using rule 98 (empty -> .)
    BOOLEAN         reduce using rule 98 (empty -> .)

    class_body_decl                shift and go to state 10
    field_decl                     shift and go to state 11
    method_decl                    shift and go to state 12
    constructor_decl               shift and go to state 13
    modifier                       shift and go to state 14
    empty                          shift and go to state 18

state 9

    (4) class_decl -> CLASS ID EXTENDS ID . { class_body_decl }

    {               shift and go to state 19


state 10

    (5) class_decl -> CLASS ID { class_body_decl . }
    (6) class_body_decl -> class_body_decl . class_body_decl
    (6) class_body_decl -> . class_body_decl class_body_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) field_decl -> . modifier var_decl
    (25) method_decl -> . modifier type ID ( optional_formals ) block
    (26) method_decl -> . modifier VOID ID ( optional_formals ) block
    (27) constructor_decl -> . modifier ID ( optional_formals ) block
    (11) modifier -> . PRIVATE STATIC
    (12) modifier -> . PRIVATE
    (13) modifier -> . PUBLIC STATIC
    (14) modifier -> . PUBLIC
    (15) modifier -> . STATIC
    (16) modifier -> . empty
    (98) empty -> .

    }               shift and go to state 21
    PRIVATE         shift and go to state 15
    PUBLIC          shift and go to state 17
    STATIC          shift and go to state 16
    VOID            reduce using rule 98 (empty -> .)
    ID              reduce using rule 98 (empty -> .)
    INT             reduce using rule 98 (empty -> .)
    FLOAT           reduce using rule 98 (empty -> .)
    BOOLEAN         reduce using rule 98 (empty -> .)

    class_body_decl                shift and go to state 20
    field_decl                     shift and go to state 11
    method_decl                    shift and go to state 12
    constructor_decl               shift and go to state 13
    modifier                       shift and go to state 14
    empty                          shift and go to state 18

state 11

    (7) class_body_decl -> field_decl .

    }               reduce using rule 7 (class_body_decl -> field_decl .)
    PRIVATE         reduce using rule 7 (class_body_decl -> field_decl .)
    PUBLIC          reduce using rule 7 (class_body_decl -> field_decl .)
    STATIC          reduce using rule 7 (class_body_decl -> field_decl .)
    VOID            reduce using rule 7 (class_body_decl -> field_decl .)
    ID              reduce using rule 7 (class_body_decl -> field_decl .)
    INT             reduce using rule 7 (class_body_decl -> field_decl .)
    FLOAT           reduce using rule 7 (class_body_decl -> field_decl .)
    BOOLEAN         reduce using rule 7 (class_body_decl -> field_decl .)


state 12

    (8) class_body_decl -> method_decl .

    }               reduce using rule 8 (class_body_decl -> method_decl .)
    PRIVATE         reduce using rule 8 (class_body_decl -> method_decl .)
    PUBLIC          reduce using rule 8 (class_body_decl -> method_decl .)
    STATIC          reduce using rule 8 (class_body_decl -> method_decl .)
    VOID            reduce using rule 8 (class_body_decl -> method_decl .)
    ID              reduce using rule 8 (class_body_decl -> method_decl .)
    INT             reduce using rule 8 (class_body_decl -> method_decl .)
    FLOAT           reduce using rule 8 (class_body_decl -> method_decl .)
    BOOLEAN         reduce using rule 8 (class_body_decl -> method_decl .)


state 13

    (9) class_body_decl -> constructor_decl .

    }               reduce using rule 9 (class_body_decl -> constructor_decl .)
    PRIVATE         reduce using rule 9 (class_body_decl -> constructor_decl .)
    PUBLIC          reduce using rule 9 (class_body_decl -> constructor_decl .)
    STATIC          reduce using rule 9 (class_body_decl -> constructor_decl .)
    VOID            reduce using rule 9 (class_body_decl -> constructor_decl .)
    ID              reduce using rule 9 (class_body_decl -> constructor_decl .)
    INT             reduce using rule 9 (class_body_decl -> constructor_decl .)
    FLOAT           reduce using rule 9 (class_body_decl -> constructor_decl .)
    BOOLEAN         reduce using rule 9 (class_body_decl -> constructor_decl .)


state 14

    (10) field_decl -> modifier . var_decl
    (25) method_decl -> modifier . type ID ( optional_formals ) block
    (26) method_decl -> modifier . VOID ID ( optional_formals ) block
    (27) constructor_decl -> modifier . ID ( optional_formals ) block
    (17) var_decl -> . type variables ;
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    VOID            shift and go to state 25
    ID              shift and go to state 24
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28

    var_decl                       shift and go to state 22
    type                           shift and go to state 23

state 15

    (11) modifier -> PRIVATE . STATIC
    (12) modifier -> PRIVATE .

    STATIC          shift and go to state 29
    VOID            reduce using rule 12 (modifier -> PRIVATE .)
    ID              reduce using rule 12 (modifier -> PRIVATE .)
    INT             reduce using rule 12 (modifier -> PRIVATE .)
    FLOAT           reduce using rule 12 (modifier -> PRIVATE .)
    BOOLEAN         reduce using rule 12 (modifier -> PRIVATE .)


state 16

    (15) modifier -> STATIC .

    VOID            reduce using rule 15 (modifier -> STATIC .)
    ID              reduce using rule 15 (modifier -> STATIC .)
    INT             reduce using rule 15 (modifier -> STATIC .)
    FLOAT           reduce using rule 15 (modifier -> STATIC .)
    BOOLEAN         reduce using rule 15 (modifier -> STATIC .)


state 17

    (13) modifier -> PUBLIC . STATIC
    (14) modifier -> PUBLIC .

    STATIC          shift and go to state 30
    VOID            reduce using rule 14 (modifier -> PUBLIC .)
    ID              reduce using rule 14 (modifier -> PUBLIC .)
    INT             reduce using rule 14 (modifier -> PUBLIC .)
    FLOAT           reduce using rule 14 (modifier -> PUBLIC .)
    BOOLEAN         reduce using rule 14 (modifier -> PUBLIC .)


state 18

    (16) modifier -> empty .

    VOID            reduce using rule 16 (modifier -> empty .)
    ID              reduce using rule 16 (modifier -> empty .)
    INT             reduce using rule 16 (modifier -> empty .)
    FLOAT           reduce using rule 16 (modifier -> empty .)
    BOOLEAN         reduce using rule 16 (modifier -> empty .)


state 19

    (4) class_decl -> CLASS ID EXTENDS ID { . class_body_decl }
    (6) class_body_decl -> . class_body_decl class_body_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) field_decl -> . modifier var_decl
    (25) method_decl -> . modifier type ID ( optional_formals ) block
    (26) method_decl -> . modifier VOID ID ( optional_formals ) block
    (27) constructor_decl -> . modifier ID ( optional_formals ) block
    (11) modifier -> . PRIVATE STATIC
    (12) modifier -> . PRIVATE
    (13) modifier -> . PUBLIC STATIC
    (14) modifier -> . PUBLIC
    (15) modifier -> . STATIC
    (16) modifier -> . empty
    (98) empty -> .

    PRIVATE         shift and go to state 15
    PUBLIC          shift and go to state 17
    STATIC          shift and go to state 16
    VOID            reduce using rule 98 (empty -> .)
    ID              reduce using rule 98 (empty -> .)
    INT             reduce using rule 98 (empty -> .)
    FLOAT           reduce using rule 98 (empty -> .)
    BOOLEAN         reduce using rule 98 (empty -> .)

    class_body_decl                shift and go to state 31
    field_decl                     shift and go to state 11
    method_decl                    shift and go to state 12
    constructor_decl               shift and go to state 13
    modifier                       shift and go to state 14
    empty                          shift and go to state 18

state 20

    (6) class_body_decl -> class_body_decl class_body_decl .
    (6) class_body_decl -> class_body_decl . class_body_decl
    (6) class_body_decl -> . class_body_decl class_body_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) field_decl -> . modifier var_decl
    (25) method_decl -> . modifier type ID ( optional_formals ) block
    (26) method_decl -> . modifier VOID ID ( optional_formals ) block
    (27) constructor_decl -> . modifier ID ( optional_formals ) block
    (11) modifier -> . PRIVATE STATIC
    (12) modifier -> . PRIVATE
    (13) modifier -> . PUBLIC STATIC
    (14) modifier -> . PUBLIC
    (15) modifier -> . STATIC
    (16) modifier -> . empty
    (98) empty -> .

  ! shift/reduce conflict for PRIVATE resolved as shift
  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! reduce/reduce conflict for VOID resolved using rule 6 (class_body_decl -> class_body_decl class_body_decl .)
  ! reduce/reduce conflict for ID resolved using rule 6 (class_body_decl -> class_body_decl class_body_decl .)
  ! reduce/reduce conflict for INT resolved using rule 6 (class_body_decl -> class_body_decl class_body_decl .)
  ! reduce/reduce conflict for FLOAT resolved using rule 6 (class_body_decl -> class_body_decl class_body_decl .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 6 (class_body_decl -> class_body_decl class_body_decl .)
    }               reduce using rule 6 (class_body_decl -> class_body_decl class_body_decl .)
    VOID            reduce using rule 6 (class_body_decl -> class_body_decl class_body_decl .)
    ID              reduce using rule 6 (class_body_decl -> class_body_decl class_body_decl .)
    INT             reduce using rule 6 (class_body_decl -> class_body_decl class_body_decl .)
    FLOAT           reduce using rule 6 (class_body_decl -> class_body_decl class_body_decl .)
    BOOLEAN         reduce using rule 6 (class_body_decl -> class_body_decl class_body_decl .)
    PRIVATE         shift and go to state 15
    PUBLIC          shift and go to state 17
    STATIC          shift and go to state 16

  ! PRIVATE         [ reduce using rule 6 (class_body_decl -> class_body_decl class_body_decl .) ]
  ! PUBLIC          [ reduce using rule 6 (class_body_decl -> class_body_decl class_body_decl .) ]
  ! STATIC          [ reduce using rule 6 (class_body_decl -> class_body_decl class_body_decl .) ]
  ! VOID            [ reduce using rule 98 (empty -> .) ]
  ! ID              [ reduce using rule 98 (empty -> .) ]
  ! INT             [ reduce using rule 98 (empty -> .) ]
  ! FLOAT           [ reduce using rule 98 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 98 (empty -> .) ]

    class_body_decl                shift and go to state 20
    field_decl                     shift and go to state 11
    method_decl                    shift and go to state 12
    constructor_decl               shift and go to state 13
    modifier                       shift and go to state 14
    empty                          shift and go to state 18

state 21

    (5) class_decl -> CLASS ID { class_body_decl } .

    CLASS           reduce using rule 5 (class_decl -> CLASS ID { class_body_decl } .)
    $end            reduce using rule 5 (class_decl -> CLASS ID { class_body_decl } .)


state 22

    (10) field_decl -> modifier var_decl .

    }               reduce using rule 10 (field_decl -> modifier var_decl .)
    PRIVATE         reduce using rule 10 (field_decl -> modifier var_decl .)
    PUBLIC          reduce using rule 10 (field_decl -> modifier var_decl .)
    STATIC          reduce using rule 10 (field_decl -> modifier var_decl .)
    VOID            reduce using rule 10 (field_decl -> modifier var_decl .)
    ID              reduce using rule 10 (field_decl -> modifier var_decl .)
    INT             reduce using rule 10 (field_decl -> modifier var_decl .)
    FLOAT           reduce using rule 10 (field_decl -> modifier var_decl .)
    BOOLEAN         reduce using rule 10 (field_decl -> modifier var_decl .)


state 23

    (25) method_decl -> modifier type . ID ( optional_formals ) block
    (17) var_decl -> type . variables ;
    (22) variables -> . variable
    (23) variables -> . variable , variables
    (24) variable -> . ID

    ID              shift and go to state 32

    variables                      shift and go to state 33
    variable                       shift and go to state 34

state 24

    (27) constructor_decl -> modifier ID . ( optional_formals ) block
    (21) type -> ID .

    (               shift and go to state 35
    ID              reduce using rule 21 (type -> ID .)


state 25

    (26) method_decl -> modifier VOID . ID ( optional_formals ) block

    ID              shift and go to state 36


state 26

    (18) type -> INT .

    ID              reduce using rule 18 (type -> INT .)


state 27

    (19) type -> FLOAT .

    ID              reduce using rule 19 (type -> FLOAT .)


state 28

    (20) type -> BOOLEAN .

    ID              reduce using rule 20 (type -> BOOLEAN .)


state 29

    (11) modifier -> PRIVATE STATIC .

    VOID            reduce using rule 11 (modifier -> PRIVATE STATIC .)
    ID              reduce using rule 11 (modifier -> PRIVATE STATIC .)
    INT             reduce using rule 11 (modifier -> PRIVATE STATIC .)
    FLOAT           reduce using rule 11 (modifier -> PRIVATE STATIC .)
    BOOLEAN         reduce using rule 11 (modifier -> PRIVATE STATIC .)


state 30

    (13) modifier -> PUBLIC STATIC .

    VOID            reduce using rule 13 (modifier -> PUBLIC STATIC .)
    ID              reduce using rule 13 (modifier -> PUBLIC STATIC .)
    INT             reduce using rule 13 (modifier -> PUBLIC STATIC .)
    FLOAT           reduce using rule 13 (modifier -> PUBLIC STATIC .)
    BOOLEAN         reduce using rule 13 (modifier -> PUBLIC STATIC .)


state 31

    (4) class_decl -> CLASS ID EXTENDS ID { class_body_decl . }
    (6) class_body_decl -> class_body_decl . class_body_decl
    (6) class_body_decl -> . class_body_decl class_body_decl
    (7) class_body_decl -> . field_decl
    (8) class_body_decl -> . method_decl
    (9) class_body_decl -> . constructor_decl
    (10) field_decl -> . modifier var_decl
    (25) method_decl -> . modifier type ID ( optional_formals ) block
    (26) method_decl -> . modifier VOID ID ( optional_formals ) block
    (27) constructor_decl -> . modifier ID ( optional_formals ) block
    (11) modifier -> . PRIVATE STATIC
    (12) modifier -> . PRIVATE
    (13) modifier -> . PUBLIC STATIC
    (14) modifier -> . PUBLIC
    (15) modifier -> . STATIC
    (16) modifier -> . empty
    (98) empty -> .

    }               shift and go to state 37
    PRIVATE         shift and go to state 15
    PUBLIC          shift and go to state 17
    STATIC          shift and go to state 16
    VOID            reduce using rule 98 (empty -> .)
    ID              reduce using rule 98 (empty -> .)
    INT             reduce using rule 98 (empty -> .)
    FLOAT           reduce using rule 98 (empty -> .)
    BOOLEAN         reduce using rule 98 (empty -> .)

    class_body_decl                shift and go to state 20
    field_decl                     shift and go to state 11
    method_decl                    shift and go to state 12
    constructor_decl               shift and go to state 13
    modifier                       shift and go to state 14
    empty                          shift and go to state 18

state 32

    (25) method_decl -> modifier type ID . ( optional_formals ) block
    (24) variable -> ID .

    (               shift and go to state 38
    ,               reduce using rule 24 (variable -> ID .)
    ;               reduce using rule 24 (variable -> ID .)


state 33

    (17) var_decl -> type variables . ;

    ;               shift and go to state 39


state 34

    (22) variables -> variable .
    (23) variables -> variable . , variables

    ;               reduce using rule 22 (variables -> variable .)
    ,               shift and go to state 40


state 35

    (27) constructor_decl -> modifier ID ( . optional_formals ) block
    (28) optional_formals -> . formals
    (29) optional_formals -> . empty
    (30) formals -> . formal_param , formals
    (31) formals -> . formal_param
    (98) empty -> .
    (32) formal_param -> . type variable
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    )               reduce using rule 98 (empty -> .)
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 41

    optional_formals               shift and go to state 42
    formals                        shift and go to state 43
    empty                          shift and go to state 44
    formal_param                   shift and go to state 45
    type                           shift and go to state 46

state 36

    (26) method_decl -> modifier VOID ID . ( optional_formals ) block

    (               shift and go to state 47


state 37

    (4) class_decl -> CLASS ID EXTENDS ID { class_body_decl } .

    CLASS           reduce using rule 4 (class_decl -> CLASS ID EXTENDS ID { class_body_decl } .)
    $end            reduce using rule 4 (class_decl -> CLASS ID EXTENDS ID { class_body_decl } .)


state 38

    (25) method_decl -> modifier type ID ( . optional_formals ) block
    (28) optional_formals -> . formals
    (29) optional_formals -> . empty
    (30) formals -> . formal_param , formals
    (31) formals -> . formal_param
    (98) empty -> .
    (32) formal_param -> . type variable
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    )               reduce using rule 98 (empty -> .)
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 41

    type                           shift and go to state 46
    optional_formals               shift and go to state 48
    formals                        shift and go to state 43
    empty                          shift and go to state 44
    formal_param                   shift and go to state 45

state 39

    (17) var_decl -> type variables ; .

    }               reduce using rule 17 (var_decl -> type variables ; .)
    PRIVATE         reduce using rule 17 (var_decl -> type variables ; .)
    PUBLIC          reduce using rule 17 (var_decl -> type variables ; .)
    STATIC          reduce using rule 17 (var_decl -> type variables ; .)
    VOID            reduce using rule 17 (var_decl -> type variables ; .)
    ID              reduce using rule 17 (var_decl -> type variables ; .)
    INT             reduce using rule 17 (var_decl -> type variables ; .)
    FLOAT           reduce using rule 17 (var_decl -> type variables ; .)
    BOOLEAN         reduce using rule 17 (var_decl -> type variables ; .)
    IF              reduce using rule 17 (var_decl -> type variables ; .)
    WHILE           reduce using rule 17 (var_decl -> type variables ; .)
    FOR             reduce using rule 17 (var_decl -> type variables ; .)
    RETURN          reduce using rule 17 (var_decl -> type variables ; .)
    BREAK           reduce using rule 17 (var_decl -> type variables ; .)
    CONTINUE        reduce using rule 17 (var_decl -> type variables ; .)
    ;               reduce using rule 17 (var_decl -> type variables ; .)
    {               reduce using rule 17 (var_decl -> type variables ; .)
    PLUS            reduce using rule 17 (var_decl -> type variables ; .)
    MINUS           reduce using rule 17 (var_decl -> type variables ; .)
    THIS            reduce using rule 17 (var_decl -> type variables ; .)
    SUPER           reduce using rule 17 (var_decl -> type variables ; .)
    (               reduce using rule 17 (var_decl -> type variables ; .)
    NEW             reduce using rule 17 (var_decl -> type variables ; .)
    INT_CONST       reduce using rule 17 (var_decl -> type variables ; .)
    FLOAT_CONST     reduce using rule 17 (var_decl -> type variables ; .)
    STRING_CONST    reduce using rule 17 (var_decl -> type variables ; .)
    NULL            reduce using rule 17 (var_decl -> type variables ; .)
    TRUE            reduce using rule 17 (var_decl -> type variables ; .)
    FALSE           reduce using rule 17 (var_decl -> type variables ; .)
    ELSE            reduce using rule 17 (var_decl -> type variables ; .)


state 40

    (23) variables -> variable , . variables
    (22) variables -> . variable
    (23) variables -> . variable , variables
    (24) variable -> . ID

    ID              shift and go to state 50

    variable                       shift and go to state 34
    variables                      shift and go to state 49

state 41

    (21) type -> ID .

    ID              reduce using rule 21 (type -> ID .)


state 42

    (27) constructor_decl -> modifier ID ( optional_formals . ) block

    )               shift and go to state 51


state 43

    (28) optional_formals -> formals .

    )               reduce using rule 28 (optional_formals -> formals .)


state 44

    (29) optional_formals -> empty .

    )               reduce using rule 29 (optional_formals -> empty .)


state 45

    (30) formals -> formal_param . , formals
    (31) formals -> formal_param .

    ,               shift and go to state 52
    )               reduce using rule 31 (formals -> formal_param .)


state 46

    (32) formal_param -> type . variable
    (24) variable -> . ID

    ID              shift and go to state 50

    variable                       shift and go to state 53

state 47

    (26) method_decl -> modifier VOID ID ( . optional_formals ) block
    (28) optional_formals -> . formals
    (29) optional_formals -> . empty
    (30) formals -> . formal_param , formals
    (31) formals -> . formal_param
    (98) empty -> .
    (32) formal_param -> . type variable
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    )               reduce using rule 98 (empty -> .)
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 41

    optional_formals               shift and go to state 54
    formals                        shift and go to state 43
    empty                          shift and go to state 44
    formal_param                   shift and go to state 45
    type                           shift and go to state 46

state 48

    (25) method_decl -> modifier type ID ( optional_formals . ) block

    )               shift and go to state 55


state 49

    (23) variables -> variable , variables .

    ;               reduce using rule 23 (variables -> variable , variables .)


state 50

    (24) variable -> ID .

    ,               reduce using rule 24 (variable -> ID .)
    ;               reduce using rule 24 (variable -> ID .)
    )               reduce using rule 24 (variable -> ID .)


state 51

    (27) constructor_decl -> modifier ID ( optional_formals ) . block
    (33) block -> . { stmt }
    (34) block -> . { }

    {               shift and go to state 57

    block                          shift and go to state 56

state 52

    (30) formals -> formal_param , . formals
    (30) formals -> . formal_param , formals
    (31) formals -> . formal_param
    (32) formal_param -> . type variable
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 41

    formal_param                   shift and go to state 45
    formals                        shift and go to state 58
    type                           shift and go to state 46

state 53

    (32) formal_param -> type variable .

    ,               reduce using rule 32 (formal_param -> type variable .)
    )               reduce using rule 32 (formal_param -> type variable .)


state 54

    (26) method_decl -> modifier VOID ID ( optional_formals . ) block

    )               shift and go to state 59


state 55

    (25) method_decl -> modifier type ID ( optional_formals ) . block
    (33) block -> . { stmt }
    (34) block -> . { }

    {               shift and go to state 57

    block                          shift and go to state 60

state 56

    (27) constructor_decl -> modifier ID ( optional_formals ) block .

    }               reduce using rule 27 (constructor_decl -> modifier ID ( optional_formals ) block .)
    PRIVATE         reduce using rule 27 (constructor_decl -> modifier ID ( optional_formals ) block .)
    PUBLIC          reduce using rule 27 (constructor_decl -> modifier ID ( optional_formals ) block .)
    STATIC          reduce using rule 27 (constructor_decl -> modifier ID ( optional_formals ) block .)
    VOID            reduce using rule 27 (constructor_decl -> modifier ID ( optional_formals ) block .)
    ID              reduce using rule 27 (constructor_decl -> modifier ID ( optional_formals ) block .)
    INT             reduce using rule 27 (constructor_decl -> modifier ID ( optional_formals ) block .)
    FLOAT           reduce using rule 27 (constructor_decl -> modifier ID ( optional_formals ) block .)
    BOOLEAN         reduce using rule 27 (constructor_decl -> modifier ID ( optional_formals ) block .)


state 57

    (33) block -> { . stmt }
    (34) block -> { . }
    (35) stmt -> . stmt stmt
    (36) stmt -> . IF ( expr ) stmt ELSE stmt
    (37) stmt -> . IF ( expr ) stmt
    (38) stmt -> . WHILE ( expr ) stmt
    (39) stmt -> . FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (40) stmt -> . RETURN optional_expr ;
    (41) stmt -> . stmt_expr ;
    (42) stmt -> . BREAK ;
    (43) stmt -> . CONTINUE ;
    (44) stmt -> . block
    (45) stmt -> . var_decl
    (46) stmt -> . ;
    (96) stmt_expr -> . assign
    (97) stmt_expr -> . method_invocation
    (33) block -> . { stmt }
    (34) block -> . { }
    (17) var_decl -> . type variables ;
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE

    }               shift and go to state 62
    IF              shift and go to state 63
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    RETURN          shift and go to state 68
    BREAK           shift and go to state 70
    CONTINUE        shift and go to state 71
    ;               shift and go to state 67
    {               shift and go to state 57
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 80
    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91

    stmt                           shift and go to state 61
    stmt_expr                      shift and go to state 69
    block                          shift and go to state 72
    var_decl                       shift and go to state 73
    assign                         shift and go to state 74
    method_invocation              shift and go to state 75
    type                           shift and go to state 76
    field_access                   shift and go to state 77
    primary                        shift and go to state 81
    literal                        shift and go to state 82

state 58

    (30) formals -> formal_param , formals .

    )               reduce using rule 30 (formals -> formal_param , formals .)


state 59

    (26) method_decl -> modifier VOID ID ( optional_formals ) . block
    (33) block -> . { stmt }
    (34) block -> . { }

    {               shift and go to state 57

    block                          shift and go to state 92

state 60

    (25) method_decl -> modifier type ID ( optional_formals ) block .

    }               reduce using rule 25 (method_decl -> modifier type ID ( optional_formals ) block .)
    PRIVATE         reduce using rule 25 (method_decl -> modifier type ID ( optional_formals ) block .)
    PUBLIC          reduce using rule 25 (method_decl -> modifier type ID ( optional_formals ) block .)
    STATIC          reduce using rule 25 (method_decl -> modifier type ID ( optional_formals ) block .)
    VOID            reduce using rule 25 (method_decl -> modifier type ID ( optional_formals ) block .)
    ID              reduce using rule 25 (method_decl -> modifier type ID ( optional_formals ) block .)
    INT             reduce using rule 25 (method_decl -> modifier type ID ( optional_formals ) block .)
    FLOAT           reduce using rule 25 (method_decl -> modifier type ID ( optional_formals ) block .)
    BOOLEAN         reduce using rule 25 (method_decl -> modifier type ID ( optional_formals ) block .)


state 61

    (33) block -> { stmt . }
    (35) stmt -> stmt . stmt
    (35) stmt -> . stmt stmt
    (36) stmt -> . IF ( expr ) stmt ELSE stmt
    (37) stmt -> . IF ( expr ) stmt
    (38) stmt -> . WHILE ( expr ) stmt
    (39) stmt -> . FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (40) stmt -> . RETURN optional_expr ;
    (41) stmt -> . stmt_expr ;
    (42) stmt -> . BREAK ;
    (43) stmt -> . CONTINUE ;
    (44) stmt -> . block
    (45) stmt -> . var_decl
    (46) stmt -> . ;
    (96) stmt_expr -> . assign
    (97) stmt_expr -> . method_invocation
    (33) block -> . { stmt }
    (34) block -> . { }
    (17) var_decl -> . type variables ;
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE

    }               shift and go to state 94
    IF              shift and go to state 63
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    RETURN          shift and go to state 68
    BREAK           shift and go to state 70
    CONTINUE        shift and go to state 71
    ;               shift and go to state 67
    {               shift and go to state 57
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 80
    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91

    stmt                           shift and go to state 93
    stmt_expr                      shift and go to state 69
    block                          shift and go to state 72
    var_decl                       shift and go to state 73
    assign                         shift and go to state 74
    method_invocation              shift and go to state 75
    type                           shift and go to state 76
    field_access                   shift and go to state 77
    primary                        shift and go to state 81
    literal                        shift and go to state 82

state 62

    (34) block -> { } .

    }               reduce using rule 34 (block -> { } .)
    PRIVATE         reduce using rule 34 (block -> { } .)
    PUBLIC          reduce using rule 34 (block -> { } .)
    STATIC          reduce using rule 34 (block -> { } .)
    VOID            reduce using rule 34 (block -> { } .)
    ID              reduce using rule 34 (block -> { } .)
    INT             reduce using rule 34 (block -> { } .)
    FLOAT           reduce using rule 34 (block -> { } .)
    BOOLEAN         reduce using rule 34 (block -> { } .)
    IF              reduce using rule 34 (block -> { } .)
    WHILE           reduce using rule 34 (block -> { } .)
    FOR             reduce using rule 34 (block -> { } .)
    RETURN          reduce using rule 34 (block -> { } .)
    BREAK           reduce using rule 34 (block -> { } .)
    CONTINUE        reduce using rule 34 (block -> { } .)
    ;               reduce using rule 34 (block -> { } .)
    {               reduce using rule 34 (block -> { } .)
    PLUS            reduce using rule 34 (block -> { } .)
    MINUS           reduce using rule 34 (block -> { } .)
    THIS            reduce using rule 34 (block -> { } .)
    SUPER           reduce using rule 34 (block -> { } .)
    (               reduce using rule 34 (block -> { } .)
    NEW             reduce using rule 34 (block -> { } .)
    INT_CONST       reduce using rule 34 (block -> { } .)
    FLOAT_CONST     reduce using rule 34 (block -> { } .)
    STRING_CONST    reduce using rule 34 (block -> { } .)
    NULL            reduce using rule 34 (block -> { } .)
    TRUE            reduce using rule 34 (block -> { } .)
    FALSE           reduce using rule 34 (block -> { } .)
    ELSE            reduce using rule 34 (block -> { } .)


state 63

    (36) stmt -> IF . ( expr ) stmt ELSE stmt
    (37) stmt -> IF . ( expr ) stmt

    (               shift and go to state 95


state 64

    (60) primary -> ( . expr )
    (71) expr -> . primary
    (72) expr -> . assign
    (73) expr -> . expr arith_op expr
    (74) expr -> . expr bool_op expr
    (75) expr -> . unary_op expr
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (93) unary_op -> . PLUS
    (94) unary_op -> . MINUS
    (95) unary_op -> . NOT
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )

    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    PLUS            shift and go to state 103
    MINUS           shift and go to state 104
    NOT             shift and go to state 105
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91
    ID              shift and go to state 100

    expr                           shift and go to state 96
    primary                        shift and go to state 97
    assign                         shift and go to state 98
    unary_op                       shift and go to state 99
    literal                        shift and go to state 82
    field_access                   shift and go to state 101
    method_invocation              shift and go to state 102

state 65

    (38) stmt -> WHILE . ( expr ) stmt

    (               shift and go to state 106


state 66

    (39) stmt -> FOR . ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt

    (               shift and go to state 107


state 67

    (46) stmt -> ; .

    }               reduce using rule 46 (stmt -> ; .)
    IF              reduce using rule 46 (stmt -> ; .)
    WHILE           reduce using rule 46 (stmt -> ; .)
    FOR             reduce using rule 46 (stmt -> ; .)
    RETURN          reduce using rule 46 (stmt -> ; .)
    BREAK           reduce using rule 46 (stmt -> ; .)
    CONTINUE        reduce using rule 46 (stmt -> ; .)
    ;               reduce using rule 46 (stmt -> ; .)
    {               reduce using rule 46 (stmt -> ; .)
    PLUS            reduce using rule 46 (stmt -> ; .)
    MINUS           reduce using rule 46 (stmt -> ; .)
    INT             reduce using rule 46 (stmt -> ; .)
    FLOAT           reduce using rule 46 (stmt -> ; .)
    BOOLEAN         reduce using rule 46 (stmt -> ; .)
    ID              reduce using rule 46 (stmt -> ; .)
    THIS            reduce using rule 46 (stmt -> ; .)
    SUPER           reduce using rule 46 (stmt -> ; .)
    (               reduce using rule 46 (stmt -> ; .)
    NEW             reduce using rule 46 (stmt -> ; .)
    INT_CONST       reduce using rule 46 (stmt -> ; .)
    FLOAT_CONST     reduce using rule 46 (stmt -> ; .)
    STRING_CONST    reduce using rule 46 (stmt -> ; .)
    NULL            reduce using rule 46 (stmt -> ; .)
    TRUE            reduce using rule 46 (stmt -> ; .)
    FALSE           reduce using rule 46 (stmt -> ; .)
    ELSE            reduce using rule 46 (stmt -> ; .)


state 68

    (40) stmt -> RETURN . optional_expr ;
    (47) optional_expr -> . expr
    (48) optional_expr -> . empty
    (71) expr -> . primary
    (72) expr -> . assign
    (73) expr -> . expr arith_op expr
    (74) expr -> . expr bool_op expr
    (75) expr -> . unary_op expr
    (98) empty -> .
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (93) unary_op -> . PLUS
    (94) unary_op -> . MINUS
    (95) unary_op -> . NOT
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )

    ;               reduce using rule 98 (empty -> .)
    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    PLUS            shift and go to state 103
    MINUS           shift and go to state 104
    NOT             shift and go to state 105
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91
    ID              shift and go to state 100

    optional_expr                  shift and go to state 108
    expr                           shift and go to state 109
    empty                          shift and go to state 110
    primary                        shift and go to state 97
    assign                         shift and go to state 98
    unary_op                       shift and go to state 99
    literal                        shift and go to state 82
    field_access                   shift and go to state 101
    method_invocation              shift and go to state 102

state 69

    (41) stmt -> stmt_expr . ;

    ;               shift and go to state 111


state 70

    (42) stmt -> BREAK . ;

    ;               shift and go to state 112


state 71

    (43) stmt -> CONTINUE . ;

    ;               shift and go to state 113


state 72

    (44) stmt -> block .

    }               reduce using rule 44 (stmt -> block .)
    IF              reduce using rule 44 (stmt -> block .)
    WHILE           reduce using rule 44 (stmt -> block .)
    FOR             reduce using rule 44 (stmt -> block .)
    RETURN          reduce using rule 44 (stmt -> block .)
    BREAK           reduce using rule 44 (stmt -> block .)
    CONTINUE        reduce using rule 44 (stmt -> block .)
    ;               reduce using rule 44 (stmt -> block .)
    {               reduce using rule 44 (stmt -> block .)
    PLUS            reduce using rule 44 (stmt -> block .)
    MINUS           reduce using rule 44 (stmt -> block .)
    INT             reduce using rule 44 (stmt -> block .)
    FLOAT           reduce using rule 44 (stmt -> block .)
    BOOLEAN         reduce using rule 44 (stmt -> block .)
    ID              reduce using rule 44 (stmt -> block .)
    THIS            reduce using rule 44 (stmt -> block .)
    SUPER           reduce using rule 44 (stmt -> block .)
    (               reduce using rule 44 (stmt -> block .)
    NEW             reduce using rule 44 (stmt -> block .)
    INT_CONST       reduce using rule 44 (stmt -> block .)
    FLOAT_CONST     reduce using rule 44 (stmt -> block .)
    STRING_CONST    reduce using rule 44 (stmt -> block .)
    NULL            reduce using rule 44 (stmt -> block .)
    TRUE            reduce using rule 44 (stmt -> block .)
    FALSE           reduce using rule 44 (stmt -> block .)
    ELSE            reduce using rule 44 (stmt -> block .)


state 73

    (45) stmt -> var_decl .

    }               reduce using rule 45 (stmt -> var_decl .)
    IF              reduce using rule 45 (stmt -> var_decl .)
    WHILE           reduce using rule 45 (stmt -> var_decl .)
    FOR             reduce using rule 45 (stmt -> var_decl .)
    RETURN          reduce using rule 45 (stmt -> var_decl .)
    BREAK           reduce using rule 45 (stmt -> var_decl .)
    CONTINUE        reduce using rule 45 (stmt -> var_decl .)
    ;               reduce using rule 45 (stmt -> var_decl .)
    {               reduce using rule 45 (stmt -> var_decl .)
    PLUS            reduce using rule 45 (stmt -> var_decl .)
    MINUS           reduce using rule 45 (stmt -> var_decl .)
    INT             reduce using rule 45 (stmt -> var_decl .)
    FLOAT           reduce using rule 45 (stmt -> var_decl .)
    BOOLEAN         reduce using rule 45 (stmt -> var_decl .)
    ID              reduce using rule 45 (stmt -> var_decl .)
    THIS            reduce using rule 45 (stmt -> var_decl .)
    SUPER           reduce using rule 45 (stmt -> var_decl .)
    (               reduce using rule 45 (stmt -> var_decl .)
    NEW             reduce using rule 45 (stmt -> var_decl .)
    INT_CONST       reduce using rule 45 (stmt -> var_decl .)
    FLOAT_CONST     reduce using rule 45 (stmt -> var_decl .)
    STRING_CONST    reduce using rule 45 (stmt -> var_decl .)
    NULL            reduce using rule 45 (stmt -> var_decl .)
    TRUE            reduce using rule 45 (stmt -> var_decl .)
    FALSE           reduce using rule 45 (stmt -> var_decl .)
    ELSE            reduce using rule 45 (stmt -> var_decl .)


state 74

    (96) stmt_expr -> assign .

    ;               reduce using rule 96 (stmt_expr -> assign .)
    )               reduce using rule 96 (stmt_expr -> assign .)


state 75

    (97) stmt_expr -> method_invocation .
    (64) primary -> method_invocation .

    ;               reduce using rule 97 (stmt_expr -> method_invocation .)
    )               reduce using rule 97 (stmt_expr -> method_invocation .)
    .               reduce using rule 64 (primary -> method_invocation .)


state 76

    (17) var_decl -> type . variables ;
    (22) variables -> . variable
    (23) variables -> . variable , variables
    (24) variable -> . ID

    ID              shift and go to state 50

    variables                      shift and go to state 33
    variable                       shift and go to state 34

state 77

    (76) assign -> field_access . ASSIGN expr
    (77) assign -> field_access . PLUS PLUS
    (79) assign -> field_access . MINUS MINUS
    (69) method_invocation -> field_access . ( arguments )
    (70) method_invocation -> field_access . ( )
    (63) primary -> field_access .

    ASSIGN          shift and go to state 114
    PLUS            shift and go to state 115
    MINUS           shift and go to state 116
    (               shift and go to state 117
    .               reduce using rule 63 (primary -> field_access .)


state 78

    (78) assign -> PLUS . PLUS field_access

    PLUS            shift and go to state 118


state 79

    (80) assign -> MINUS . MINUS field_access

    MINUS           shift and go to state 119


state 80

    (21) type -> ID .
    (68) field_access -> ID .

    ID              reduce using rule 21 (type -> ID .)
    ASSIGN          reduce using rule 68 (field_access -> ID .)
    PLUS            reduce using rule 68 (field_access -> ID .)
    MINUS           reduce using rule 68 (field_access -> ID .)
    (               reduce using rule 68 (field_access -> ID .)
    .               reduce using rule 68 (field_access -> ID .)


state 81

    (67) field_access -> primary . . ID

    .               shift and go to state 120


state 82

    (57) primary -> literal .

    .               reduce using rule 57 (primary -> literal .)
    )               reduce using rule 57 (primary -> literal .)
    PLUS            reduce using rule 57 (primary -> literal .)
    MINUS           reduce using rule 57 (primary -> literal .)
    TIMES           reduce using rule 57 (primary -> literal .)
    DIVIDE          reduce using rule 57 (primary -> literal .)
    AND             reduce using rule 57 (primary -> literal .)
    OR              reduce using rule 57 (primary -> literal .)
    EQUALITY        reduce using rule 57 (primary -> literal .)
    INEQUALITY      reduce using rule 57 (primary -> literal .)
    LESSER          reduce using rule 57 (primary -> literal .)
    GREATER         reduce using rule 57 (primary -> literal .)
    LEQ             reduce using rule 57 (primary -> literal .)
    GEQ             reduce using rule 57 (primary -> literal .)
    ;               reduce using rule 57 (primary -> literal .)
    ,               reduce using rule 57 (primary -> literal .)


state 83

    (58) primary -> THIS .

    .               reduce using rule 58 (primary -> THIS .)
    )               reduce using rule 58 (primary -> THIS .)
    PLUS            reduce using rule 58 (primary -> THIS .)
    MINUS           reduce using rule 58 (primary -> THIS .)
    TIMES           reduce using rule 58 (primary -> THIS .)
    DIVIDE          reduce using rule 58 (primary -> THIS .)
    AND             reduce using rule 58 (primary -> THIS .)
    OR              reduce using rule 58 (primary -> THIS .)
    EQUALITY        reduce using rule 58 (primary -> THIS .)
    INEQUALITY      reduce using rule 58 (primary -> THIS .)
    LESSER          reduce using rule 58 (primary -> THIS .)
    GREATER         reduce using rule 58 (primary -> THIS .)
    LEQ             reduce using rule 58 (primary -> THIS .)
    GEQ             reduce using rule 58 (primary -> THIS .)
    ;               reduce using rule 58 (primary -> THIS .)
    ,               reduce using rule 58 (primary -> THIS .)


state 84

    (59) primary -> SUPER .

    .               reduce using rule 59 (primary -> SUPER .)
    )               reduce using rule 59 (primary -> SUPER .)
    PLUS            reduce using rule 59 (primary -> SUPER .)
    MINUS           reduce using rule 59 (primary -> SUPER .)
    TIMES           reduce using rule 59 (primary -> SUPER .)
    DIVIDE          reduce using rule 59 (primary -> SUPER .)
    AND             reduce using rule 59 (primary -> SUPER .)
    OR              reduce using rule 59 (primary -> SUPER .)
    EQUALITY        reduce using rule 59 (primary -> SUPER .)
    INEQUALITY      reduce using rule 59 (primary -> SUPER .)
    LESSER          reduce using rule 59 (primary -> SUPER .)
    GREATER         reduce using rule 59 (primary -> SUPER .)
    LEQ             reduce using rule 59 (primary -> SUPER .)
    GEQ             reduce using rule 59 (primary -> SUPER .)
    ;               reduce using rule 59 (primary -> SUPER .)
    ,               reduce using rule 59 (primary -> SUPER .)


state 85

    (61) primary -> NEW . ID ( arguments )
    (62) primary -> NEW . ID ( )

    ID              shift and go to state 121


state 86

    (51) literal -> INT_CONST .

    .               reduce using rule 51 (literal -> INT_CONST .)
    )               reduce using rule 51 (literal -> INT_CONST .)
    PLUS            reduce using rule 51 (literal -> INT_CONST .)
    MINUS           reduce using rule 51 (literal -> INT_CONST .)
    TIMES           reduce using rule 51 (literal -> INT_CONST .)
    DIVIDE          reduce using rule 51 (literal -> INT_CONST .)
    AND             reduce using rule 51 (literal -> INT_CONST .)
    OR              reduce using rule 51 (literal -> INT_CONST .)
    EQUALITY        reduce using rule 51 (literal -> INT_CONST .)
    INEQUALITY      reduce using rule 51 (literal -> INT_CONST .)
    LESSER          reduce using rule 51 (literal -> INT_CONST .)
    GREATER         reduce using rule 51 (literal -> INT_CONST .)
    LEQ             reduce using rule 51 (literal -> INT_CONST .)
    GEQ             reduce using rule 51 (literal -> INT_CONST .)
    ;               reduce using rule 51 (literal -> INT_CONST .)
    ,               reduce using rule 51 (literal -> INT_CONST .)


state 87

    (52) literal -> FLOAT_CONST .

    .               reduce using rule 52 (literal -> FLOAT_CONST .)
    )               reduce using rule 52 (literal -> FLOAT_CONST .)
    PLUS            reduce using rule 52 (literal -> FLOAT_CONST .)
    MINUS           reduce using rule 52 (literal -> FLOAT_CONST .)
    TIMES           reduce using rule 52 (literal -> FLOAT_CONST .)
    DIVIDE          reduce using rule 52 (literal -> FLOAT_CONST .)
    AND             reduce using rule 52 (literal -> FLOAT_CONST .)
    OR              reduce using rule 52 (literal -> FLOAT_CONST .)
    EQUALITY        reduce using rule 52 (literal -> FLOAT_CONST .)
    INEQUALITY      reduce using rule 52 (literal -> FLOAT_CONST .)
    LESSER          reduce using rule 52 (literal -> FLOAT_CONST .)
    GREATER         reduce using rule 52 (literal -> FLOAT_CONST .)
    LEQ             reduce using rule 52 (literal -> FLOAT_CONST .)
    GEQ             reduce using rule 52 (literal -> FLOAT_CONST .)
    ;               reduce using rule 52 (literal -> FLOAT_CONST .)
    ,               reduce using rule 52 (literal -> FLOAT_CONST .)


state 88

    (53) literal -> STRING_CONST .

    .               reduce using rule 53 (literal -> STRING_CONST .)
    )               reduce using rule 53 (literal -> STRING_CONST .)
    PLUS            reduce using rule 53 (literal -> STRING_CONST .)
    MINUS           reduce using rule 53 (literal -> STRING_CONST .)
    TIMES           reduce using rule 53 (literal -> STRING_CONST .)
    DIVIDE          reduce using rule 53 (literal -> STRING_CONST .)
    AND             reduce using rule 53 (literal -> STRING_CONST .)
    OR              reduce using rule 53 (literal -> STRING_CONST .)
    EQUALITY        reduce using rule 53 (literal -> STRING_CONST .)
    INEQUALITY      reduce using rule 53 (literal -> STRING_CONST .)
    LESSER          reduce using rule 53 (literal -> STRING_CONST .)
    GREATER         reduce using rule 53 (literal -> STRING_CONST .)
    LEQ             reduce using rule 53 (literal -> STRING_CONST .)
    GEQ             reduce using rule 53 (literal -> STRING_CONST .)
    ;               reduce using rule 53 (literal -> STRING_CONST .)
    ,               reduce using rule 53 (literal -> STRING_CONST .)


state 89

    (54) literal -> NULL .

    .               reduce using rule 54 (literal -> NULL .)
    )               reduce using rule 54 (literal -> NULL .)
    PLUS            reduce using rule 54 (literal -> NULL .)
    MINUS           reduce using rule 54 (literal -> NULL .)
    TIMES           reduce using rule 54 (literal -> NULL .)
    DIVIDE          reduce using rule 54 (literal -> NULL .)
    AND             reduce using rule 54 (literal -> NULL .)
    OR              reduce using rule 54 (literal -> NULL .)
    EQUALITY        reduce using rule 54 (literal -> NULL .)
    INEQUALITY      reduce using rule 54 (literal -> NULL .)
    LESSER          reduce using rule 54 (literal -> NULL .)
    GREATER         reduce using rule 54 (literal -> NULL .)
    LEQ             reduce using rule 54 (literal -> NULL .)
    GEQ             reduce using rule 54 (literal -> NULL .)
    ;               reduce using rule 54 (literal -> NULL .)
    ,               reduce using rule 54 (literal -> NULL .)


state 90

    (55) literal -> TRUE .

    .               reduce using rule 55 (literal -> TRUE .)
    )               reduce using rule 55 (literal -> TRUE .)
    PLUS            reduce using rule 55 (literal -> TRUE .)
    MINUS           reduce using rule 55 (literal -> TRUE .)
    TIMES           reduce using rule 55 (literal -> TRUE .)
    DIVIDE          reduce using rule 55 (literal -> TRUE .)
    AND             reduce using rule 55 (literal -> TRUE .)
    OR              reduce using rule 55 (literal -> TRUE .)
    EQUALITY        reduce using rule 55 (literal -> TRUE .)
    INEQUALITY      reduce using rule 55 (literal -> TRUE .)
    LESSER          reduce using rule 55 (literal -> TRUE .)
    GREATER         reduce using rule 55 (literal -> TRUE .)
    LEQ             reduce using rule 55 (literal -> TRUE .)
    GEQ             reduce using rule 55 (literal -> TRUE .)
    ;               reduce using rule 55 (literal -> TRUE .)
    ,               reduce using rule 55 (literal -> TRUE .)


state 91

    (56) literal -> FALSE .

    .               reduce using rule 56 (literal -> FALSE .)
    )               reduce using rule 56 (literal -> FALSE .)
    PLUS            reduce using rule 56 (literal -> FALSE .)
    MINUS           reduce using rule 56 (literal -> FALSE .)
    TIMES           reduce using rule 56 (literal -> FALSE .)
    DIVIDE          reduce using rule 56 (literal -> FALSE .)
    AND             reduce using rule 56 (literal -> FALSE .)
    OR              reduce using rule 56 (literal -> FALSE .)
    EQUALITY        reduce using rule 56 (literal -> FALSE .)
    INEQUALITY      reduce using rule 56 (literal -> FALSE .)
    LESSER          reduce using rule 56 (literal -> FALSE .)
    GREATER         reduce using rule 56 (literal -> FALSE .)
    LEQ             reduce using rule 56 (literal -> FALSE .)
    GEQ             reduce using rule 56 (literal -> FALSE .)
    ;               reduce using rule 56 (literal -> FALSE .)
    ,               reduce using rule 56 (literal -> FALSE .)


state 92

    (26) method_decl -> modifier VOID ID ( optional_formals ) block .

    }               reduce using rule 26 (method_decl -> modifier VOID ID ( optional_formals ) block .)
    PRIVATE         reduce using rule 26 (method_decl -> modifier VOID ID ( optional_formals ) block .)
    PUBLIC          reduce using rule 26 (method_decl -> modifier VOID ID ( optional_formals ) block .)
    STATIC          reduce using rule 26 (method_decl -> modifier VOID ID ( optional_formals ) block .)
    VOID            reduce using rule 26 (method_decl -> modifier VOID ID ( optional_formals ) block .)
    ID              reduce using rule 26 (method_decl -> modifier VOID ID ( optional_formals ) block .)
    INT             reduce using rule 26 (method_decl -> modifier VOID ID ( optional_formals ) block .)
    FLOAT           reduce using rule 26 (method_decl -> modifier VOID ID ( optional_formals ) block .)
    BOOLEAN         reduce using rule 26 (method_decl -> modifier VOID ID ( optional_formals ) block .)


state 93

    (35) stmt -> stmt stmt .
    (35) stmt -> stmt . stmt
    (35) stmt -> . stmt stmt
    (36) stmt -> . IF ( expr ) stmt ELSE stmt
    (37) stmt -> . IF ( expr ) stmt
    (38) stmt -> . WHILE ( expr ) stmt
    (39) stmt -> . FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (40) stmt -> . RETURN optional_expr ;
    (41) stmt -> . stmt_expr ;
    (42) stmt -> . BREAK ;
    (43) stmt -> . CONTINUE ;
    (44) stmt -> . block
    (45) stmt -> . var_decl
    (46) stmt -> . ;
    (96) stmt_expr -> . assign
    (97) stmt_expr -> . method_invocation
    (33) block -> . { stmt }
    (34) block -> . { }
    (17) var_decl -> . type variables ;
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INT_CONST resolved as shift
  ! shift/reduce conflict for FLOAT_CONST resolved as shift
  ! shift/reduce conflict for STRING_CONST resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    }               reduce using rule 35 (stmt -> stmt stmt .)
    ELSE            reduce using rule 35 (stmt -> stmt stmt .)
    IF              shift and go to state 63
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    RETURN          shift and go to state 68
    BREAK           shift and go to state 70
    CONTINUE        shift and go to state 71
    ;               shift and go to state 67
    {               shift and go to state 57
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 80
    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91

  ! IF              [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! WHILE           [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! FOR             [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! RETURN          [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! BREAK           [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! CONTINUE        [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! ;               [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! {               [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! PLUS            [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! MINUS           [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! INT             [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! FLOAT           [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! BOOLEAN         [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! ID              [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! THIS            [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! SUPER           [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! (               [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! NEW             [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! INT_CONST       [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! FLOAT_CONST     [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! STRING_CONST    [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! NULL            [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! TRUE            [ reduce using rule 35 (stmt -> stmt stmt .) ]
  ! FALSE           [ reduce using rule 35 (stmt -> stmt stmt .) ]

    stmt                           shift and go to state 93
    stmt_expr                      shift and go to state 69
    block                          shift and go to state 72
    var_decl                       shift and go to state 73
    assign                         shift and go to state 74
    method_invocation              shift and go to state 75
    type                           shift and go to state 76
    field_access                   shift and go to state 77
    primary                        shift and go to state 81
    literal                        shift and go to state 82

state 94

    (33) block -> { stmt } .

    }               reduce using rule 33 (block -> { stmt } .)
    PRIVATE         reduce using rule 33 (block -> { stmt } .)
    PUBLIC          reduce using rule 33 (block -> { stmt } .)
    STATIC          reduce using rule 33 (block -> { stmt } .)
    VOID            reduce using rule 33 (block -> { stmt } .)
    ID              reduce using rule 33 (block -> { stmt } .)
    INT             reduce using rule 33 (block -> { stmt } .)
    FLOAT           reduce using rule 33 (block -> { stmt } .)
    BOOLEAN         reduce using rule 33 (block -> { stmt } .)
    IF              reduce using rule 33 (block -> { stmt } .)
    WHILE           reduce using rule 33 (block -> { stmt } .)
    FOR             reduce using rule 33 (block -> { stmt } .)
    RETURN          reduce using rule 33 (block -> { stmt } .)
    BREAK           reduce using rule 33 (block -> { stmt } .)
    CONTINUE        reduce using rule 33 (block -> { stmt } .)
    ;               reduce using rule 33 (block -> { stmt } .)
    {               reduce using rule 33 (block -> { stmt } .)
    PLUS            reduce using rule 33 (block -> { stmt } .)
    MINUS           reduce using rule 33 (block -> { stmt } .)
    THIS            reduce using rule 33 (block -> { stmt } .)
    SUPER           reduce using rule 33 (block -> { stmt } .)
    (               reduce using rule 33 (block -> { stmt } .)
    NEW             reduce using rule 33 (block -> { stmt } .)
    INT_CONST       reduce using rule 33 (block -> { stmt } .)
    FLOAT_CONST     reduce using rule 33 (block -> { stmt } .)
    STRING_CONST    reduce using rule 33 (block -> { stmt } .)
    NULL            reduce using rule 33 (block -> { stmt } .)
    TRUE            reduce using rule 33 (block -> { stmt } .)
    FALSE           reduce using rule 33 (block -> { stmt } .)
    ELSE            reduce using rule 33 (block -> { stmt } .)


state 95

    (36) stmt -> IF ( . expr ) stmt ELSE stmt
    (37) stmt -> IF ( . expr ) stmt
    (71) expr -> . primary
    (72) expr -> . assign
    (73) expr -> . expr arith_op expr
    (74) expr -> . expr bool_op expr
    (75) expr -> . unary_op expr
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (93) unary_op -> . PLUS
    (94) unary_op -> . MINUS
    (95) unary_op -> . NOT
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )

    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    PLUS            shift and go to state 103
    MINUS           shift and go to state 104
    NOT             shift and go to state 105
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91
    ID              shift and go to state 100

    expr                           shift and go to state 122
    primary                        shift and go to state 97
    assign                         shift and go to state 98
    unary_op                       shift and go to state 99
    literal                        shift and go to state 82
    field_access                   shift and go to state 101
    method_invocation              shift and go to state 102

state 96

    (60) primary -> ( expr . )
    (73) expr -> expr . arith_op expr
    (74) expr -> expr . bool_op expr
    (81) arith_op -> . PLUS
    (82) arith_op -> . MINUS
    (83) arith_op -> . TIMES
    (84) arith_op -> . DIVIDE
    (85) bool_op -> . AND
    (86) bool_op -> . OR
    (87) bool_op -> . EQUALITY
    (88) bool_op -> . INEQUALITY
    (89) bool_op -> . LESSER
    (90) bool_op -> . GREATER
    (91) bool_op -> . LEQ
    (92) bool_op -> . GEQ

    )               shift and go to state 123
    PLUS            shift and go to state 126
    MINUS           shift and go to state 127
    TIMES           shift and go to state 128
    DIVIDE          shift and go to state 129
    AND             shift and go to state 130
    OR              shift and go to state 131
    EQUALITY        shift and go to state 132
    INEQUALITY      shift and go to state 133
    LESSER          shift and go to state 134
    GREATER         shift and go to state 135
    LEQ             shift and go to state 136
    GEQ             shift and go to state 137

    arith_op                       shift and go to state 124
    bool_op                        shift and go to state 125

state 97

    (71) expr -> primary .
    (67) field_access -> primary . . ID

    )               reduce using rule 71 (expr -> primary .)
    PLUS            reduce using rule 71 (expr -> primary .)
    MINUS           reduce using rule 71 (expr -> primary .)
    TIMES           reduce using rule 71 (expr -> primary .)
    DIVIDE          reduce using rule 71 (expr -> primary .)
    AND             reduce using rule 71 (expr -> primary .)
    OR              reduce using rule 71 (expr -> primary .)
    EQUALITY        reduce using rule 71 (expr -> primary .)
    INEQUALITY      reduce using rule 71 (expr -> primary .)
    LESSER          reduce using rule 71 (expr -> primary .)
    GREATER         reduce using rule 71 (expr -> primary .)
    LEQ             reduce using rule 71 (expr -> primary .)
    GEQ             reduce using rule 71 (expr -> primary .)
    ;               reduce using rule 71 (expr -> primary .)
    ,               reduce using rule 71 (expr -> primary .)
    .               shift and go to state 120


state 98

    (72) expr -> assign .

    )               reduce using rule 72 (expr -> assign .)
    PLUS            reduce using rule 72 (expr -> assign .)
    MINUS           reduce using rule 72 (expr -> assign .)
    TIMES           reduce using rule 72 (expr -> assign .)
    DIVIDE          reduce using rule 72 (expr -> assign .)
    AND             reduce using rule 72 (expr -> assign .)
    OR              reduce using rule 72 (expr -> assign .)
    EQUALITY        reduce using rule 72 (expr -> assign .)
    INEQUALITY      reduce using rule 72 (expr -> assign .)
    LESSER          reduce using rule 72 (expr -> assign .)
    GREATER         reduce using rule 72 (expr -> assign .)
    LEQ             reduce using rule 72 (expr -> assign .)
    GEQ             reduce using rule 72 (expr -> assign .)
    ;               reduce using rule 72 (expr -> assign .)
    ,               reduce using rule 72 (expr -> assign .)


state 99

    (75) expr -> unary_op . expr
    (71) expr -> . primary
    (72) expr -> . assign
    (73) expr -> . expr arith_op expr
    (74) expr -> . expr bool_op expr
    (75) expr -> . unary_op expr
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (93) unary_op -> . PLUS
    (94) unary_op -> . MINUS
    (95) unary_op -> . NOT
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )

    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    PLUS            shift and go to state 103
    MINUS           shift and go to state 104
    NOT             shift and go to state 105
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91
    ID              shift and go to state 100

    unary_op                       shift and go to state 99
    expr                           shift and go to state 138
    primary                        shift and go to state 97
    assign                         shift and go to state 98
    literal                        shift and go to state 82
    field_access                   shift and go to state 101
    method_invocation              shift and go to state 102

state 100

    (68) field_access -> ID .

    ASSIGN          reduce using rule 68 (field_access -> ID .)
    PLUS            reduce using rule 68 (field_access -> ID .)
    MINUS           reduce using rule 68 (field_access -> ID .)
    (               reduce using rule 68 (field_access -> ID .)
    .               reduce using rule 68 (field_access -> ID .)
    )               reduce using rule 68 (field_access -> ID .)
    TIMES           reduce using rule 68 (field_access -> ID .)
    DIVIDE          reduce using rule 68 (field_access -> ID .)
    AND             reduce using rule 68 (field_access -> ID .)
    OR              reduce using rule 68 (field_access -> ID .)
    EQUALITY        reduce using rule 68 (field_access -> ID .)
    INEQUALITY      reduce using rule 68 (field_access -> ID .)
    LESSER          reduce using rule 68 (field_access -> ID .)
    GREATER         reduce using rule 68 (field_access -> ID .)
    LEQ             reduce using rule 68 (field_access -> ID .)
    GEQ             reduce using rule 68 (field_access -> ID .)
    ;               reduce using rule 68 (field_access -> ID .)
    ,               reduce using rule 68 (field_access -> ID .)


state 101

    (63) primary -> field_access .
    (76) assign -> field_access . ASSIGN expr
    (77) assign -> field_access . PLUS PLUS
    (79) assign -> field_access . MINUS MINUS
    (69) method_invocation -> field_access . ( arguments )
    (70) method_invocation -> field_access . ( )

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    .               reduce using rule 63 (primary -> field_access .)
    )               reduce using rule 63 (primary -> field_access .)
    TIMES           reduce using rule 63 (primary -> field_access .)
    DIVIDE          reduce using rule 63 (primary -> field_access .)
    AND             reduce using rule 63 (primary -> field_access .)
    OR              reduce using rule 63 (primary -> field_access .)
    EQUALITY        reduce using rule 63 (primary -> field_access .)
    INEQUALITY      reduce using rule 63 (primary -> field_access .)
    LESSER          reduce using rule 63 (primary -> field_access .)
    GREATER         reduce using rule 63 (primary -> field_access .)
    LEQ             reduce using rule 63 (primary -> field_access .)
    GEQ             reduce using rule 63 (primary -> field_access .)
    ;               reduce using rule 63 (primary -> field_access .)
    ,               reduce using rule 63 (primary -> field_access .)
    ASSIGN          shift and go to state 114
    PLUS            shift and go to state 115
    MINUS           shift and go to state 116
    (               shift and go to state 117

  ! PLUS            [ reduce using rule 63 (primary -> field_access .) ]
  ! MINUS           [ reduce using rule 63 (primary -> field_access .) ]


state 102

    (64) primary -> method_invocation .

    .               reduce using rule 64 (primary -> method_invocation .)
    )               reduce using rule 64 (primary -> method_invocation .)
    PLUS            reduce using rule 64 (primary -> method_invocation .)
    MINUS           reduce using rule 64 (primary -> method_invocation .)
    TIMES           reduce using rule 64 (primary -> method_invocation .)
    DIVIDE          reduce using rule 64 (primary -> method_invocation .)
    AND             reduce using rule 64 (primary -> method_invocation .)
    OR              reduce using rule 64 (primary -> method_invocation .)
    EQUALITY        reduce using rule 64 (primary -> method_invocation .)
    INEQUALITY      reduce using rule 64 (primary -> method_invocation .)
    LESSER          reduce using rule 64 (primary -> method_invocation .)
    GREATER         reduce using rule 64 (primary -> method_invocation .)
    LEQ             reduce using rule 64 (primary -> method_invocation .)
    GEQ             reduce using rule 64 (primary -> method_invocation .)
    ;               reduce using rule 64 (primary -> method_invocation .)
    ,               reduce using rule 64 (primary -> method_invocation .)


state 103

    (78) assign -> PLUS . PLUS field_access
    (93) unary_op -> PLUS .

    THIS            reduce using rule 93 (unary_op -> PLUS .)
    SUPER           reduce using rule 93 (unary_op -> PLUS .)
    (               reduce using rule 93 (unary_op -> PLUS .)
    NEW             reduce using rule 93 (unary_op -> PLUS .)
    PLUS            reduce using rule 93 (unary_op -> PLUS .)
    MINUS           reduce using rule 93 (unary_op -> PLUS .)
    NOT             reduce using rule 93 (unary_op -> PLUS .)
    INT_CONST       reduce using rule 93 (unary_op -> PLUS .)
    FLOAT_CONST     reduce using rule 93 (unary_op -> PLUS .)
    STRING_CONST    reduce using rule 93 (unary_op -> PLUS .)
    NULL            reduce using rule 93 (unary_op -> PLUS .)
    TRUE            reduce using rule 93 (unary_op -> PLUS .)
    FALSE           reduce using rule 93 (unary_op -> PLUS .)
    ID              reduce using rule 93 (unary_op -> PLUS .)

  ! PLUS            [ shift and go to state 118 ]


state 104

    (80) assign -> MINUS . MINUS field_access
    (94) unary_op -> MINUS .

    THIS            reduce using rule 94 (unary_op -> MINUS .)
    SUPER           reduce using rule 94 (unary_op -> MINUS .)
    (               reduce using rule 94 (unary_op -> MINUS .)
    NEW             reduce using rule 94 (unary_op -> MINUS .)
    PLUS            reduce using rule 94 (unary_op -> MINUS .)
    MINUS           reduce using rule 94 (unary_op -> MINUS .)
    NOT             reduce using rule 94 (unary_op -> MINUS .)
    INT_CONST       reduce using rule 94 (unary_op -> MINUS .)
    FLOAT_CONST     reduce using rule 94 (unary_op -> MINUS .)
    STRING_CONST    reduce using rule 94 (unary_op -> MINUS .)
    NULL            reduce using rule 94 (unary_op -> MINUS .)
    TRUE            reduce using rule 94 (unary_op -> MINUS .)
    FALSE           reduce using rule 94 (unary_op -> MINUS .)
    ID              reduce using rule 94 (unary_op -> MINUS .)

  ! MINUS           [ shift and go to state 119 ]


state 105

    (95) unary_op -> NOT .

    THIS            reduce using rule 95 (unary_op -> NOT .)
    SUPER           reduce using rule 95 (unary_op -> NOT .)
    (               reduce using rule 95 (unary_op -> NOT .)
    NEW             reduce using rule 95 (unary_op -> NOT .)
    PLUS            reduce using rule 95 (unary_op -> NOT .)
    MINUS           reduce using rule 95 (unary_op -> NOT .)
    NOT             reduce using rule 95 (unary_op -> NOT .)
    INT_CONST       reduce using rule 95 (unary_op -> NOT .)
    FLOAT_CONST     reduce using rule 95 (unary_op -> NOT .)
    STRING_CONST    reduce using rule 95 (unary_op -> NOT .)
    NULL            reduce using rule 95 (unary_op -> NOT .)
    TRUE            reduce using rule 95 (unary_op -> NOT .)
    FALSE           reduce using rule 95 (unary_op -> NOT .)
    ID              reduce using rule 95 (unary_op -> NOT .)


state 106

    (38) stmt -> WHILE ( . expr ) stmt
    (71) expr -> . primary
    (72) expr -> . assign
    (73) expr -> . expr arith_op expr
    (74) expr -> . expr bool_op expr
    (75) expr -> . unary_op expr
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (93) unary_op -> . PLUS
    (94) unary_op -> . MINUS
    (95) unary_op -> . NOT
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )

    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    PLUS            shift and go to state 103
    MINUS           shift and go to state 104
    NOT             shift and go to state 105
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91
    ID              shift and go to state 100

    expr                           shift and go to state 139
    primary                        shift and go to state 97
    assign                         shift and go to state 98
    unary_op                       shift and go to state 99
    literal                        shift and go to state 82
    field_access                   shift and go to state 101
    method_invocation              shift and go to state 102

state 107

    (39) stmt -> FOR ( . optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (49) optional_stmt_expr -> . stmt_expr
    (50) optional_stmt_expr -> . empty
    (96) stmt_expr -> . assign
    (97) stmt_expr -> . method_invocation
    (98) empty -> .
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE

    ;               reduce using rule 98 (empty -> .)
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    ID              shift and go to state 100
    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91

    optional_stmt_expr             shift and go to state 140
    stmt_expr                      shift and go to state 141
    empty                          shift and go to state 142
    assign                         shift and go to state 74
    method_invocation              shift and go to state 75
    field_access                   shift and go to state 77
    primary                        shift and go to state 81
    literal                        shift and go to state 82

state 108

    (40) stmt -> RETURN optional_expr . ;

    ;               shift and go to state 143


state 109

    (47) optional_expr -> expr .
    (73) expr -> expr . arith_op expr
    (74) expr -> expr . bool_op expr
    (81) arith_op -> . PLUS
    (82) arith_op -> . MINUS
    (83) arith_op -> . TIMES
    (84) arith_op -> . DIVIDE
    (85) bool_op -> . AND
    (86) bool_op -> . OR
    (87) bool_op -> . EQUALITY
    (88) bool_op -> . INEQUALITY
    (89) bool_op -> . LESSER
    (90) bool_op -> . GREATER
    (91) bool_op -> . LEQ
    (92) bool_op -> . GEQ

    ;               reduce using rule 47 (optional_expr -> expr .)
    PLUS            shift and go to state 126
    MINUS           shift and go to state 127
    TIMES           shift and go to state 128
    DIVIDE          shift and go to state 129
    AND             shift and go to state 130
    OR              shift and go to state 131
    EQUALITY        shift and go to state 132
    INEQUALITY      shift and go to state 133
    LESSER          shift and go to state 134
    GREATER         shift and go to state 135
    LEQ             shift and go to state 136
    GEQ             shift and go to state 137

    arith_op                       shift and go to state 124
    bool_op                        shift and go to state 125

state 110

    (48) optional_expr -> empty .

    ;               reduce using rule 48 (optional_expr -> empty .)


state 111

    (41) stmt -> stmt_expr ; .

    }               reduce using rule 41 (stmt -> stmt_expr ; .)
    IF              reduce using rule 41 (stmt -> stmt_expr ; .)
    WHILE           reduce using rule 41 (stmt -> stmt_expr ; .)
    FOR             reduce using rule 41 (stmt -> stmt_expr ; .)
    RETURN          reduce using rule 41 (stmt -> stmt_expr ; .)
    BREAK           reduce using rule 41 (stmt -> stmt_expr ; .)
    CONTINUE        reduce using rule 41 (stmt -> stmt_expr ; .)
    ;               reduce using rule 41 (stmt -> stmt_expr ; .)
    {               reduce using rule 41 (stmt -> stmt_expr ; .)
    PLUS            reduce using rule 41 (stmt -> stmt_expr ; .)
    MINUS           reduce using rule 41 (stmt -> stmt_expr ; .)
    INT             reduce using rule 41 (stmt -> stmt_expr ; .)
    FLOAT           reduce using rule 41 (stmt -> stmt_expr ; .)
    BOOLEAN         reduce using rule 41 (stmt -> stmt_expr ; .)
    ID              reduce using rule 41 (stmt -> stmt_expr ; .)
    THIS            reduce using rule 41 (stmt -> stmt_expr ; .)
    SUPER           reduce using rule 41 (stmt -> stmt_expr ; .)
    (               reduce using rule 41 (stmt -> stmt_expr ; .)
    NEW             reduce using rule 41 (stmt -> stmt_expr ; .)
    INT_CONST       reduce using rule 41 (stmt -> stmt_expr ; .)
    FLOAT_CONST     reduce using rule 41 (stmt -> stmt_expr ; .)
    STRING_CONST    reduce using rule 41 (stmt -> stmt_expr ; .)
    NULL            reduce using rule 41 (stmt -> stmt_expr ; .)
    TRUE            reduce using rule 41 (stmt -> stmt_expr ; .)
    FALSE           reduce using rule 41 (stmt -> stmt_expr ; .)
    ELSE            reduce using rule 41 (stmt -> stmt_expr ; .)


state 112

    (42) stmt -> BREAK ; .

    }               reduce using rule 42 (stmt -> BREAK ; .)
    IF              reduce using rule 42 (stmt -> BREAK ; .)
    WHILE           reduce using rule 42 (stmt -> BREAK ; .)
    FOR             reduce using rule 42 (stmt -> BREAK ; .)
    RETURN          reduce using rule 42 (stmt -> BREAK ; .)
    BREAK           reduce using rule 42 (stmt -> BREAK ; .)
    CONTINUE        reduce using rule 42 (stmt -> BREAK ; .)
    ;               reduce using rule 42 (stmt -> BREAK ; .)
    {               reduce using rule 42 (stmt -> BREAK ; .)
    PLUS            reduce using rule 42 (stmt -> BREAK ; .)
    MINUS           reduce using rule 42 (stmt -> BREAK ; .)
    INT             reduce using rule 42 (stmt -> BREAK ; .)
    FLOAT           reduce using rule 42 (stmt -> BREAK ; .)
    BOOLEAN         reduce using rule 42 (stmt -> BREAK ; .)
    ID              reduce using rule 42 (stmt -> BREAK ; .)
    THIS            reduce using rule 42 (stmt -> BREAK ; .)
    SUPER           reduce using rule 42 (stmt -> BREAK ; .)
    (               reduce using rule 42 (stmt -> BREAK ; .)
    NEW             reduce using rule 42 (stmt -> BREAK ; .)
    INT_CONST       reduce using rule 42 (stmt -> BREAK ; .)
    FLOAT_CONST     reduce using rule 42 (stmt -> BREAK ; .)
    STRING_CONST    reduce using rule 42 (stmt -> BREAK ; .)
    NULL            reduce using rule 42 (stmt -> BREAK ; .)
    TRUE            reduce using rule 42 (stmt -> BREAK ; .)
    FALSE           reduce using rule 42 (stmt -> BREAK ; .)
    ELSE            reduce using rule 42 (stmt -> BREAK ; .)


state 113

    (43) stmt -> CONTINUE ; .

    }               reduce using rule 43 (stmt -> CONTINUE ; .)
    IF              reduce using rule 43 (stmt -> CONTINUE ; .)
    WHILE           reduce using rule 43 (stmt -> CONTINUE ; .)
    FOR             reduce using rule 43 (stmt -> CONTINUE ; .)
    RETURN          reduce using rule 43 (stmt -> CONTINUE ; .)
    BREAK           reduce using rule 43 (stmt -> CONTINUE ; .)
    CONTINUE        reduce using rule 43 (stmt -> CONTINUE ; .)
    ;               reduce using rule 43 (stmt -> CONTINUE ; .)
    {               reduce using rule 43 (stmt -> CONTINUE ; .)
    PLUS            reduce using rule 43 (stmt -> CONTINUE ; .)
    MINUS           reduce using rule 43 (stmt -> CONTINUE ; .)
    INT             reduce using rule 43 (stmt -> CONTINUE ; .)
    FLOAT           reduce using rule 43 (stmt -> CONTINUE ; .)
    BOOLEAN         reduce using rule 43 (stmt -> CONTINUE ; .)
    ID              reduce using rule 43 (stmt -> CONTINUE ; .)
    THIS            reduce using rule 43 (stmt -> CONTINUE ; .)
    SUPER           reduce using rule 43 (stmt -> CONTINUE ; .)
    (               reduce using rule 43 (stmt -> CONTINUE ; .)
    NEW             reduce using rule 43 (stmt -> CONTINUE ; .)
    INT_CONST       reduce using rule 43 (stmt -> CONTINUE ; .)
    FLOAT_CONST     reduce using rule 43 (stmt -> CONTINUE ; .)
    STRING_CONST    reduce using rule 43 (stmt -> CONTINUE ; .)
    NULL            reduce using rule 43 (stmt -> CONTINUE ; .)
    TRUE            reduce using rule 43 (stmt -> CONTINUE ; .)
    FALSE           reduce using rule 43 (stmt -> CONTINUE ; .)
    ELSE            reduce using rule 43 (stmt -> CONTINUE ; .)


state 114

    (76) assign -> field_access ASSIGN . expr
    (71) expr -> . primary
    (72) expr -> . assign
    (73) expr -> . expr arith_op expr
    (74) expr -> . expr bool_op expr
    (75) expr -> . unary_op expr
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (93) unary_op -> . PLUS
    (94) unary_op -> . MINUS
    (95) unary_op -> . NOT
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )

    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    PLUS            shift and go to state 103
    MINUS           shift and go to state 104
    NOT             shift and go to state 105
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91
    ID              shift and go to state 100

    field_access                   shift and go to state 101
    expr                           shift and go to state 144
    primary                        shift and go to state 97
    assign                         shift and go to state 98
    unary_op                       shift and go to state 99
    literal                        shift and go to state 82
    method_invocation              shift and go to state 102

state 115

    (77) assign -> field_access PLUS . PLUS

    PLUS            shift and go to state 145


state 116

    (79) assign -> field_access MINUS . MINUS

    MINUS           shift and go to state 146


state 117

    (69) method_invocation -> field_access ( . arguments )
    (70) method_invocation -> field_access ( . )
    (65) arguments -> . expr
    (66) arguments -> . expr , arguments
    (71) expr -> . primary
    (72) expr -> . assign
    (73) expr -> . expr arith_op expr
    (74) expr -> . expr bool_op expr
    (75) expr -> . unary_op expr
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (93) unary_op -> . PLUS
    (94) unary_op -> . MINUS
    (95) unary_op -> . NOT
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )

    )               shift and go to state 148
    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    PLUS            shift and go to state 103
    MINUS           shift and go to state 104
    NOT             shift and go to state 105
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91
    ID              shift and go to state 100

    field_access                   shift and go to state 101
    arguments                      shift and go to state 147
    expr                           shift and go to state 149
    primary                        shift and go to state 97
    assign                         shift and go to state 98
    unary_op                       shift and go to state 99
    literal                        shift and go to state 82
    method_invocation              shift and go to state 102

state 118

    (78) assign -> PLUS PLUS . field_access
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )

    ID              shift and go to state 100
    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91

    field_access                   shift and go to state 150
    primary                        shift and go to state 81
    literal                        shift and go to state 82
    method_invocation              shift and go to state 102

state 119

    (80) assign -> MINUS MINUS . field_access
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )

    ID              shift and go to state 100
    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91

    field_access                   shift and go to state 151
    primary                        shift and go to state 81
    literal                        shift and go to state 82
    method_invocation              shift and go to state 102

state 120

    (67) field_access -> primary . . ID

    ID              shift and go to state 152


state 121

    (61) primary -> NEW ID . ( arguments )
    (62) primary -> NEW ID . ( )

    (               shift and go to state 153


state 122

    (36) stmt -> IF ( expr . ) stmt ELSE stmt
    (37) stmt -> IF ( expr . ) stmt
    (73) expr -> expr . arith_op expr
    (74) expr -> expr . bool_op expr
    (81) arith_op -> . PLUS
    (82) arith_op -> . MINUS
    (83) arith_op -> . TIMES
    (84) arith_op -> . DIVIDE
    (85) bool_op -> . AND
    (86) bool_op -> . OR
    (87) bool_op -> . EQUALITY
    (88) bool_op -> . INEQUALITY
    (89) bool_op -> . LESSER
    (90) bool_op -> . GREATER
    (91) bool_op -> . LEQ
    (92) bool_op -> . GEQ

    )               shift and go to state 154
    PLUS            shift and go to state 126
    MINUS           shift and go to state 127
    TIMES           shift and go to state 128
    DIVIDE          shift and go to state 129
    AND             shift and go to state 130
    OR              shift and go to state 131
    EQUALITY        shift and go to state 132
    INEQUALITY      shift and go to state 133
    LESSER          shift and go to state 134
    GREATER         shift and go to state 135
    LEQ             shift and go to state 136
    GEQ             shift and go to state 137

    arith_op                       shift and go to state 124
    bool_op                        shift and go to state 125

state 123

    (60) primary -> ( expr ) .

    .               reduce using rule 60 (primary -> ( expr ) .)
    )               reduce using rule 60 (primary -> ( expr ) .)
    PLUS            reduce using rule 60 (primary -> ( expr ) .)
    MINUS           reduce using rule 60 (primary -> ( expr ) .)
    TIMES           reduce using rule 60 (primary -> ( expr ) .)
    DIVIDE          reduce using rule 60 (primary -> ( expr ) .)
    AND             reduce using rule 60 (primary -> ( expr ) .)
    OR              reduce using rule 60 (primary -> ( expr ) .)
    EQUALITY        reduce using rule 60 (primary -> ( expr ) .)
    INEQUALITY      reduce using rule 60 (primary -> ( expr ) .)
    LESSER          reduce using rule 60 (primary -> ( expr ) .)
    GREATER         reduce using rule 60 (primary -> ( expr ) .)
    LEQ             reduce using rule 60 (primary -> ( expr ) .)
    GEQ             reduce using rule 60 (primary -> ( expr ) .)
    ;               reduce using rule 60 (primary -> ( expr ) .)
    ,               reduce using rule 60 (primary -> ( expr ) .)


state 124

    (73) expr -> expr arith_op . expr
    (71) expr -> . primary
    (72) expr -> . assign
    (73) expr -> . expr arith_op expr
    (74) expr -> . expr bool_op expr
    (75) expr -> . unary_op expr
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (93) unary_op -> . PLUS
    (94) unary_op -> . MINUS
    (95) unary_op -> . NOT
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )

    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    PLUS            shift and go to state 103
    MINUS           shift and go to state 104
    NOT             shift and go to state 105
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91
    ID              shift and go to state 100

    expr                           shift and go to state 155
    primary                        shift and go to state 97
    assign                         shift and go to state 98
    unary_op                       shift and go to state 99
    literal                        shift and go to state 82
    field_access                   shift and go to state 101
    method_invocation              shift and go to state 102

state 125

    (74) expr -> expr bool_op . expr
    (71) expr -> . primary
    (72) expr -> . assign
    (73) expr -> . expr arith_op expr
    (74) expr -> . expr bool_op expr
    (75) expr -> . unary_op expr
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (93) unary_op -> . PLUS
    (94) unary_op -> . MINUS
    (95) unary_op -> . NOT
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )

    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    PLUS            shift and go to state 103
    MINUS           shift and go to state 104
    NOT             shift and go to state 105
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91
    ID              shift and go to state 100

    expr                           shift and go to state 156
    primary                        shift and go to state 97
    assign                         shift and go to state 98
    unary_op                       shift and go to state 99
    literal                        shift and go to state 82
    field_access                   shift and go to state 101
    method_invocation              shift and go to state 102

state 126

    (81) arith_op -> PLUS .

    THIS            reduce using rule 81 (arith_op -> PLUS .)
    SUPER           reduce using rule 81 (arith_op -> PLUS .)
    (               reduce using rule 81 (arith_op -> PLUS .)
    NEW             reduce using rule 81 (arith_op -> PLUS .)
    PLUS            reduce using rule 81 (arith_op -> PLUS .)
    MINUS           reduce using rule 81 (arith_op -> PLUS .)
    NOT             reduce using rule 81 (arith_op -> PLUS .)
    INT_CONST       reduce using rule 81 (arith_op -> PLUS .)
    FLOAT_CONST     reduce using rule 81 (arith_op -> PLUS .)
    STRING_CONST    reduce using rule 81 (arith_op -> PLUS .)
    NULL            reduce using rule 81 (arith_op -> PLUS .)
    TRUE            reduce using rule 81 (arith_op -> PLUS .)
    FALSE           reduce using rule 81 (arith_op -> PLUS .)
    ID              reduce using rule 81 (arith_op -> PLUS .)


state 127

    (82) arith_op -> MINUS .

    THIS            reduce using rule 82 (arith_op -> MINUS .)
    SUPER           reduce using rule 82 (arith_op -> MINUS .)
    (               reduce using rule 82 (arith_op -> MINUS .)
    NEW             reduce using rule 82 (arith_op -> MINUS .)
    PLUS            reduce using rule 82 (arith_op -> MINUS .)
    MINUS           reduce using rule 82 (arith_op -> MINUS .)
    NOT             reduce using rule 82 (arith_op -> MINUS .)
    INT_CONST       reduce using rule 82 (arith_op -> MINUS .)
    FLOAT_CONST     reduce using rule 82 (arith_op -> MINUS .)
    STRING_CONST    reduce using rule 82 (arith_op -> MINUS .)
    NULL            reduce using rule 82 (arith_op -> MINUS .)
    TRUE            reduce using rule 82 (arith_op -> MINUS .)
    FALSE           reduce using rule 82 (arith_op -> MINUS .)
    ID              reduce using rule 82 (arith_op -> MINUS .)


state 128

    (83) arith_op -> TIMES .

    THIS            reduce using rule 83 (arith_op -> TIMES .)
    SUPER           reduce using rule 83 (arith_op -> TIMES .)
    (               reduce using rule 83 (arith_op -> TIMES .)
    NEW             reduce using rule 83 (arith_op -> TIMES .)
    PLUS            reduce using rule 83 (arith_op -> TIMES .)
    MINUS           reduce using rule 83 (arith_op -> TIMES .)
    NOT             reduce using rule 83 (arith_op -> TIMES .)
    INT_CONST       reduce using rule 83 (arith_op -> TIMES .)
    FLOAT_CONST     reduce using rule 83 (arith_op -> TIMES .)
    STRING_CONST    reduce using rule 83 (arith_op -> TIMES .)
    NULL            reduce using rule 83 (arith_op -> TIMES .)
    TRUE            reduce using rule 83 (arith_op -> TIMES .)
    FALSE           reduce using rule 83 (arith_op -> TIMES .)
    ID              reduce using rule 83 (arith_op -> TIMES .)


state 129

    (84) arith_op -> DIVIDE .

    THIS            reduce using rule 84 (arith_op -> DIVIDE .)
    SUPER           reduce using rule 84 (arith_op -> DIVIDE .)
    (               reduce using rule 84 (arith_op -> DIVIDE .)
    NEW             reduce using rule 84 (arith_op -> DIVIDE .)
    PLUS            reduce using rule 84 (arith_op -> DIVIDE .)
    MINUS           reduce using rule 84 (arith_op -> DIVIDE .)
    NOT             reduce using rule 84 (arith_op -> DIVIDE .)
    INT_CONST       reduce using rule 84 (arith_op -> DIVIDE .)
    FLOAT_CONST     reduce using rule 84 (arith_op -> DIVIDE .)
    STRING_CONST    reduce using rule 84 (arith_op -> DIVIDE .)
    NULL            reduce using rule 84 (arith_op -> DIVIDE .)
    TRUE            reduce using rule 84 (arith_op -> DIVIDE .)
    FALSE           reduce using rule 84 (arith_op -> DIVIDE .)
    ID              reduce using rule 84 (arith_op -> DIVIDE .)


state 130

    (85) bool_op -> AND .

    THIS            reduce using rule 85 (bool_op -> AND .)
    SUPER           reduce using rule 85 (bool_op -> AND .)
    (               reduce using rule 85 (bool_op -> AND .)
    NEW             reduce using rule 85 (bool_op -> AND .)
    PLUS            reduce using rule 85 (bool_op -> AND .)
    MINUS           reduce using rule 85 (bool_op -> AND .)
    NOT             reduce using rule 85 (bool_op -> AND .)
    INT_CONST       reduce using rule 85 (bool_op -> AND .)
    FLOAT_CONST     reduce using rule 85 (bool_op -> AND .)
    STRING_CONST    reduce using rule 85 (bool_op -> AND .)
    NULL            reduce using rule 85 (bool_op -> AND .)
    TRUE            reduce using rule 85 (bool_op -> AND .)
    FALSE           reduce using rule 85 (bool_op -> AND .)
    ID              reduce using rule 85 (bool_op -> AND .)


state 131

    (86) bool_op -> OR .

    THIS            reduce using rule 86 (bool_op -> OR .)
    SUPER           reduce using rule 86 (bool_op -> OR .)
    (               reduce using rule 86 (bool_op -> OR .)
    NEW             reduce using rule 86 (bool_op -> OR .)
    PLUS            reduce using rule 86 (bool_op -> OR .)
    MINUS           reduce using rule 86 (bool_op -> OR .)
    NOT             reduce using rule 86 (bool_op -> OR .)
    INT_CONST       reduce using rule 86 (bool_op -> OR .)
    FLOAT_CONST     reduce using rule 86 (bool_op -> OR .)
    STRING_CONST    reduce using rule 86 (bool_op -> OR .)
    NULL            reduce using rule 86 (bool_op -> OR .)
    TRUE            reduce using rule 86 (bool_op -> OR .)
    FALSE           reduce using rule 86 (bool_op -> OR .)
    ID              reduce using rule 86 (bool_op -> OR .)


state 132

    (87) bool_op -> EQUALITY .

    THIS            reduce using rule 87 (bool_op -> EQUALITY .)
    SUPER           reduce using rule 87 (bool_op -> EQUALITY .)
    (               reduce using rule 87 (bool_op -> EQUALITY .)
    NEW             reduce using rule 87 (bool_op -> EQUALITY .)
    PLUS            reduce using rule 87 (bool_op -> EQUALITY .)
    MINUS           reduce using rule 87 (bool_op -> EQUALITY .)
    NOT             reduce using rule 87 (bool_op -> EQUALITY .)
    INT_CONST       reduce using rule 87 (bool_op -> EQUALITY .)
    FLOAT_CONST     reduce using rule 87 (bool_op -> EQUALITY .)
    STRING_CONST    reduce using rule 87 (bool_op -> EQUALITY .)
    NULL            reduce using rule 87 (bool_op -> EQUALITY .)
    TRUE            reduce using rule 87 (bool_op -> EQUALITY .)
    FALSE           reduce using rule 87 (bool_op -> EQUALITY .)
    ID              reduce using rule 87 (bool_op -> EQUALITY .)


state 133

    (88) bool_op -> INEQUALITY .

    THIS            reduce using rule 88 (bool_op -> INEQUALITY .)
    SUPER           reduce using rule 88 (bool_op -> INEQUALITY .)
    (               reduce using rule 88 (bool_op -> INEQUALITY .)
    NEW             reduce using rule 88 (bool_op -> INEQUALITY .)
    PLUS            reduce using rule 88 (bool_op -> INEQUALITY .)
    MINUS           reduce using rule 88 (bool_op -> INEQUALITY .)
    NOT             reduce using rule 88 (bool_op -> INEQUALITY .)
    INT_CONST       reduce using rule 88 (bool_op -> INEQUALITY .)
    FLOAT_CONST     reduce using rule 88 (bool_op -> INEQUALITY .)
    STRING_CONST    reduce using rule 88 (bool_op -> INEQUALITY .)
    NULL            reduce using rule 88 (bool_op -> INEQUALITY .)
    TRUE            reduce using rule 88 (bool_op -> INEQUALITY .)
    FALSE           reduce using rule 88 (bool_op -> INEQUALITY .)
    ID              reduce using rule 88 (bool_op -> INEQUALITY .)


state 134

    (89) bool_op -> LESSER .

    THIS            reduce using rule 89 (bool_op -> LESSER .)
    SUPER           reduce using rule 89 (bool_op -> LESSER .)
    (               reduce using rule 89 (bool_op -> LESSER .)
    NEW             reduce using rule 89 (bool_op -> LESSER .)
    PLUS            reduce using rule 89 (bool_op -> LESSER .)
    MINUS           reduce using rule 89 (bool_op -> LESSER .)
    NOT             reduce using rule 89 (bool_op -> LESSER .)
    INT_CONST       reduce using rule 89 (bool_op -> LESSER .)
    FLOAT_CONST     reduce using rule 89 (bool_op -> LESSER .)
    STRING_CONST    reduce using rule 89 (bool_op -> LESSER .)
    NULL            reduce using rule 89 (bool_op -> LESSER .)
    TRUE            reduce using rule 89 (bool_op -> LESSER .)
    FALSE           reduce using rule 89 (bool_op -> LESSER .)
    ID              reduce using rule 89 (bool_op -> LESSER .)


state 135

    (90) bool_op -> GREATER .

    THIS            reduce using rule 90 (bool_op -> GREATER .)
    SUPER           reduce using rule 90 (bool_op -> GREATER .)
    (               reduce using rule 90 (bool_op -> GREATER .)
    NEW             reduce using rule 90 (bool_op -> GREATER .)
    PLUS            reduce using rule 90 (bool_op -> GREATER .)
    MINUS           reduce using rule 90 (bool_op -> GREATER .)
    NOT             reduce using rule 90 (bool_op -> GREATER .)
    INT_CONST       reduce using rule 90 (bool_op -> GREATER .)
    FLOAT_CONST     reduce using rule 90 (bool_op -> GREATER .)
    STRING_CONST    reduce using rule 90 (bool_op -> GREATER .)
    NULL            reduce using rule 90 (bool_op -> GREATER .)
    TRUE            reduce using rule 90 (bool_op -> GREATER .)
    FALSE           reduce using rule 90 (bool_op -> GREATER .)
    ID              reduce using rule 90 (bool_op -> GREATER .)


state 136

    (91) bool_op -> LEQ .

    THIS            reduce using rule 91 (bool_op -> LEQ .)
    SUPER           reduce using rule 91 (bool_op -> LEQ .)
    (               reduce using rule 91 (bool_op -> LEQ .)
    NEW             reduce using rule 91 (bool_op -> LEQ .)
    PLUS            reduce using rule 91 (bool_op -> LEQ .)
    MINUS           reduce using rule 91 (bool_op -> LEQ .)
    NOT             reduce using rule 91 (bool_op -> LEQ .)
    INT_CONST       reduce using rule 91 (bool_op -> LEQ .)
    FLOAT_CONST     reduce using rule 91 (bool_op -> LEQ .)
    STRING_CONST    reduce using rule 91 (bool_op -> LEQ .)
    NULL            reduce using rule 91 (bool_op -> LEQ .)
    TRUE            reduce using rule 91 (bool_op -> LEQ .)
    FALSE           reduce using rule 91 (bool_op -> LEQ .)
    ID              reduce using rule 91 (bool_op -> LEQ .)


state 137

    (92) bool_op -> GEQ .

    THIS            reduce using rule 92 (bool_op -> GEQ .)
    SUPER           reduce using rule 92 (bool_op -> GEQ .)
    (               reduce using rule 92 (bool_op -> GEQ .)
    NEW             reduce using rule 92 (bool_op -> GEQ .)
    PLUS            reduce using rule 92 (bool_op -> GEQ .)
    MINUS           reduce using rule 92 (bool_op -> GEQ .)
    NOT             reduce using rule 92 (bool_op -> GEQ .)
    INT_CONST       reduce using rule 92 (bool_op -> GEQ .)
    FLOAT_CONST     reduce using rule 92 (bool_op -> GEQ .)
    STRING_CONST    reduce using rule 92 (bool_op -> GEQ .)
    NULL            reduce using rule 92 (bool_op -> GEQ .)
    TRUE            reduce using rule 92 (bool_op -> GEQ .)
    FALSE           reduce using rule 92 (bool_op -> GEQ .)
    ID              reduce using rule 92 (bool_op -> GEQ .)


state 138

    (75) expr -> unary_op expr .
    (73) expr -> expr . arith_op expr
    (74) expr -> expr . bool_op expr
    (81) arith_op -> . PLUS
    (82) arith_op -> . MINUS
    (83) arith_op -> . TIMES
    (84) arith_op -> . DIVIDE
    (85) bool_op -> . AND
    (86) bool_op -> . OR
    (87) bool_op -> . EQUALITY
    (88) bool_op -> . INEQUALITY
    (89) bool_op -> . LESSER
    (90) bool_op -> . GREATER
    (91) bool_op -> . LEQ
    (92) bool_op -> . GEQ

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQUALITY resolved as shift
  ! shift/reduce conflict for INEQUALITY resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
    )               reduce using rule 75 (expr -> unary_op expr .)
    ;               reduce using rule 75 (expr -> unary_op expr .)
    ,               reduce using rule 75 (expr -> unary_op expr .)
    PLUS            shift and go to state 126
    MINUS           shift and go to state 127
    TIMES           shift and go to state 128
    DIVIDE          shift and go to state 129
    AND             shift and go to state 130
    OR              shift and go to state 131
    EQUALITY        shift and go to state 132
    INEQUALITY      shift and go to state 133
    LESSER          shift and go to state 134
    GREATER         shift and go to state 135
    LEQ             shift and go to state 136
    GEQ             shift and go to state 137

  ! PLUS            [ reduce using rule 75 (expr -> unary_op expr .) ]
  ! MINUS           [ reduce using rule 75 (expr -> unary_op expr .) ]
  ! TIMES           [ reduce using rule 75 (expr -> unary_op expr .) ]
  ! DIVIDE          [ reduce using rule 75 (expr -> unary_op expr .) ]
  ! AND             [ reduce using rule 75 (expr -> unary_op expr .) ]
  ! OR              [ reduce using rule 75 (expr -> unary_op expr .) ]
  ! EQUALITY        [ reduce using rule 75 (expr -> unary_op expr .) ]
  ! INEQUALITY      [ reduce using rule 75 (expr -> unary_op expr .) ]
  ! LESSER          [ reduce using rule 75 (expr -> unary_op expr .) ]
  ! GREATER         [ reduce using rule 75 (expr -> unary_op expr .) ]
  ! LEQ             [ reduce using rule 75 (expr -> unary_op expr .) ]
  ! GEQ             [ reduce using rule 75 (expr -> unary_op expr .) ]

    arith_op                       shift and go to state 124
    bool_op                        shift and go to state 125

state 139

    (38) stmt -> WHILE ( expr . ) stmt
    (73) expr -> expr . arith_op expr
    (74) expr -> expr . bool_op expr
    (81) arith_op -> . PLUS
    (82) arith_op -> . MINUS
    (83) arith_op -> . TIMES
    (84) arith_op -> . DIVIDE
    (85) bool_op -> . AND
    (86) bool_op -> . OR
    (87) bool_op -> . EQUALITY
    (88) bool_op -> . INEQUALITY
    (89) bool_op -> . LESSER
    (90) bool_op -> . GREATER
    (91) bool_op -> . LEQ
    (92) bool_op -> . GEQ

    )               shift and go to state 157
    PLUS            shift and go to state 126
    MINUS           shift and go to state 127
    TIMES           shift and go to state 128
    DIVIDE          shift and go to state 129
    AND             shift and go to state 130
    OR              shift and go to state 131
    EQUALITY        shift and go to state 132
    INEQUALITY      shift and go to state 133
    LESSER          shift and go to state 134
    GREATER         shift and go to state 135
    LEQ             shift and go to state 136
    GEQ             shift and go to state 137

    arith_op                       shift and go to state 124
    bool_op                        shift and go to state 125

state 140

    (39) stmt -> FOR ( optional_stmt_expr . ; optional_expr ; optional_stmt_expr ) stmt

    ;               shift and go to state 158


state 141

    (49) optional_stmt_expr -> stmt_expr .

    ;               reduce using rule 49 (optional_stmt_expr -> stmt_expr .)
    )               reduce using rule 49 (optional_stmt_expr -> stmt_expr .)


state 142

    (50) optional_stmt_expr -> empty .

    ;               reduce using rule 50 (optional_stmt_expr -> empty .)
    )               reduce using rule 50 (optional_stmt_expr -> empty .)


state 143

    (40) stmt -> RETURN optional_expr ; .

    }               reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    IF              reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    WHILE           reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    FOR             reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    RETURN          reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    BREAK           reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    CONTINUE        reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    ;               reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    {               reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    PLUS            reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    MINUS           reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    INT             reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    FLOAT           reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    BOOLEAN         reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    ID              reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    THIS            reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    SUPER           reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    (               reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    NEW             reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    INT_CONST       reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    FLOAT_CONST     reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    STRING_CONST    reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    NULL            reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    TRUE            reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    FALSE           reduce using rule 40 (stmt -> RETURN optional_expr ; .)
    ELSE            reduce using rule 40 (stmt -> RETURN optional_expr ; .)


state 144

    (76) assign -> field_access ASSIGN expr .
    (73) expr -> expr . arith_op expr
    (74) expr -> expr . bool_op expr
    (81) arith_op -> . PLUS
    (82) arith_op -> . MINUS
    (83) arith_op -> . TIMES
    (84) arith_op -> . DIVIDE
    (85) bool_op -> . AND
    (86) bool_op -> . OR
    (87) bool_op -> . EQUALITY
    (88) bool_op -> . INEQUALITY
    (89) bool_op -> . LESSER
    (90) bool_op -> . GREATER
    (91) bool_op -> . LEQ
    (92) bool_op -> . GEQ

    ;               reduce using rule 76 (assign -> field_access ASSIGN expr .)
    )               reduce using rule 76 (assign -> field_access ASSIGN expr .)
    ,               reduce using rule 76 (assign -> field_access ASSIGN expr .)
    PLUS            shift and go to state 126
    MINUS           shift and go to state 127
    TIMES           shift and go to state 128
    DIVIDE          shift and go to state 129
    AND             shift and go to state 130
    OR              shift and go to state 131
    EQUALITY        shift and go to state 132
    INEQUALITY      shift and go to state 133
    LESSER          shift and go to state 134
    GREATER         shift and go to state 135
    LEQ             shift and go to state 136
    GEQ             shift and go to state 137

  ! PLUS            [ reduce using rule 76 (assign -> field_access ASSIGN expr .) ]
  ! MINUS           [ reduce using rule 76 (assign -> field_access ASSIGN expr .) ]
  ! TIMES           [ reduce using rule 76 (assign -> field_access ASSIGN expr .) ]
  ! DIVIDE          [ reduce using rule 76 (assign -> field_access ASSIGN expr .) ]
  ! AND             [ reduce using rule 76 (assign -> field_access ASSIGN expr .) ]
  ! OR              [ reduce using rule 76 (assign -> field_access ASSIGN expr .) ]
  ! EQUALITY        [ reduce using rule 76 (assign -> field_access ASSIGN expr .) ]
  ! INEQUALITY      [ reduce using rule 76 (assign -> field_access ASSIGN expr .) ]
  ! LESSER          [ reduce using rule 76 (assign -> field_access ASSIGN expr .) ]
  ! GREATER         [ reduce using rule 76 (assign -> field_access ASSIGN expr .) ]
  ! LEQ             [ reduce using rule 76 (assign -> field_access ASSIGN expr .) ]
  ! GEQ             [ reduce using rule 76 (assign -> field_access ASSIGN expr .) ]

    arith_op                       shift and go to state 124
    bool_op                        shift and go to state 125

state 145

    (77) assign -> field_access PLUS PLUS .

    ;               reduce using rule 77 (assign -> field_access PLUS PLUS .)
    )               reduce using rule 77 (assign -> field_access PLUS PLUS .)
    PLUS            reduce using rule 77 (assign -> field_access PLUS PLUS .)
    MINUS           reduce using rule 77 (assign -> field_access PLUS PLUS .)
    TIMES           reduce using rule 77 (assign -> field_access PLUS PLUS .)
    DIVIDE          reduce using rule 77 (assign -> field_access PLUS PLUS .)
    AND             reduce using rule 77 (assign -> field_access PLUS PLUS .)
    OR              reduce using rule 77 (assign -> field_access PLUS PLUS .)
    EQUALITY        reduce using rule 77 (assign -> field_access PLUS PLUS .)
    INEQUALITY      reduce using rule 77 (assign -> field_access PLUS PLUS .)
    LESSER          reduce using rule 77 (assign -> field_access PLUS PLUS .)
    GREATER         reduce using rule 77 (assign -> field_access PLUS PLUS .)
    LEQ             reduce using rule 77 (assign -> field_access PLUS PLUS .)
    GEQ             reduce using rule 77 (assign -> field_access PLUS PLUS .)
    ,               reduce using rule 77 (assign -> field_access PLUS PLUS .)


state 146

    (79) assign -> field_access MINUS MINUS .

    ;               reduce using rule 79 (assign -> field_access MINUS MINUS .)
    )               reduce using rule 79 (assign -> field_access MINUS MINUS .)
    PLUS            reduce using rule 79 (assign -> field_access MINUS MINUS .)
    MINUS           reduce using rule 79 (assign -> field_access MINUS MINUS .)
    TIMES           reduce using rule 79 (assign -> field_access MINUS MINUS .)
    DIVIDE          reduce using rule 79 (assign -> field_access MINUS MINUS .)
    AND             reduce using rule 79 (assign -> field_access MINUS MINUS .)
    OR              reduce using rule 79 (assign -> field_access MINUS MINUS .)
    EQUALITY        reduce using rule 79 (assign -> field_access MINUS MINUS .)
    INEQUALITY      reduce using rule 79 (assign -> field_access MINUS MINUS .)
    LESSER          reduce using rule 79 (assign -> field_access MINUS MINUS .)
    GREATER         reduce using rule 79 (assign -> field_access MINUS MINUS .)
    LEQ             reduce using rule 79 (assign -> field_access MINUS MINUS .)
    GEQ             reduce using rule 79 (assign -> field_access MINUS MINUS .)
    ,               reduce using rule 79 (assign -> field_access MINUS MINUS .)


state 147

    (69) method_invocation -> field_access ( arguments . )

    )               shift and go to state 159


state 148

    (70) method_invocation -> field_access ( ) .

    ;               reduce using rule 70 (method_invocation -> field_access ( ) .)
    .               reduce using rule 70 (method_invocation -> field_access ( ) .)
    )               reduce using rule 70 (method_invocation -> field_access ( ) .)
    PLUS            reduce using rule 70 (method_invocation -> field_access ( ) .)
    MINUS           reduce using rule 70 (method_invocation -> field_access ( ) .)
    TIMES           reduce using rule 70 (method_invocation -> field_access ( ) .)
    DIVIDE          reduce using rule 70 (method_invocation -> field_access ( ) .)
    AND             reduce using rule 70 (method_invocation -> field_access ( ) .)
    OR              reduce using rule 70 (method_invocation -> field_access ( ) .)
    EQUALITY        reduce using rule 70 (method_invocation -> field_access ( ) .)
    INEQUALITY      reduce using rule 70 (method_invocation -> field_access ( ) .)
    LESSER          reduce using rule 70 (method_invocation -> field_access ( ) .)
    GREATER         reduce using rule 70 (method_invocation -> field_access ( ) .)
    LEQ             reduce using rule 70 (method_invocation -> field_access ( ) .)
    GEQ             reduce using rule 70 (method_invocation -> field_access ( ) .)
    ,               reduce using rule 70 (method_invocation -> field_access ( ) .)


state 149

    (65) arguments -> expr .
    (66) arguments -> expr . , arguments
    (73) expr -> expr . arith_op expr
    (74) expr -> expr . bool_op expr
    (81) arith_op -> . PLUS
    (82) arith_op -> . MINUS
    (83) arith_op -> . TIMES
    (84) arith_op -> . DIVIDE
    (85) bool_op -> . AND
    (86) bool_op -> . OR
    (87) bool_op -> . EQUALITY
    (88) bool_op -> . INEQUALITY
    (89) bool_op -> . LESSER
    (90) bool_op -> . GREATER
    (91) bool_op -> . LEQ
    (92) bool_op -> . GEQ

    )               reduce using rule 65 (arguments -> expr .)
    ,               shift and go to state 160
    PLUS            shift and go to state 126
    MINUS           shift and go to state 127
    TIMES           shift and go to state 128
    DIVIDE          shift and go to state 129
    AND             shift and go to state 130
    OR              shift and go to state 131
    EQUALITY        shift and go to state 132
    INEQUALITY      shift and go to state 133
    LESSER          shift and go to state 134
    GREATER         shift and go to state 135
    LEQ             shift and go to state 136
    GEQ             shift and go to state 137

    arith_op                       shift and go to state 124
    bool_op                        shift and go to state 125

state 150

    (78) assign -> PLUS PLUS field_access .
    (63) primary -> field_access .
    (69) method_invocation -> field_access . ( arguments )
    (70) method_invocation -> field_access . ( )

    ;               reduce using rule 78 (assign -> PLUS PLUS field_access .)
    )               reduce using rule 78 (assign -> PLUS PLUS field_access .)
    PLUS            reduce using rule 78 (assign -> PLUS PLUS field_access .)
    MINUS           reduce using rule 78 (assign -> PLUS PLUS field_access .)
    TIMES           reduce using rule 78 (assign -> PLUS PLUS field_access .)
    DIVIDE          reduce using rule 78 (assign -> PLUS PLUS field_access .)
    AND             reduce using rule 78 (assign -> PLUS PLUS field_access .)
    OR              reduce using rule 78 (assign -> PLUS PLUS field_access .)
    EQUALITY        reduce using rule 78 (assign -> PLUS PLUS field_access .)
    INEQUALITY      reduce using rule 78 (assign -> PLUS PLUS field_access .)
    LESSER          reduce using rule 78 (assign -> PLUS PLUS field_access .)
    GREATER         reduce using rule 78 (assign -> PLUS PLUS field_access .)
    LEQ             reduce using rule 78 (assign -> PLUS PLUS field_access .)
    GEQ             reduce using rule 78 (assign -> PLUS PLUS field_access .)
    ,               reduce using rule 78 (assign -> PLUS PLUS field_access .)
    .               reduce using rule 63 (primary -> field_access .)
    (               shift and go to state 117


state 151

    (80) assign -> MINUS MINUS field_access .
    (63) primary -> field_access .
    (69) method_invocation -> field_access . ( arguments )
    (70) method_invocation -> field_access . ( )

    ;               reduce using rule 80 (assign -> MINUS MINUS field_access .)
    )               reduce using rule 80 (assign -> MINUS MINUS field_access .)
    PLUS            reduce using rule 80 (assign -> MINUS MINUS field_access .)
    MINUS           reduce using rule 80 (assign -> MINUS MINUS field_access .)
    TIMES           reduce using rule 80 (assign -> MINUS MINUS field_access .)
    DIVIDE          reduce using rule 80 (assign -> MINUS MINUS field_access .)
    AND             reduce using rule 80 (assign -> MINUS MINUS field_access .)
    OR              reduce using rule 80 (assign -> MINUS MINUS field_access .)
    EQUALITY        reduce using rule 80 (assign -> MINUS MINUS field_access .)
    INEQUALITY      reduce using rule 80 (assign -> MINUS MINUS field_access .)
    LESSER          reduce using rule 80 (assign -> MINUS MINUS field_access .)
    GREATER         reduce using rule 80 (assign -> MINUS MINUS field_access .)
    LEQ             reduce using rule 80 (assign -> MINUS MINUS field_access .)
    GEQ             reduce using rule 80 (assign -> MINUS MINUS field_access .)
    ,               reduce using rule 80 (assign -> MINUS MINUS field_access .)
    .               reduce using rule 63 (primary -> field_access .)
    (               shift and go to state 117


state 152

    (67) field_access -> primary . ID .

    ASSIGN          reduce using rule 67 (field_access -> primary . ID .)
    PLUS            reduce using rule 67 (field_access -> primary . ID .)
    MINUS           reduce using rule 67 (field_access -> primary . ID .)
    (               reduce using rule 67 (field_access -> primary . ID .)
    .               reduce using rule 67 (field_access -> primary . ID .)
    )               reduce using rule 67 (field_access -> primary . ID .)
    TIMES           reduce using rule 67 (field_access -> primary . ID .)
    DIVIDE          reduce using rule 67 (field_access -> primary . ID .)
    AND             reduce using rule 67 (field_access -> primary . ID .)
    OR              reduce using rule 67 (field_access -> primary . ID .)
    EQUALITY        reduce using rule 67 (field_access -> primary . ID .)
    INEQUALITY      reduce using rule 67 (field_access -> primary . ID .)
    LESSER          reduce using rule 67 (field_access -> primary . ID .)
    GREATER         reduce using rule 67 (field_access -> primary . ID .)
    LEQ             reduce using rule 67 (field_access -> primary . ID .)
    GEQ             reduce using rule 67 (field_access -> primary . ID .)
    ;               reduce using rule 67 (field_access -> primary . ID .)
    ,               reduce using rule 67 (field_access -> primary . ID .)


state 153

    (61) primary -> NEW ID ( . arguments )
    (62) primary -> NEW ID ( . )
    (65) arguments -> . expr
    (66) arguments -> . expr , arguments
    (71) expr -> . primary
    (72) expr -> . assign
    (73) expr -> . expr arith_op expr
    (74) expr -> . expr bool_op expr
    (75) expr -> . unary_op expr
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (93) unary_op -> . PLUS
    (94) unary_op -> . MINUS
    (95) unary_op -> . NOT
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )

    )               shift and go to state 162
    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    PLUS            shift and go to state 103
    MINUS           shift and go to state 104
    NOT             shift and go to state 105
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91
    ID              shift and go to state 100

    arguments                      shift and go to state 161
    expr                           shift and go to state 149
    primary                        shift and go to state 97
    assign                         shift and go to state 98
    unary_op                       shift and go to state 99
    literal                        shift and go to state 82
    field_access                   shift and go to state 101
    method_invocation              shift and go to state 102

state 154

    (36) stmt -> IF ( expr ) . stmt ELSE stmt
    (37) stmt -> IF ( expr ) . stmt
    (35) stmt -> . stmt stmt
    (36) stmt -> . IF ( expr ) stmt ELSE stmt
    (37) stmt -> . IF ( expr ) stmt
    (38) stmt -> . WHILE ( expr ) stmt
    (39) stmt -> . FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (40) stmt -> . RETURN optional_expr ;
    (41) stmt -> . stmt_expr ;
    (42) stmt -> . BREAK ;
    (43) stmt -> . CONTINUE ;
    (44) stmt -> . block
    (45) stmt -> . var_decl
    (46) stmt -> . ;
    (96) stmt_expr -> . assign
    (97) stmt_expr -> . method_invocation
    (33) block -> . { stmt }
    (34) block -> . { }
    (17) var_decl -> . type variables ;
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE

    IF              shift and go to state 63
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    RETURN          shift and go to state 68
    BREAK           shift and go to state 70
    CONTINUE        shift and go to state 71
    ;               shift and go to state 67
    {               shift and go to state 57
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 80
    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91

    stmt                           shift and go to state 163
    stmt_expr                      shift and go to state 69
    block                          shift and go to state 72
    var_decl                       shift and go to state 73
    assign                         shift and go to state 74
    method_invocation              shift and go to state 75
    type                           shift and go to state 76
    field_access                   shift and go to state 77
    primary                        shift and go to state 81
    literal                        shift and go to state 82

state 155

    (73) expr -> expr arith_op expr .
    (73) expr -> expr . arith_op expr
    (74) expr -> expr . bool_op expr
    (81) arith_op -> . PLUS
    (82) arith_op -> . MINUS
    (83) arith_op -> . TIMES
    (84) arith_op -> . DIVIDE
    (85) bool_op -> . AND
    (86) bool_op -> . OR
    (87) bool_op -> . EQUALITY
    (88) bool_op -> . INEQUALITY
    (89) bool_op -> . LESSER
    (90) bool_op -> . GREATER
    (91) bool_op -> . LEQ
    (92) bool_op -> . GEQ

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQUALITY resolved as shift
  ! shift/reduce conflict for INEQUALITY resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
    )               reduce using rule 73 (expr -> expr arith_op expr .)
    ;               reduce using rule 73 (expr -> expr arith_op expr .)
    ,               reduce using rule 73 (expr -> expr arith_op expr .)
    PLUS            shift and go to state 126
    MINUS           shift and go to state 127
    TIMES           shift and go to state 128
    DIVIDE          shift and go to state 129
    AND             shift and go to state 130
    OR              shift and go to state 131
    EQUALITY        shift and go to state 132
    INEQUALITY      shift and go to state 133
    LESSER          shift and go to state 134
    GREATER         shift and go to state 135
    LEQ             shift and go to state 136
    GEQ             shift and go to state 137

  ! PLUS            [ reduce using rule 73 (expr -> expr arith_op expr .) ]
  ! MINUS           [ reduce using rule 73 (expr -> expr arith_op expr .) ]
  ! TIMES           [ reduce using rule 73 (expr -> expr arith_op expr .) ]
  ! DIVIDE          [ reduce using rule 73 (expr -> expr arith_op expr .) ]
  ! AND             [ reduce using rule 73 (expr -> expr arith_op expr .) ]
  ! OR              [ reduce using rule 73 (expr -> expr arith_op expr .) ]
  ! EQUALITY        [ reduce using rule 73 (expr -> expr arith_op expr .) ]
  ! INEQUALITY      [ reduce using rule 73 (expr -> expr arith_op expr .) ]
  ! LESSER          [ reduce using rule 73 (expr -> expr arith_op expr .) ]
  ! GREATER         [ reduce using rule 73 (expr -> expr arith_op expr .) ]
  ! LEQ             [ reduce using rule 73 (expr -> expr arith_op expr .) ]
  ! GEQ             [ reduce using rule 73 (expr -> expr arith_op expr .) ]

    arith_op                       shift and go to state 124
    bool_op                        shift and go to state 125

state 156

    (74) expr -> expr bool_op expr .
    (73) expr -> expr . arith_op expr
    (74) expr -> expr . bool_op expr
    (81) arith_op -> . PLUS
    (82) arith_op -> . MINUS
    (83) arith_op -> . TIMES
    (84) arith_op -> . DIVIDE
    (85) bool_op -> . AND
    (86) bool_op -> . OR
    (87) bool_op -> . EQUALITY
    (88) bool_op -> . INEQUALITY
    (89) bool_op -> . LESSER
    (90) bool_op -> . GREATER
    (91) bool_op -> . LEQ
    (92) bool_op -> . GEQ

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQUALITY resolved as shift
  ! shift/reduce conflict for INEQUALITY resolved as shift
  ! shift/reduce conflict for LESSER resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
    )               reduce using rule 74 (expr -> expr bool_op expr .)
    ;               reduce using rule 74 (expr -> expr bool_op expr .)
    ,               reduce using rule 74 (expr -> expr bool_op expr .)
    PLUS            shift and go to state 126
    MINUS           shift and go to state 127
    TIMES           shift and go to state 128
    DIVIDE          shift and go to state 129
    AND             shift and go to state 130
    OR              shift and go to state 131
    EQUALITY        shift and go to state 132
    INEQUALITY      shift and go to state 133
    LESSER          shift and go to state 134
    GREATER         shift and go to state 135
    LEQ             shift and go to state 136
    GEQ             shift and go to state 137

  ! PLUS            [ reduce using rule 74 (expr -> expr bool_op expr .) ]
  ! MINUS           [ reduce using rule 74 (expr -> expr bool_op expr .) ]
  ! TIMES           [ reduce using rule 74 (expr -> expr bool_op expr .) ]
  ! DIVIDE          [ reduce using rule 74 (expr -> expr bool_op expr .) ]
  ! AND             [ reduce using rule 74 (expr -> expr bool_op expr .) ]
  ! OR              [ reduce using rule 74 (expr -> expr bool_op expr .) ]
  ! EQUALITY        [ reduce using rule 74 (expr -> expr bool_op expr .) ]
  ! INEQUALITY      [ reduce using rule 74 (expr -> expr bool_op expr .) ]
  ! LESSER          [ reduce using rule 74 (expr -> expr bool_op expr .) ]
  ! GREATER         [ reduce using rule 74 (expr -> expr bool_op expr .) ]
  ! LEQ             [ reduce using rule 74 (expr -> expr bool_op expr .) ]
  ! GEQ             [ reduce using rule 74 (expr -> expr bool_op expr .) ]

    bool_op                        shift and go to state 125
    arith_op                       shift and go to state 124

state 157

    (38) stmt -> WHILE ( expr ) . stmt
    (35) stmt -> . stmt stmt
    (36) stmt -> . IF ( expr ) stmt ELSE stmt
    (37) stmt -> . IF ( expr ) stmt
    (38) stmt -> . WHILE ( expr ) stmt
    (39) stmt -> . FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (40) stmt -> . RETURN optional_expr ;
    (41) stmt -> . stmt_expr ;
    (42) stmt -> . BREAK ;
    (43) stmt -> . CONTINUE ;
    (44) stmt -> . block
    (45) stmt -> . var_decl
    (46) stmt -> . ;
    (96) stmt_expr -> . assign
    (97) stmt_expr -> . method_invocation
    (33) block -> . { stmt }
    (34) block -> . { }
    (17) var_decl -> . type variables ;
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE

    IF              shift and go to state 63
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    RETURN          shift and go to state 68
    BREAK           shift and go to state 70
    CONTINUE        shift and go to state 71
    ;               shift and go to state 67
    {               shift and go to state 57
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 80
    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91

    stmt                           shift and go to state 164
    stmt_expr                      shift and go to state 69
    block                          shift and go to state 72
    var_decl                       shift and go to state 73
    assign                         shift and go to state 74
    method_invocation              shift and go to state 75
    type                           shift and go to state 76
    field_access                   shift and go to state 77
    primary                        shift and go to state 81
    literal                        shift and go to state 82

state 158

    (39) stmt -> FOR ( optional_stmt_expr ; . optional_expr ; optional_stmt_expr ) stmt
    (47) optional_expr -> . expr
    (48) optional_expr -> . empty
    (71) expr -> . primary
    (72) expr -> . assign
    (73) expr -> . expr arith_op expr
    (74) expr -> . expr bool_op expr
    (75) expr -> . unary_op expr
    (98) empty -> .
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (93) unary_op -> . PLUS
    (94) unary_op -> . MINUS
    (95) unary_op -> . NOT
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )

    ;               reduce using rule 98 (empty -> .)
    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    PLUS            shift and go to state 103
    MINUS           shift and go to state 104
    NOT             shift and go to state 105
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91
    ID              shift and go to state 100

    optional_expr                  shift and go to state 165
    expr                           shift and go to state 109
    empty                          shift and go to state 110
    primary                        shift and go to state 97
    assign                         shift and go to state 98
    unary_op                       shift and go to state 99
    literal                        shift and go to state 82
    field_access                   shift and go to state 101
    method_invocation              shift and go to state 102

state 159

    (69) method_invocation -> field_access ( arguments ) .

    ;               reduce using rule 69 (method_invocation -> field_access ( arguments ) .)
    .               reduce using rule 69 (method_invocation -> field_access ( arguments ) .)
    )               reduce using rule 69 (method_invocation -> field_access ( arguments ) .)
    PLUS            reduce using rule 69 (method_invocation -> field_access ( arguments ) .)
    MINUS           reduce using rule 69 (method_invocation -> field_access ( arguments ) .)
    TIMES           reduce using rule 69 (method_invocation -> field_access ( arguments ) .)
    DIVIDE          reduce using rule 69 (method_invocation -> field_access ( arguments ) .)
    AND             reduce using rule 69 (method_invocation -> field_access ( arguments ) .)
    OR              reduce using rule 69 (method_invocation -> field_access ( arguments ) .)
    EQUALITY        reduce using rule 69 (method_invocation -> field_access ( arguments ) .)
    INEQUALITY      reduce using rule 69 (method_invocation -> field_access ( arguments ) .)
    LESSER          reduce using rule 69 (method_invocation -> field_access ( arguments ) .)
    GREATER         reduce using rule 69 (method_invocation -> field_access ( arguments ) .)
    LEQ             reduce using rule 69 (method_invocation -> field_access ( arguments ) .)
    GEQ             reduce using rule 69 (method_invocation -> field_access ( arguments ) .)
    ,               reduce using rule 69 (method_invocation -> field_access ( arguments ) .)


state 160

    (66) arguments -> expr , . arguments
    (65) arguments -> . expr
    (66) arguments -> . expr , arguments
    (71) expr -> . primary
    (72) expr -> . assign
    (73) expr -> . expr arith_op expr
    (74) expr -> . expr bool_op expr
    (75) expr -> . unary_op expr
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (93) unary_op -> . PLUS
    (94) unary_op -> . MINUS
    (95) unary_op -> . NOT
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )

    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    PLUS            shift and go to state 103
    MINUS           shift and go to state 104
    NOT             shift and go to state 105
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91
    ID              shift and go to state 100

    expr                           shift and go to state 149
    arguments                      shift and go to state 166
    primary                        shift and go to state 97
    assign                         shift and go to state 98
    unary_op                       shift and go to state 99
    literal                        shift and go to state 82
    field_access                   shift and go to state 101
    method_invocation              shift and go to state 102

state 161

    (61) primary -> NEW ID ( arguments . )

    )               shift and go to state 167


state 162

    (62) primary -> NEW ID ( ) .

    .               reduce using rule 62 (primary -> NEW ID ( ) .)
    )               reduce using rule 62 (primary -> NEW ID ( ) .)
    PLUS            reduce using rule 62 (primary -> NEW ID ( ) .)
    MINUS           reduce using rule 62 (primary -> NEW ID ( ) .)
    TIMES           reduce using rule 62 (primary -> NEW ID ( ) .)
    DIVIDE          reduce using rule 62 (primary -> NEW ID ( ) .)
    AND             reduce using rule 62 (primary -> NEW ID ( ) .)
    OR              reduce using rule 62 (primary -> NEW ID ( ) .)
    EQUALITY        reduce using rule 62 (primary -> NEW ID ( ) .)
    INEQUALITY      reduce using rule 62 (primary -> NEW ID ( ) .)
    LESSER          reduce using rule 62 (primary -> NEW ID ( ) .)
    GREATER         reduce using rule 62 (primary -> NEW ID ( ) .)
    LEQ             reduce using rule 62 (primary -> NEW ID ( ) .)
    GEQ             reduce using rule 62 (primary -> NEW ID ( ) .)
    ;               reduce using rule 62 (primary -> NEW ID ( ) .)
    ,               reduce using rule 62 (primary -> NEW ID ( ) .)


state 163

    (36) stmt -> IF ( expr ) stmt . ELSE stmt
    (37) stmt -> IF ( expr ) stmt .
    (35) stmt -> stmt . stmt
    (35) stmt -> . stmt stmt
    (36) stmt -> . IF ( expr ) stmt ELSE stmt
    (37) stmt -> . IF ( expr ) stmt
    (38) stmt -> . WHILE ( expr ) stmt
    (39) stmt -> . FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (40) stmt -> . RETURN optional_expr ;
    (41) stmt -> . stmt_expr ;
    (42) stmt -> . BREAK ;
    (43) stmt -> . CONTINUE ;
    (44) stmt -> . block
    (45) stmt -> . var_decl
    (46) stmt -> . ;
    (96) stmt_expr -> . assign
    (97) stmt_expr -> . method_invocation
    (33) block -> . { stmt }
    (34) block -> . { }
    (17) var_decl -> . type variables ;
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INT_CONST resolved as shift
  ! shift/reduce conflict for FLOAT_CONST resolved as shift
  ! shift/reduce conflict for STRING_CONST resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    ELSE            shift and go to state 168
    }               reduce using rule 37 (stmt -> IF ( expr ) stmt .)
    IF              shift and go to state 63
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    RETURN          shift and go to state 68
    BREAK           shift and go to state 70
    CONTINUE        shift and go to state 71
    ;               shift and go to state 67
    {               shift and go to state 57
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 80
    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91

  ! IF              [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! WHILE           [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! FOR             [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! RETURN          [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! BREAK           [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! CONTINUE        [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! ;               [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! {               [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! PLUS            [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! MINUS           [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! INT             [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! FLOAT           [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! BOOLEAN         [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! ID              [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! THIS            [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! SUPER           [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! (               [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! NEW             [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! INT_CONST       [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! FLOAT_CONST     [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! STRING_CONST    [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! NULL            [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! TRUE            [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! FALSE           [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]
  ! ELSE            [ reduce using rule 37 (stmt -> IF ( expr ) stmt .) ]

    stmt                           shift and go to state 93
    stmt_expr                      shift and go to state 69
    block                          shift and go to state 72
    var_decl                       shift and go to state 73
    assign                         shift and go to state 74
    method_invocation              shift and go to state 75
    type                           shift and go to state 76
    field_access                   shift and go to state 77
    primary                        shift and go to state 81
    literal                        shift and go to state 82

state 164

    (38) stmt -> WHILE ( expr ) stmt .
    (35) stmt -> stmt . stmt
    (35) stmt -> . stmt stmt
    (36) stmt -> . IF ( expr ) stmt ELSE stmt
    (37) stmt -> . IF ( expr ) stmt
    (38) stmt -> . WHILE ( expr ) stmt
    (39) stmt -> . FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (40) stmt -> . RETURN optional_expr ;
    (41) stmt -> . stmt_expr ;
    (42) stmt -> . BREAK ;
    (43) stmt -> . CONTINUE ;
    (44) stmt -> . block
    (45) stmt -> . var_decl
    (46) stmt -> . ;
    (96) stmt_expr -> . assign
    (97) stmt_expr -> . method_invocation
    (33) block -> . { stmt }
    (34) block -> . { }
    (17) var_decl -> . type variables ;
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INT_CONST resolved as shift
  ! shift/reduce conflict for FLOAT_CONST resolved as shift
  ! shift/reduce conflict for STRING_CONST resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    }               reduce using rule 38 (stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 38 (stmt -> WHILE ( expr ) stmt .)
    IF              shift and go to state 63
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    RETURN          shift and go to state 68
    BREAK           shift and go to state 70
    CONTINUE        shift and go to state 71
    ;               shift and go to state 67
    {               shift and go to state 57
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 80
    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91

  ! IF              [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! WHILE           [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! FOR             [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! RETURN          [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! BREAK           [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! CONTINUE        [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! ;               [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! {               [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! PLUS            [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! MINUS           [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! INT             [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! FLOAT           [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! BOOLEAN         [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! ID              [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! THIS            [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! SUPER           [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! (               [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! NEW             [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! INT_CONST       [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! FLOAT_CONST     [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! STRING_CONST    [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! NULL            [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! TRUE            [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]
  ! FALSE           [ reduce using rule 38 (stmt -> WHILE ( expr ) stmt .) ]

    stmt                           shift and go to state 93
    stmt_expr                      shift and go to state 69
    block                          shift and go to state 72
    var_decl                       shift and go to state 73
    assign                         shift and go to state 74
    method_invocation              shift and go to state 75
    type                           shift and go to state 76
    field_access                   shift and go to state 77
    primary                        shift and go to state 81
    literal                        shift and go to state 82

state 165

    (39) stmt -> FOR ( optional_stmt_expr ; optional_expr . ; optional_stmt_expr ) stmt

    ;               shift and go to state 169


state 166

    (66) arguments -> expr , arguments .

    )               reduce using rule 66 (arguments -> expr , arguments .)


state 167

    (61) primary -> NEW ID ( arguments ) .

    .               reduce using rule 61 (primary -> NEW ID ( arguments ) .)
    )               reduce using rule 61 (primary -> NEW ID ( arguments ) .)
    PLUS            reduce using rule 61 (primary -> NEW ID ( arguments ) .)
    MINUS           reduce using rule 61 (primary -> NEW ID ( arguments ) .)
    TIMES           reduce using rule 61 (primary -> NEW ID ( arguments ) .)
    DIVIDE          reduce using rule 61 (primary -> NEW ID ( arguments ) .)
    AND             reduce using rule 61 (primary -> NEW ID ( arguments ) .)
    OR              reduce using rule 61 (primary -> NEW ID ( arguments ) .)
    EQUALITY        reduce using rule 61 (primary -> NEW ID ( arguments ) .)
    INEQUALITY      reduce using rule 61 (primary -> NEW ID ( arguments ) .)
    LESSER          reduce using rule 61 (primary -> NEW ID ( arguments ) .)
    GREATER         reduce using rule 61 (primary -> NEW ID ( arguments ) .)
    LEQ             reduce using rule 61 (primary -> NEW ID ( arguments ) .)
    GEQ             reduce using rule 61 (primary -> NEW ID ( arguments ) .)
    ;               reduce using rule 61 (primary -> NEW ID ( arguments ) .)
    ,               reduce using rule 61 (primary -> NEW ID ( arguments ) .)


state 168

    (36) stmt -> IF ( expr ) stmt ELSE . stmt
    (35) stmt -> . stmt stmt
    (36) stmt -> . IF ( expr ) stmt ELSE stmt
    (37) stmt -> . IF ( expr ) stmt
    (38) stmt -> . WHILE ( expr ) stmt
    (39) stmt -> . FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (40) stmt -> . RETURN optional_expr ;
    (41) stmt -> . stmt_expr ;
    (42) stmt -> . BREAK ;
    (43) stmt -> . CONTINUE ;
    (44) stmt -> . block
    (45) stmt -> . var_decl
    (46) stmt -> . ;
    (96) stmt_expr -> . assign
    (97) stmt_expr -> . method_invocation
    (33) block -> . { stmt }
    (34) block -> . { }
    (17) var_decl -> . type variables ;
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE

    IF              shift and go to state 63
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    RETURN          shift and go to state 68
    BREAK           shift and go to state 70
    CONTINUE        shift and go to state 71
    ;               shift and go to state 67
    {               shift and go to state 57
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 80
    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91

    stmt                           shift and go to state 170
    stmt_expr                      shift and go to state 69
    block                          shift and go to state 72
    var_decl                       shift and go to state 73
    assign                         shift and go to state 74
    method_invocation              shift and go to state 75
    type                           shift and go to state 76
    field_access                   shift and go to state 77
    primary                        shift and go to state 81
    literal                        shift and go to state 82

state 169

    (39) stmt -> FOR ( optional_stmt_expr ; optional_expr ; . optional_stmt_expr ) stmt
    (49) optional_stmt_expr -> . stmt_expr
    (50) optional_stmt_expr -> . empty
    (96) stmt_expr -> . assign
    (97) stmt_expr -> . method_invocation
    (98) empty -> .
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE

    )               reduce using rule 98 (empty -> .)
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    ID              shift and go to state 100
    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91

    optional_stmt_expr             shift and go to state 171
    stmt_expr                      shift and go to state 141
    empty                          shift and go to state 142
    assign                         shift and go to state 74
    method_invocation              shift and go to state 75
    field_access                   shift and go to state 77
    primary                        shift and go to state 81
    literal                        shift and go to state 82

state 170

    (36) stmt -> IF ( expr ) stmt ELSE stmt .
    (35) stmt -> stmt . stmt
    (35) stmt -> . stmt stmt
    (36) stmt -> . IF ( expr ) stmt ELSE stmt
    (37) stmt -> . IF ( expr ) stmt
    (38) stmt -> . WHILE ( expr ) stmt
    (39) stmt -> . FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (40) stmt -> . RETURN optional_expr ;
    (41) stmt -> . stmt_expr ;
    (42) stmt -> . BREAK ;
    (43) stmt -> . CONTINUE ;
    (44) stmt -> . block
    (45) stmt -> . var_decl
    (46) stmt -> . ;
    (96) stmt_expr -> . assign
    (97) stmt_expr -> . method_invocation
    (33) block -> . { stmt }
    (34) block -> . { }
    (17) var_decl -> . type variables ;
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INT_CONST resolved as shift
  ! shift/reduce conflict for FLOAT_CONST resolved as shift
  ! shift/reduce conflict for STRING_CONST resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    }               reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              shift and go to state 63
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    RETURN          shift and go to state 68
    BREAK           shift and go to state 70
    CONTINUE        shift and go to state 71
    ;               shift and go to state 67
    {               shift and go to state 57
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 80
    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91

  ! IF              [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! WHILE           [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! FOR             [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! RETURN          [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! BREAK           [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! CONTINUE        [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! ;               [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! {               [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! PLUS            [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! MINUS           [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! INT             [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! FLOAT           [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! BOOLEAN         [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! ID              [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! THIS            [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! SUPER           [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! (               [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! NEW             [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! INT_CONST       [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! FLOAT_CONST     [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! STRING_CONST    [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! NULL            [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! TRUE            [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]
  ! FALSE           [ reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .) ]

    stmt                           shift and go to state 93
    stmt_expr                      shift and go to state 69
    block                          shift and go to state 72
    var_decl                       shift and go to state 73
    assign                         shift and go to state 74
    method_invocation              shift and go to state 75
    type                           shift and go to state 76
    field_access                   shift and go to state 77
    primary                        shift and go to state 81
    literal                        shift and go to state 82

state 171

    (39) stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr . ) stmt

    )               shift and go to state 172


state 172

    (39) stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) . stmt
    (35) stmt -> . stmt stmt
    (36) stmt -> . IF ( expr ) stmt ELSE stmt
    (37) stmt -> . IF ( expr ) stmt
    (38) stmt -> . WHILE ( expr ) stmt
    (39) stmt -> . FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (40) stmt -> . RETURN optional_expr ;
    (41) stmt -> . stmt_expr ;
    (42) stmt -> . BREAK ;
    (43) stmt -> . CONTINUE ;
    (44) stmt -> . block
    (45) stmt -> . var_decl
    (46) stmt -> . ;
    (96) stmt_expr -> . assign
    (97) stmt_expr -> . method_invocation
    (33) block -> . { stmt }
    (34) block -> . { }
    (17) var_decl -> . type variables ;
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE

    IF              shift and go to state 63
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    RETURN          shift and go to state 68
    BREAK           shift and go to state 70
    CONTINUE        shift and go to state 71
    ;               shift and go to state 67
    {               shift and go to state 57
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 80
    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91

    stmt                           shift and go to state 173
    stmt_expr                      shift and go to state 69
    block                          shift and go to state 72
    var_decl                       shift and go to state 73
    assign                         shift and go to state 74
    method_invocation              shift and go to state 75
    type                           shift and go to state 76
    field_access                   shift and go to state 77
    primary                        shift and go to state 81
    literal                        shift and go to state 82

state 173

    (39) stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .
    (35) stmt -> stmt . stmt
    (35) stmt -> . stmt stmt
    (36) stmt -> . IF ( expr ) stmt ELSE stmt
    (37) stmt -> . IF ( expr ) stmt
    (38) stmt -> . WHILE ( expr ) stmt
    (39) stmt -> . FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt
    (40) stmt -> . RETURN optional_expr ;
    (41) stmt -> . stmt_expr ;
    (42) stmt -> . BREAK ;
    (43) stmt -> . CONTINUE ;
    (44) stmt -> . block
    (45) stmt -> . var_decl
    (46) stmt -> . ;
    (96) stmt_expr -> . assign
    (97) stmt_expr -> . method_invocation
    (33) block -> . { stmt }
    (34) block -> . { }
    (17) var_decl -> . type variables ;
    (76) assign -> . field_access ASSIGN expr
    (77) assign -> . field_access PLUS PLUS
    (78) assign -> . PLUS PLUS field_access
    (79) assign -> . field_access MINUS MINUS
    (80) assign -> . MINUS MINUS field_access
    (69) method_invocation -> . field_access ( arguments )
    (70) method_invocation -> . field_access ( )
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (67) field_access -> . primary . ID
    (68) field_access -> . ID
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . ( expr )
    (61) primary -> . NEW ID ( arguments )
    (62) primary -> . NEW ID ( )
    (63) primary -> . field_access
    (64) primary -> . method_invocation
    (51) literal -> . INT_CONST
    (52) literal -> . FLOAT_CONST
    (53) literal -> . STRING_CONST
    (54) literal -> . NULL
    (55) literal -> . TRUE
    (56) literal -> . FALSE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for ; resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INT_CONST resolved as shift
  ! shift/reduce conflict for FLOAT_CONST resolved as shift
  ! shift/reduce conflict for STRING_CONST resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    }               reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .)
    ELSE            reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .)
    IF              shift and go to state 63
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    RETURN          shift and go to state 68
    BREAK           shift and go to state 70
    CONTINUE        shift and go to state 71
    ;               shift and go to state 67
    {               shift and go to state 57
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    BOOLEAN         shift and go to state 28
    ID              shift and go to state 80
    THIS            shift and go to state 83
    SUPER           shift and go to state 84
    (               shift and go to state 64
    NEW             shift and go to state 85
    INT_CONST       shift and go to state 86
    FLOAT_CONST     shift and go to state 87
    STRING_CONST    shift and go to state 88
    NULL            shift and go to state 89
    TRUE            shift and go to state 90
    FALSE           shift and go to state 91

  ! IF              [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! WHILE           [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! FOR             [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! RETURN          [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! BREAK           [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! CONTINUE        [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! ;               [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! {               [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! PLUS            [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! MINUS           [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! INT             [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! FLOAT           [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! BOOLEAN         [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! ID              [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! THIS            [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! SUPER           [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! (               [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! NEW             [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! INT_CONST       [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! FLOAT_CONST     [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! STRING_CONST    [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! NULL            [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! TRUE            [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]
  ! FALSE           [ reduce using rule 39 (stmt -> FOR ( optional_stmt_expr ; optional_expr ; optional_stmt_expr ) stmt .) ]

    stmt                           shift and go to state 93
    stmt_expr                      shift and go to state 69
    block                          shift and go to state 72
    var_decl                       shift and go to state 73
    assign                         shift and go to state 74
    method_invocation              shift and go to state 75
    type                           shift and go to state 76
    field_access                   shift and go to state 77
    primary                        shift and go to state 81
    literal                        shift and go to state 82
WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for CLASS in state 5 resolved as shift
WARNING: shift/reduce conflict for PRIVATE in state 20 resolved as shift
WARNING: shift/reduce conflict for PUBLIC in state 20 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 20 resolved as shift
WARNING: shift/reduce conflict for IF in state 93 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 93 resolved as shift
WARNING: shift/reduce conflict for FOR in state 93 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 93 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 93 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 93 resolved as shift
WARNING: shift/reduce conflict for ; in state 93 resolved as shift
WARNING: shift/reduce conflict for { in state 93 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 93 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 93 resolved as shift
WARNING: shift/reduce conflict for INT in state 93 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 93 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 93 resolved as shift
WARNING: shift/reduce conflict for ID in state 93 resolved as shift
WARNING: shift/reduce conflict for THIS in state 93 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 93 resolved as shift
WARNING: shift/reduce conflict for ( in state 93 resolved as shift
WARNING: shift/reduce conflict for NEW in state 93 resolved as shift
WARNING: shift/reduce conflict for INT_CONST in state 93 resolved as shift
WARNING: shift/reduce conflict for FLOAT_CONST in state 93 resolved as shift
WARNING: shift/reduce conflict for STRING_CONST in state 93 resolved as shift
WARNING: shift/reduce conflict for NULL in state 93 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 93 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 93 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 101 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 101 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 138 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 138 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 138 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 138 resolved as shift
WARNING: shift/reduce conflict for AND in state 138 resolved as shift
WARNING: shift/reduce conflict for OR in state 138 resolved as shift
WARNING: shift/reduce conflict for EQUALITY in state 138 resolved as shift
WARNING: shift/reduce conflict for INEQUALITY in state 138 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 138 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 138 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 138 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 138 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 155 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 155 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 155 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 155 resolved as shift
WARNING: shift/reduce conflict for AND in state 155 resolved as shift
WARNING: shift/reduce conflict for OR in state 155 resolved as shift
WARNING: shift/reduce conflict for EQUALITY in state 155 resolved as shift
WARNING: shift/reduce conflict for INEQUALITY in state 155 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 155 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 155 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 155 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 155 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 156 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 156 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 156 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 156 resolved as shift
WARNING: shift/reduce conflict for AND in state 156 resolved as shift
WARNING: shift/reduce conflict for OR in state 156 resolved as shift
WARNING: shift/reduce conflict for EQUALITY in state 156 resolved as shift
WARNING: shift/reduce conflict for INEQUALITY in state 156 resolved as shift
WARNING: shift/reduce conflict for LESSER in state 156 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 156 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 156 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 156 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 163 resolved as shift
WARNING: shift/reduce conflict for IF in state 163 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 163 resolved as shift
WARNING: shift/reduce conflict for FOR in state 163 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 163 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 163 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 163 resolved as shift
WARNING: shift/reduce conflict for ; in state 163 resolved as shift
WARNING: shift/reduce conflict for { in state 163 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 163 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 163 resolved as shift
WARNING: shift/reduce conflict for INT in state 163 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 163 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 163 resolved as shift
WARNING: shift/reduce conflict for ID in state 163 resolved as shift
WARNING: shift/reduce conflict for THIS in state 163 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 163 resolved as shift
WARNING: shift/reduce conflict for ( in state 163 resolved as shift
WARNING: shift/reduce conflict for NEW in state 163 resolved as shift
WARNING: shift/reduce conflict for INT_CONST in state 163 resolved as shift
WARNING: shift/reduce conflict for FLOAT_CONST in state 163 resolved as shift
WARNING: shift/reduce conflict for STRING_CONST in state 163 resolved as shift
WARNING: shift/reduce conflict for NULL in state 163 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 163 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 163 resolved as shift
WARNING: shift/reduce conflict for IF in state 164 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 164 resolved as shift
WARNING: shift/reduce conflict for FOR in state 164 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 164 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 164 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 164 resolved as shift
WARNING: shift/reduce conflict for ; in state 164 resolved as shift
WARNING: shift/reduce conflict for { in state 164 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 164 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 164 resolved as shift
WARNING: shift/reduce conflict for INT in state 164 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 164 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 164 resolved as shift
WARNING: shift/reduce conflict for ID in state 164 resolved as shift
WARNING: shift/reduce conflict for THIS in state 164 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 164 resolved as shift
WARNING: shift/reduce conflict for ( in state 164 resolved as shift
WARNING: shift/reduce conflict for NEW in state 164 resolved as shift
WARNING: shift/reduce conflict for INT_CONST in state 164 resolved as shift
WARNING: shift/reduce conflict for FLOAT_CONST in state 164 resolved as shift
WARNING: shift/reduce conflict for STRING_CONST in state 164 resolved as shift
WARNING: shift/reduce conflict for NULL in state 164 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 164 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 164 resolved as shift
WARNING: shift/reduce conflict for IF in state 170 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 170 resolved as shift
WARNING: shift/reduce conflict for FOR in state 170 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 170 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 170 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 170 resolved as shift
WARNING: shift/reduce conflict for ; in state 170 resolved as shift
WARNING: shift/reduce conflict for { in state 170 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 170 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 170 resolved as shift
WARNING: shift/reduce conflict for INT in state 170 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 170 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 170 resolved as shift
WARNING: shift/reduce conflict for ID in state 170 resolved as shift
WARNING: shift/reduce conflict for THIS in state 170 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 170 resolved as shift
WARNING: shift/reduce conflict for ( in state 170 resolved as shift
WARNING: shift/reduce conflict for NEW in state 170 resolved as shift
WARNING: shift/reduce conflict for INT_CONST in state 170 resolved as shift
WARNING: shift/reduce conflict for FLOAT_CONST in state 170 resolved as shift
WARNING: shift/reduce conflict for STRING_CONST in state 170 resolved as shift
WARNING: shift/reduce conflict for NULL in state 170 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 170 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 170 resolved as shift
WARNING: shift/reduce conflict for IF in state 173 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 173 resolved as shift
WARNING: shift/reduce conflict for FOR in state 173 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 173 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 173 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 173 resolved as shift
WARNING: shift/reduce conflict for ; in state 173 resolved as shift
WARNING: shift/reduce conflict for { in state 173 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 173 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 173 resolved as shift
WARNING: shift/reduce conflict for INT in state 173 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 173 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 173 resolved as shift
WARNING: shift/reduce conflict for ID in state 173 resolved as shift
WARNING: shift/reduce conflict for THIS in state 173 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 173 resolved as shift
WARNING: shift/reduce conflict for ( in state 173 resolved as shift
WARNING: shift/reduce conflict for NEW in state 173 resolved as shift
WARNING: shift/reduce conflict for INT_CONST in state 173 resolved as shift
WARNING: shift/reduce conflict for FLOAT_CONST in state 173 resolved as shift
WARNING: shift/reduce conflict for STRING_CONST in state 173 resolved as shift
WARNING: shift/reduce conflict for NULL in state 173 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 173 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 173 resolved as shift
WARNING: reduce/reduce conflict in state 20 resolved using rule (class_body_decl -> class_body_decl class_body_decl)
WARNING: rejected rule (empty -> <empty>) in state 20
